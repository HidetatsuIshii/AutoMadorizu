<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto間取り図</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1588.0.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
        }
        .accordion-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.7s ease-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-out;
            margin-top: 0 !important; /* 閉じている時はmarginをなくす */
        }
        .accordion-content-open {
            max-height: 1500px; /* 内容が十分収まる高さを指定 */
            opacity: 1;
            margin-top: 1rem !important; /* 開いている時はmarginを適用(mt-4相当) */
        }
        .arrow-icon {
            transition: transform 0.3s ease-in-out;
        }
        .arrow-icon-open {
            transform: rotate(0deg);
        }
        .arrow-icon-closed {
            transform: rotate(-90deg);
        }
        .editor-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        .scroll-wrapper {
            width: 5000px;
            height: 5000px;
            position: relative;
        }
        .editor-container {
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .editor-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            max-width: 100%;
            max-height: 100%;
        }
        .editor-canvas, .editor-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .editor-svg {
            pointer-events: all;
            user-select: none;          /* 標準のブラウザ */
            -webkit-user-select: none;  /* Chrome, Safari */
            -moz-user-select: none;     /* Firefox */
            -ms-user-select: none;      /* Internet Explorer/Edge */
        }
        .editor-svg > * {
            pointer-events: all;
        }
        .cursor-crosshair { cursor: crosshair; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-default { cursor: default; }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.4L159.2%2C69.7c-3.1-3.1-8.2-3.1-11.3%2C0L5.4%2C197.4c-3.1%2C3.1-3.1%2C8.2%2C0%2C11.3l11.3%2C11.3c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l115.4-115.4l115.4%2C115.4c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l11.3-11.3C290.1%2C205.6%2C290.1%2C200.5%2C287%2C197.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem 0.8rem;
            padding-right: 2.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
        }
        select:focus {
            border-color: #6366F1;
            box-shadow: 0 0 0 1px #6366F1;
            outline: none;
        }
        .transparent-bg {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useLayoutEffect } = React;

        // --- 定数とダミーデータ ---
        const DUMMY_OCR_DATA = {
            "Blocks": [
                { "id": "block-1", "type": "LDK", "Text": "LDK 12.5帖", "Geometry": { "BoundingBox": { "Width": 0.25, "Height": 0.05, "Left": 0.4, "Top": 0.5 }}},
                { "id": "block-2", "type": "洋室", "Text": "洋室 6.0帖", "Geometry": { "BoundingBox": { "Width": 0.2, "Height": 0.05, "Left": 0.1, "Top": 0.2 }}},
                { "id": "block-3", "type": "浴室", "Text": "浴室", "Geometry": { "BoundingBox": { "Width": 0.1, "Height": 0.04, "Left": 0.7, "Top": 0.2 }}},
                { "id": "block-4", "type": "収納", "Text": "WIC", "Geometry": { "BoundingBox": { "Width": 0.08, "Height": 0.04, "Left": 0.15, "Top": 0.4 }}}
            ]
        };
        const SPACE_TYPES = {
            main: ["LDK", "DK", "K", "居室", "和室", "収納", "洗面所", "浴室", "トイレ", "廊下", "玄関", "バルコニー"],
            sub: ["柱", "吹抜", "グルニエ", "折上天井", "床下収納", "カウンター", "棚", "下足入", "冷蔵庫", "洗濯機", "PS", "MB"]
        };
        const FONT_FAMILIES = [
            { id: 'sans-serif', name: 'ゴシック体' },
            { id: 'serif', name: '明朝体' },
            { id: 'monospace', name: '等幅フォント' },
            { id: 'cursive', name: '筆記体' }
        ];
        const SNAP_THRESHOLD = 10;
        const DEFAULT_WIDTH = 1200;
        const DEFAULT_HEIGHT = 900;
        const SELECTED_ELEMENT_COLOR = '#3b82f6';
        const DEFAULT_STROKE_COLOR = '#000000';
        const DEFAULT_STROKE_WIDTH = 5;
        const DEFAULT_STAIR_WIDTH = 50;
        const BASE_FIXTURE_DEFAULT_SIZE = 50; // 設備の基準サイズ

        const LINE_STYLES = [
            { id: 'solid', name: '実線', dashArray: 'none' },
            { id: 'dashed', name: '破線', dashArray: '10, 5' },
            { id: 'dotted', name: '点線', dashArray: '2, 5' },
            { id: 'chain', name: '一点鎖線', dashArray: '10, 4, 2, 4' },
            { id: 'double-chain', name: '二点鎖線', dashArray: '10, 4, 2, 4, 2, 4' },
            { id: 'double', name: '二重線', dashArray: null }
        ];
        
        const BACKGROUND_PATTERNS = [
            { id: 'none', name: 'なし' },
            { id: 'vertical-lines', name: '縦線' },
            { id: 'horizontal-lines', name: '横線' },
            { id: 'grid-small', name: '格子小' },
            { id: 'grid-large', name: '格子大' },
            { id: 'dotted-x', name: '点線バツ印' },
            { id: 'solid-x', name: '実線バツ印' },
            { id: 'dotted-triangle', name: '点線三角' },
            { id: 'solid-triangle', name: '実線三角' }
        ];

        const DEFAULT_FILL_COLORS = {
            "LDK": "#fef3c7", "DK": "#fef3c7", "K": "#fef3c7",
            "居室": "#f5e5d4",
            "和室": "#dcfce7",
            "収納": "#fef9c3",
            "洗面所": "#dbeafe",
            "浴室": "#dbeafe",
            "トイレ": "#dbeafe",
            "廊下": "rgb(245, 229, 212)",
            "玄関": "#dedede",
            "バルコニー": "#f5f5f5",
            "柱": "#000000",
            "吹抜": "none",
            "グルニエ": "none",
            "折上天井": "none",
            "床下収納": "none",
            "カウンター": "#CD924C",
            "棚": "#CD924C",
            "下足入": "#CD924C",
            "冷蔵庫": "none",
            "洗濯機": "none",
            "PS": "#ffffff",
            "MB": "#ffffff",
            "その他": "#fafafa"
        };
        
        const SUB_TYPE_PROPERTIES = {
            "吹抜": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "グルニエ": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "折上天井": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "冷蔵庫": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "洗濯機": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "床下収納": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "カウンター": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "棚": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "下足入": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "PS": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#ffffff' },
            "MB": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#ffffff' },
            "柱": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#000000' }
        };

        const COMPASS_TEMPLATES = [
            { id: 'dsynbol01', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol01.svg'},
            { id: 'dsynbol02', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol02.svg'},
            { id: 'dsynbol03', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol03.svg'},
            { id: 'dsynbol04', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol04.svg'},
            { id: 'dsynbol05', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol05.svg'},
            { id: 'dsynbol06', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol06.svg'},
            { id: 'dsynbol07', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol07.svg'},
            { id: 'dsynbol08', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol08.svg'},
            { id: 'dsynbol09', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol09.svg'},
            { id: 'dsynbol10', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol10.svg'},
            { id: 'dsynbol11', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol11.svg'}
        ];

        const FIXTURE_TEMPLATES = {
            kitchen: [
                { id: 'kitchen01-from-svg', name: 'キッチン01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen01.svg', defaultSize: 20, aspectRatio: 128 / 49, },
                { id: 'kitchen02-from-svg', name: 'キッチン02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen02.svg', defaultSize: 20, aspectRatio: 128 / 48, },
                { id: 'kitchen03-from-svg', name: 'キッチン03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen03.svg', defaultSize: 20, aspectRatio: 128 / 58, },
                { id: 'kitchen04-from-svg', name: 'キッチン04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen04.svg', defaultSize: 15, aspectRatio: 175 / 49, },
                { id: 'kitchen05-from-svg', name: 'キッチン05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen05.svg', defaultSize: 15, aspectRatio: 175 / 58, },
                { id: 'kitchen06-from-svg', name: 'キッチン06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen06.svg', defaultSize: 24, aspectRatio: 102 / 114, },
                { id: 'kitchen07-from-svg', name: 'キッチン07', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen07.svg', defaultSize: 21, aspectRatio: 124 / 114, },
                { id: 'kitchen08-from-svg', name: 'キッチン08', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen08.svg', defaultSize: 15, aspectRatio: 175 / 114, },
                { id: 'kitchen09-from-svg', name: 'キッチン09', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen09.svg', defaultSize: 15, aspectRatio: 174 / 85, },
                { id: 'kitchen10-from-svg', name: 'キッチン10', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen10.svg', defaultSize: 58, aspectRatio: 38 / 34, },
                { id: 'kitchen11-from-svg', name: 'キッチン11', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen11.svg', defaultSize: 36, aspectRatio: 61 / 34, },
                { id: 'kitchen12-from-svg', name: 'キッチン12', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen12.svg', defaultSize: 20, aspectRatio: 129 / 40, },
                { id: 'kitchen13-from-svg', name: 'キッチン13', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen13.svg', defaultSize: 21, aspectRatio: 128 / 115, },
                { id: 'kitchen14-from-svg', name: 'キッチン14', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen14.svg', defaultSize: 15, aspectRatio: 174 / 85, },
                { id: 'kitchen15-from-svg', name: 'キッチン15', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen15.svg', defaultSize: 55, aspectRatio: 50 / 31, },
                { id: 'kitchen16-from-svg', name: 'キッチン16', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen16.svg', defaultSize: 55, aspectRatio: 44 / 35, },
                { id: 'kitchen17-from-svg', name: 'キッチン17', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen17.svg', defaultSize: 55, aspectRatio: 48 / 32, },
                { id: 'kitchen18-from-svg', name: 'キッチン18', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen18.svg', defaultSize: 55, aspectRatio: 42 / 44, }
            ],
            washroom: [
                { id: 'washroom01-from-svg', name: '洗面01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen01.svg', defaultSize: 50, aspectRatio: 139 / 84, },
                { id: 'washroom02-from-svg', name: '洗面02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen02.svg', defaultSize: 50, aspectRatio: 126 / 85, },
                { id: 'washroom03-from-svg', name: '洗面03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen03.svg', defaultSize: 50, aspectRatio: 122 / 62, },
                { id: 'washroom04-from-svg', name: '洗面04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen04.svg', defaultSize: 50, aspectRatio: 121 / 102, },
                { id: 'washroom05-from-svg', name: '洗面05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen05.svg', defaultSize: 50, aspectRatio: 115 / 52, },
                { id: 'washroom06-from-svg', name: '洗面06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen06.svg', defaultSize: 50, aspectRatio: 121 / 96, }
            
            ],
            bathroom: [
                { id: 'bathtub01-from-svg', name: 'お風呂01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo01.svg', defaultSize: 30, aspectRatio: 173 / 107, },
                { id: 'bathtub02-from-svg', name: 'お風呂02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo02.svg', defaultSize: 30, aspectRatio: 173 / 97, },
                { id: 'bathtub03-from-svg', name: 'お風呂03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo03.svg', defaultSize: 30, aspectRatio: 202 / 108, },
                { id: 'bathtub04-from-svg', name: 'お風呂04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo04.svg', defaultSize: 30, aspectRatio: 194 / 96, },
                { id: 'bathtub05-from-svg', name: 'お風呂05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo05.svg', defaultSize: 30, aspectRatio: 195 / 106, },
                { id: 'bathtub06-from-svg', name: 'お風呂06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo06.svg', defaultSize: 30, aspectRatio: 189 / 97, },
                { id: 'bathtub07-from-svg', name: 'お風呂07', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo07.svg', defaultSize: 30, aspectRatio: 185 / 95, },
                { id: 'bathtub08-from-svg', name: 'お風呂08', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo08.svg', defaultSize: 30, aspectRatio: 183 / 107, },
                { id: 'bathtub09-from-svg', name: 'お風呂09', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo09.svg', defaultSize: 80, aspectRatio: 78 / 62, },
                { id: 'bathtub10-from-svg', name: 'お風呂10', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo10.svg', defaultSize: 80, aspectRatio: 91 / 57, }
            ],
            toilet: [
                { id: 'toilet01-from-svg', name: 'トイレ01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet01.svg', defaultSize: 100, aspectRatio: 76 / 140, },
                { id: 'toilet02-from-svg', name: 'トイレ02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet02.svg', defaultSize: 80, aspectRatio: 87 / 122, },
                { id: 'toilet03-from-svg', name: 'トイレ03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet03.svg', defaultSize: 80, aspectRatio: 82 / 121, },
                { id: 'toilet04-from-svg', name: 'トイレ04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet04.svg', defaultSize: 100, aspectRatio: 78 / 136, },
                { id: 'toilet05-from-svg', name: 'トイレ05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet05.svg', defaultSize: 100, aspectRatio: 74 / 121, },
                { id: 'toilet06-from-svg', name: 'トイレ06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet06.svg', defaultSize: 100, aspectRatio: 76 / 121, },
                { id: 'toilet07-from-svg', name: 'トイレ07', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet07.svg', defaultSize: 100, aspectRatio: 75 / 131, },
                { id: 'toilet08-from-svg', name: 'トイレ08', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet08.svg', defaultSize: 100, aspectRatio: 66 / 116, },
                { id: 'toilet09-from-svg', name: 'トイレ09', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet09.svg', defaultSize: 100, aspectRatio: 80 / 122, },
                { id: 'toilet10-from-svg', name: 'トイレ10', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet10.svg', defaultSize: 70, aspectRatio: 126 / 61, },
                { id: 'toilet11-from-svg', name: 'トイレ11', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet11.svg', defaultSize: 100, aspectRatio: 69 / 75, },
                { id: 'toilet12-from-svg', name: 'トイレ12', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet12.svg', defaultSize: 200, aspectRatio: 41 / 36, }
            
            ],
            livingDining: [
                { id: 'dining-table-round', name: '円形テーブル', path: 'M0,0 A15,15 0 1,0 0,0.001 Z', defaultSize: 40, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dining-table-rect', name: '長方形テーブル', path: 'M-25,-15 H25 V15 H-25 Z', defaultSize: 50, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-single', name: '一人掛けソファ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 V0 M10,-10 V0', defaultSize: 40, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-double', name: '二人掛けソファ', path: 'M-30,-10 H30 V10 H-30 Z M-25,-10 V0 M25,-10 V0', defaultSize: 60, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'tv-stand', name: 'テレビ台', path: 'M-20,-5 H20 V5 H-20 Z', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bookshelf', name: '本棚', path: 'M-15,-20 H15 V20 H-15 Z M-10,-15 H10 M-10,0 H10 M-10,15 H10', defaultSize: 45, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bedroom: [
                { id: 'bed-single', name: 'シングルベッド', path: 'M-20,-15 H20 V15 H-20 Z M-15,-15 H15 V-5 H-15 Z', defaultSize: 50, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bed-double', name: 'ダブルベッド', path: 'M-30,-20 H30 V20 H-30 Z M-25,-20 H25 V-5 H-25 Z', defaultSize: 60, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'closet', name: 'クローゼット', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20', defaultSize: 40, defaultFill: '#f5deb3', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dresser', name: 'ドレッサー', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'nightstand', name: 'ナイトスタンド', path: 'M-10,-10 H10 V10 H-10 Z', defaultSize: 20, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'wardrobe', name: 'ワードローブ', path: 'M-20,-25 H20 V25 H-20 Z M-15,-25 V25 M15,-25 V25', defaultSize: 50, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            other: [
                { id: 'desk', name: 'デスク', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 45, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'fireplace', name: '暖炉', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 L-10,0 L10,0 L10,-10', defaultSize: 30, defaultFill: '#a0a0a0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'piano', name: 'ピアノ', path: 'M-25,-10 H25 V10 H-25 Z M-20,-10 V0 M-15,-10 V0 M-10,-10 V0 M-5,-10 V0 M0,-10 V0 M5,-10 V0 M10,-10 V0 M15,-10 V0 M20,-10 V0', defaultSize: 50, defaultFill: '#303030', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ]
        };

        const FIXTURE_CATEGORIES = [
            { key: 'kitchen', name: 'キッチン' },
            { key: 'washroom', name: '洗面' },
            { key: 'bathroom', name: '浴室' },
            { key: 'toilet', name: 'トイレ' },
            { key: 'livingDining', name: 'リビング' },
            { key: 'bedroom', name: '寝室' },
            { key: 'other', name: 'その他' }
        ];

        const WINDOW_TEMPLATES = [
            // 1. シンプル1
            { 
                id: 'simple-1', 
                name: 'シンプル1',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z'
            },
            // 2. シンプル2
            { 
                id: 'simple-2', 
                name: 'シンプル2',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const overhang = 3; // はみ出し量
                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8'
            },
            // 3. スライド2枚
            {
                id: 'double-sliding',
                name: 'スライド2枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length / 2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M${length / 2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M0,${y_third_2} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${length / 2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M0,-1.7 H23 M17,1.7 H40'
            },
            // 4. スライド3枚
            {
                id: 'triple-sliding',
                name: 'スライド3枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_third_1 = length / 3;
                    const x_third_2 = length * 2 / 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_1} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_2} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M13.3,-8 V8 M26.7,-8 V8 M0,-1.7 H16.3 M10.3,1.7 H29.7 M23.7,-1.7 H40'
            },
            // 5. スライド4枚
            {
                id: 'quadruple-sliding',
                name: 'スライド4枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_quarter_1 = length / 4;
                    const x_quarter_2 = length / 2;
                    const x_quarter_3 = length * 3 / 4;

                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_3},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_1} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_2} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M10,-8 V8 M20,-8 V8 M30,-8 V8 M0,-1.7 H13 M7,1.7 H33 M27,-1.7 H40'
            },
            // 6. FIX窓
            { 
                id: 'fix', 
                name: 'FIX窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    return [
                        // 背景と外枠 (シンプル1と同じ)
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        
                        // 追加：中央の横線
                        { d: `M0,0 H${length}`, stroke: 'currentColor', strokeWidth: frameWidth }
                    ];
                },
                // プレビューも修正
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 H40'
            },
            // 7. 縦滑り出し窓
            {
                id: 'vertical-slide-out',
                name: '縦滑り出し窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;

                    // ▼▼▼【修正】isInnerに応じて角度と円弧の向きを変える ▼▼▼
                    const angle = (isInner ? 30 : -30) * Math.PI / 180; // 内開きか外開きか
                    const sweepFlag = isInner ? 1 : 0; // 円弧の描画方向

                    const new_x = length * Math.cos(angle);
                    const new_y = length * Math.sin(angle);

                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M0,0 H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M0,0 L${new_x},${new_y}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length},0 A${length},${length} 0 0 ${sweepFlag} ${new_x},${new_y}`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth, strokeDasharray: '4, 2' }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 H40 M0,0 L34.64,-20 M40,0 A40,40 0 0 0 34.64,-20'
            },
            // 8. 突き出し窓
            {
                id: 'awning-window',
                name: '突き出し窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const edge_inset = length / 8;
                    
                    // ▼▼▼【修正】isInnerに応じて開く方向を変える ▼▼▼
                    const open_dist = isInner ? length / 4 : -length / 4;

                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M0,0 H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${edge_inset},0 L${length/2},${open_dist} L${length - edge_inset},0`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth, strokeDasharray: '4, 2' }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 H40 M5,0 L20,-10 L35,0'
            },
        ];

        const DOOR_TEMPLATES = [
            // 1. 片開きドア
            {
                id: 'single-swing',
                name: '片開きドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const y_center = 0;
                    
                    // isInnerフラグで開く方向（上/下）を制御
                    const openDoorY = isInner ? y_center + length : y_center - length;
                    
                    // ▼▼▼【修正点】ここのフラグを逆にしました▼▼▼
                    const sweepFlag = isInner ? 0 : 1; 
                    
                    return [
                        // 1. 壁に埋め込まれたドア枠
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'currentColor', strokeWidth: 1 },
                        // 2. 90度開いたドア本体（直線）
                        { d: `M${length},${y_center} L${length},${openDoorY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        // 3. 開閉軌跡を示す円弧
                        { d: `M0,${y_center} A${length},${length} 0 0 ${sweepFlag} ${length},${openDoorY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパスは変更なし
                previewPath: 'M0,-5 H40 V5 H0 Z M40,0 L40,-40 M0,0 A40,40 0 0 1 40,-40'
            },

            // 2. 両開きドア
            {
                id: 'double-swing',
                name: '両開きドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const y_center = 0;
                    const halfL = length / 2;

                    // isInnerフラグで開く方向を制御
                    const openDoorY = isInner ? y_center + halfL : y_center - halfL;
                    // 左右のドアで円弧の向きを逆にする
                    const sweepFlagLeft = isInner ? 1 : 0;
                    const sweepFlagRight = isInner ? 0 : 1;

                    return [
                        // 1. 壁に埋め込まれた共通のドア枠
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'currentColor', strokeWidth: 1 },
                        
                        // 2. 左側のドア本体と軌跡
                        { d: `M0,${y_center} L0,${openDoorY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${halfL},${y_center} A${halfL},${halfL} 0 0 ${sweepFlagLeft} 0,${openDoorY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' },

                        // 3. 右側のドア本体と軌跡
                        { d: `M${length},${y_center} L${length},${openDoorY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${halfL},${y_center} A${halfL},${halfL} 0 0 ${sweepFlagRight} ${length},${openDoorY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパス
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 L0,-20 M20,0 A20,20 0 0 0 0,-20 M40,0 L40,-20 M20,0 A20,20 0 0 1 40,-20'
            },

            // 3. 親子ドア
            {
                id: 'uneven-double-swing',
                name: '親子ドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const y_center = 0;
                    
                    // 全体を2:1の比率に分割
                    const parentL = length * 2 / 3;
                    const childL = length * 1 / 3;
                    const pivotX = parentL; // 親ドアと子ドアの境界

                    // isInnerフラグで開く方向を制御
                    const openParentY = isInner ? y_center + parentL : y_center - parentL;
                    const openChildY = isInner ? y_center + childL : y_center - childL;

                    // 左右のドアで円弧の向きを逆にする
                    const sweepFlagParent = isInner ? 1 : 0;
                    const sweepFlagChild = isInner ? 0 : 1;

                    return [
                        // 1. 壁に埋め込まれた共通のドア枠
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'currentColor', strokeWidth: 1 },
                        
                        // 2. 親ドア（大きい方）の本体と軌跡
                        { d: `M0,${y_center} L0,${openParentY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${pivotX},${y_center} A${parentL},${parentL} 0 0 ${sweepFlagParent} 0,${openParentY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' },

                        // 3. 子ドア（小さい方）の本体と軌跡
                        { d: `M${length},${y_center} L${length},${openChildY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${pivotX},${y_center} A${childL},${childL} 0 0 ${sweepFlagChild} ${length},${openChildY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパス (幅40を 27:13 に分割)
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 L0,-27 M27,0 A27,27 0 0 0 0,-27 M40,0 L40,-13 M27,0 A13,13 0 0 1 40,-13'
            },

            // 4. スライド1枚 (白抜き範囲を修正)
            {
                id: 'single-sliding',
                name: 'スライド1枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const frameWidth = 1;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const overhang = 3; 
                    const lineY = y_bottom;

                    const doorStartX = isInner ? 0 : length / 2;
                    const doorEndX = doorStartX + length / 2;
                    let doorPath;
                    if (isInner) {
                        doorPath = `M${doorStartX},${y_bottom} V${y_top} H${doorEndX}`;
                    } else {
                        doorPath = `M${doorEndX},${y_bottom} H${doorStartX} V${y_top}`;
                    }

                    let extensionStartX, extensionEndX;
                    if (isInner) { 
                        extensionStartX = length;
                        extensionEndX = length * 2;
                    } else { 
                        extensionStartX = 0;
                        extensionEndX = -length;
                    }
                    
                    const dashes = [];
                    const dashLength = 5;
                    const gapLength = 5;
                    const patternLength = dashLength + gapLength;
                    for (let i = 0; i < length; i += patternLength) {
                        let startX, endX;
                        if (isInner) {
                            startX = extensionStartX + i;
                            endX = Math.min(startX + dashLength, extensionEndX);
                        } else {
                            startX = extensionStartX - i;
                            endX = Math.max(startX - dashLength, extensionEndX);
                        }
                        dashes.push({
                            d: `M${startX},${lineY} H${endX}`,
                            stroke: 'currentColor',
                            strokeWidth: 1.5
                        });
                    }

                    return [
                        // 1. 最下層：ドア枠の背景
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        
                        // ▼▼▼【ここから修正】「太い白線」を「白い長方形」に変更 ▼▼▼
                        // 2. 白抜き用の背景長方形 (ドアの中心線から下枠まで)
                        { 
                            d: `M${extensionStartX},0 H${extensionEndX} V${y_bottom} H${extensionStartX} Z`,
                            fill: 'white',
                            stroke: 'none'
                        },
                        // ▲▲▲【ここまで修正】▲▲▲

                        // 3. 中間層：ドア枠の線と、ドア本体の線
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: doorPath, fill: 'none', stroke: 'currentColor', strokeWidth: 1.5 },
                        
                        // 4. 最上層：中央の縦線と、黒い点線
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ...dashes
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M40,5 H80'
            },
            
            // 5. スライド2枚 (横線の位置を修正)
            {
                id: 'double-sliding',
                name: 'スライド2枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length / 2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M${length / 2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M0,${y_third_2} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${length / 2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M0,-1.7 H23 M17,1.7 H40'
            },

            // 6. スライド3枚 (横線の位置を修正)
            {
                id: 'triple-sliding',
                name: 'スライド3枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_third_1 = length / 3;
                    const x_third_2 = length * 2 / 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_1} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_2} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M13.3,-8 V8 M26.7,-8 V8 M0,-1.7 H16.3 M10.3,1.7 H29.7 M23.7,-1.7 H40'
            },

            // 7. スライド4枚 (横線の位置を修正)
            {
                id: 'quadruple-sliding',
                name: 'スライド4枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_quarter_1 = length / 4;
                    const x_quarter_2 = length / 2;
                    const x_quarter_3 = length * 3 / 4;

                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_3},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_1} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_2} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M10,-8 V8 M20,-8 V8 M30,-8 V8 M0,-1.7 H13 M7,1.7 H33 M27,-1.7 H40'
            },

            // 8. 片折れ扉
            {
                id: 'single-bifold',
                name: '片折れ扉',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const frameWidth = 1;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const overhang = 3; 

                    // isInnerフラグで三角形の基準辺（底辺）と頂点の位置を動的に変更
                    const triangleBaseY = isInner ? y_bottom : y_top;
                    const triangleTipY = isInner ? triangleBaseY + length / 4 : triangleBaseY - length / 4;

                    return [
                        // 1. ドア枠の背景（白色）
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        // 2. ドア枠の線
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        // 3. 枠の中央にある縦線
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        
                        // 4. 右半分に描画する三角形 (d属性のY座標を修正)
                        { 
                            d: `M${length * 3 / 4},${triangleBaseY} L${length * 7 / 8},${triangleTipY} L${length},${triangleBaseY}`, 
                            fill: 'none', 
                            stroke: 'currentColor', 
                            strokeWidth: 1.5 
                        }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M30,-5 L35,-15 L40,-5'
            },

            // 9. 両折れ扉
            {
                id: 'double-bifold',
                name: '両折れ扉',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const frameWidth = 1;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const overhang = 3; 

                    // isInnerフラグで三角形の向きと基準辺（底辺）を決定
                    const triangleBaseY = isInner ? y_bottom : y_top;
                    const triangleTipY = isInner ? triangleBaseY + length / 4 : triangleBaseY - length / 4;

                    return [
                        // 1. ドア枠の背景（白色）
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        // 2. ドア枠の線
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        // 3. 枠の中央にある縦線
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        
                        // 4. 右半分に描画する三角形
                        { 
                            d: `M${length * 3 / 4},${triangleBaseY} L${length * 7 / 8},${triangleTipY} L${length},${triangleBaseY}`, 
                            fill: 'none', 
                            stroke: 'currentColor', 
                            strokeWidth: 1.5 
                        },
                        // ▼▼▼【追加】左半分に描画する三角形 ▼▼▼
                        { 
                            d: `M0,${triangleBaseY} L${length / 8},${triangleTipY} L${length / 4},${triangleBaseY}`, 
                            fill: 'none', 
                            stroke: 'currentColor', 
                            strokeWidth: 1.5 
                        }
                    ];
                },
                // プレビュー用のSVGパスも更新
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M30,-5 L35,-15 L40,-5 M0,-5 L5,-15 L10,-5'
            },

            // 10. 開口 (左右の線を白枠の高さに合わせる)
            {
                id: 'opening',
                name: '開口',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const padding = 1; // 白抜きを上下に1pxずつ拡大

                    return [
                        // 1. 白抜きの背景 (上下に少し拡大)
                        { d: `M0,${y_top - padding} H${length} V${y_bottom + padding} H0 Z`, fill: 'white', stroke: 'none' },
                        
                        // ▼▼▼【修正点】左右の縦線のY座標にもpaddingを適用 ▼▼▼
                        // 2. 左右の縦線 (白枠と同じ高さにする)
                        { d: `M0,${y_top - padding} V${y_bottom + padding}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' },
                        { d: `M${length},${y_top - padding} V${y_bottom + padding}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパスは変更なし
                previewPath: 'M0,-5 V5 M40,-5 V5'
            },
        ];


        // --- ヘルパー関数 ---
        const isPointOnSegment = (point, lineStart, lineEnd, tolerance = 1) => {
            const dxL = lineEnd.x - lineStart.x;
            const dyL = lineEnd.y - lineStart.y;
            const dxP = point.x - lineStart.x;
            const dyP = point.y - lineStart.y;

            const crossProduct = dxP * dyL - dyP * dxL;
            if (Math.abs(crossProduct) > tolerance) return false;

            const dotProduct = dxP * dxL + dyP * dyL;
            if (dotProduct < 0) return false;

            const squaredLength = dxL * dxL + dyL * dyL;
            if (dotProduct > squaredLength) return false;

            return true;
        };
        
        const getLineIntersection = (p1, p2, p3, p4) => {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            // 平行な線の判定閾値を少し調整して安定性を向上
            if (Math.abs(d) < 1e-8) {
                return null;
            }
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y),
            };
        };

        const getCenterPointForElement = (el, dimensions) => {
                    switch (el.type) {
                        case 'text':
                        case 'fixture':
                        case 'compass':
                            // x, y はパーセンテージで中心座標
                            return {
                                x: el.x / 100 * dimensions.width,
                                y: el.y / 100 * dimensions.height
                            };
                        case 'door':
                        case 'window':
                            // x1,y1,x2,y2 はパーセンテージで始点と終点
                            const x1_px_dw = el.x1 / 100 * dimensions.width;
                            const y1_px_dw = el.y1 / 100 * dimensions.height;
                            const x2_px_dw = el.x2 / 100 * dimensions.width;
                            const y2_px_dw = el.y2 / 100 * dimensions.height;
                            return {
                                x: (x1_px_dw + x2_px_dw) / 2,
                                y: (y1_px_dw + y2_px_dw) / 2
                            };
                        case 'wall':
                            // x1,y1,x2,y2 はピクセルで始点と終点
                            return {
                                x: (el.x1 + el.x2) / 2,
                                y: (el.y1 + el.y2) / 2
                            };
                        case 'space':
                        case 'stairs':
                            // points はピクセル座標
                            const points = el.points.split(' ').map(p_str => ({x: parseFloat(p_str.split(',')[0]), y: parseFloat(p_str.split(',')[1])}));
                            return getPolygonCentroid(points);
                        default:
                            if (el.x !== undefined) { // フォールバック for testRect
                                return { x: el.x + el.width / 2, y: el.y + el.height / 2 };
                            } else if (el.x1 !== undefined) { // フォールバック for testLine
                                return { x: (el.x1 + el.x2) / 2, y: (el.y1 + el.y2) / 2 };
                            }
                            return { x: 0, y: 0 };
                    }
                };

        const getPolygonCentroid = (pts) => {
            if (!pts || pts.length === 0) return { x: 0, y: 0 };
            let first = pts[0], last = pts[pts.length - 1];
            if (first.x !== last.x || first.y !== last.y) pts.push(first);
            let twicearea = 0, x = 0, y = 0, nPts = pts.length, p1, p2, f;
            for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
                p1 = pts[i]; p2 = pts[j];
                f = p1.x * p2.y - p2.x * p1.y;
                twicearea += f;
                x += (p1.x + p2.x) * f;
                y += (p1.y + p2.y) * f;
            }
            f = twicearea * 3;
            if (pts.length > 0 && pts[pts.length - 1] === first) pts.pop();
            if (Math.abs(f) < 1e-6) { // Avoid division by zero for degenerate polygons
                return pts.reduce((acc, p) => ({ x: acc.x + p.x / pts.length, y: acc.y + p.y / pts.length }), { x: 0, y: 0 });
            }
            return { x: x / f, y: y / f };
        };

        const createSpaceLabel = (spaceType, centroid, dimensions) => {
            if (["柱", "その他"].includes(spaceType)) {
                return null;
            }
            
            const text = ["LDK", "DK", "K", "居室", "和室"].includes(spaceType)
                ? `${spaceType}\n◯.◯帖`
                : spaceType;

            const smallFontTypes = ["バルコニー", "トイレ", "浴室", "洗面所", "玄関", "収納", "廊下", ...SPACE_TYPES.sub];
            const fontSize = smallFontTypes.includes(spaceType) ? 10 : 16;

            return {
                id: `text-${Date.now()}`,
                type: 'text',
                x: (centroid.x / dimensions.width) * 100,
                y: (centroid.y / dimensions.height) * 100,
                text: text,
                color: '#000000',
                backgroundColor: 'none',
                fontSize: fontSize,
                fontFamily: 'sans-serif',
                textAlign: 'center',
            };
        };

        const getClosestPointOnWalls = (p, walls) => {
            let closestPoint = null;
            let minDistanceSq = Infinity;

            for (const wall of walls) {
                const p1 = { x: wall.x1, y: wall.y1 };
                const p2 = { x: wall.x2, y: wall.y2 };
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;

                if (dx === 0 && dy === 0) continue;

                const t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / (dx * dx + dy * dy);
                const clampedT = Math.max(0, Math.min(1, t));

                const pointOnLine = {
                    x: p1.x + clampedT * dx,
                    y: p1.y + clampedT * dy
                };

                const distSq = (p.x - pointOnLine.x) ** 2 + (p.y - pointOnLine.y) ** 2;

                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestPoint = pointOnLine;
                }
            }
            return closestPoint;
        };

        // --- UIコンポーネント ---
        const LineStyleSelector = ({ selectedStyle, onChange, isRectShape }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">線の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-1">
                    {LINE_STYLES.map(style => (
                        <button key={style.id} onClick={() => onChange(style.id)} className={`p-2 rounded-md border-2 ${selectedStyle === style.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center justify-center">
                                <svg width="40" height="20" viewBox="0 0 60 20" className="flex-shrink-0">
                                    {style.id === 'double' ? (
                                        <g stroke="black" strokeWidth="1.5">
                                            <line x1="5" y1="7" x2="55" y2="7" />
                                            <line x1="5" y1="13" x2="55" y2="13" />
                                        </g>
                                    ) : (
                                        <line x1="5" y1="10" x2="55" y2="10" stroke="black" strokeWidth="2" strokeDasharray={style.dashArray} strokeLinecap="round" />
                                    )}
                                </svg>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );
        
        const SpaceTypeSelector = ({ selectedType, onChange, spaceTypeTab, setSpaceTypeTab }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">空間タイプ</label>
                <div className="flex bg-gray-200 rounded-lg p-1 mt-2">
                    <button onClick={() => setSpaceTypeTab('main')} className={`w-full py-1 rounded-md text-sm ${spaceTypeTab === 'main' ? 'bg-white shadow' : ''}`}>メイン</button>
                    <button onClick={() => setSpaceTypeTab('sub')} className={`w-full py-1 rounded-md text-sm ${spaceTypeTab === 'sub' ? 'bg-white shadow' : ''}`}>サブ</button>
                </div>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {SPACE_TYPES[spaceTypeTab].map(type => {
                        const isSelected = selectedType === type;
                        const isPillar = type === '柱';
                        const isTransparent = DEFAULT_FILL_COLORS[type] === 'none';
                        const style = {
                            backgroundColor: isTransparent ? 'transparent' : DEFAULT_FILL_COLORS[type],
                            color: isPillar ? 'white' : 'black',
                            border: `1px solid ${isTransparent || DEFAULT_FILL_COLORS[type] === '#ffffff' ? '#ccc' : 'transparent'}`
                        };
                        return (
                            <button
                                key={type}
                                onClick={() => onChange(type)}
                                style={style}
                                className={`p-1 rounded-md text-xs text-center transition-all ${isSelected ? 'ring-2 ring-offset-1 ring-indigo-500' : ''} ${isTransparent ? 'transparent-bg' : ''}`}
                            >
                                {type}
                            </button>
                        );
                    })}
                </div>
            </div>
        );

        const BackgroundSelector = ({ selected, onChange }) => {
            const getPreview = (patternId) => {
                const baseRect = <rect width="40" height="20" fill="#f0f0f0" />;
                switch(patternId) {
                    case 'none': return baseRect;
                    case 'vertical-lines': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M10 0 V20 M20 0 V20 M30 0 V20" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'horizontal-lines': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 5 H40 M0 10 H40 M0 15 H40" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'grid-small': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M10 0 V20 M20 0 V20 M30 0 V20 M0 10 H40" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'grid-large': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M20 0 V20" stroke="#000000" strokeWidth="1" /></>;
                    case 'solid-x': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 20 M0 20 L40 0" stroke="#000000" strokeWidth="1" /></>;
                    case 'dotted-x': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 20 M0 20 L40 0" stroke="#000000" strokeWidth="1" strokeDasharray="2 2" /></>;
                    case 'solid-triangle': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 10 L0 20 Z" stroke="#000000" strokeWidth="1" fill="none" /></>;
                    case 'dotted-triangle': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 10 L0 20 Z" stroke="#000000" strokeWidth="1" fill="none" strokeDasharray="2 2" /></>;
                    default: return baseRect;
                }
            };
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700">背景</label>
                    <div className="mt-2 grid grid-cols-3 gap-2">
                        {BACKGROUND_PATTERNS.map(pattern => (
                            <button
                                key={pattern.id}
                                onClick={() => onChange(pattern.id)}
                                className={`p-2 rounded-md border-2 text-xs ${selected === pattern.id ? 'border-indigo-500 bg-indigo-50' : 'bg-white border-gray-200'} hover:bg-gray-50 flex flex-col items-center justify-center`}
                            >
                                <svg width="40" height="20" className="border border-gray-300 mb-1">
                                    {getPreview(pattern.id)}
                                </svg>
                                {pattern.name}
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const CompassTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">方角の図形</label>
                <div className="mt-2 grid grid-cols-4 gap-1">
                    {COMPASS_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center h-12`}
                        >
                           <img
                                src={template.src}
                                alt={template.id}
                                className="w-8 h-8 object-contain"
                            />
                        </button>
                    ))}
                </div>
            </div>
        );

        const FixtureTemplateSelector = ({
            selectedTemplateId,
            onChange, // テンプレート変更時の関数
            category,
            isFlipped, // 反転しているか (true/false)
            onFlipChange, // 反転状態を変更する関数
            mode // 'create' or 'edit'
        }) => {
            const templates = FIXTURE_TEMPLATES[category] || [];
            return (
                <div>
                    <div className="flex justify-between items-center">
                        <label className="block text-sm font-medium text-gray-700">設備の種類</label>
                        <div className="flex items-center">
                            <input
                                id={`fixture-flip-${mode}`}
                                type="checkbox"
                                checked={isFlipped}
                                onChange={(e) => onFlipChange(e.target.checked)}
                                className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                            />
                            <label htmlFor={`fixture-flip-${mode}`} className="ml-2 text-sm text-gray-700">反転</label>
                        </div>
                    </div>
                    <div className="mt-2 grid grid-cols-4 gap-1">
                        {templates.map(template => (
                            <button key={template.id} onClick={() => onChange(template.id)} className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center`}>
                                <svg width="40" height="40" viewBox="-30 -30 60 60" className="flex-shrink-0">
                                    {template.path ? (
                                        <path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} />
                                    ) : (
                                        <image href={template.src} width="60" height="60" x="-30" y="-30" />
                                    )}
                                </svg>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const DoorTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-xs font-medium text-gray-700">ドアの種類</label>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {DOOR_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-2 rounded border w-full ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}
                        >
                            <div className="flex flex-col items-center space-y-2">
                                <svg width="100" height="80" viewBox="0 0 100 80" className="flex-shrink-0">
                                    <g transform="translate(50, 60)">
                                        <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" transform="translate(-20, -15)" />
                                    </g>
                                </svg>
                                <span className="text-xs text-center">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        const WindowTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-xs font-medium text-gray-700">窓の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {WINDOW_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-2 rounded border w-full ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}
                        >
                            <div className="flex flex-col items-center space-y-2">
                                <svg width="100" height="80" viewBox="0 0 100 80" className="flex-shrink-0">
                                    <g transform="translate(50, 60)">
                                        <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" transform="translate(-20, -15)" />
                                    </g>
                                </svg>
                                <span className="text-xs text-center">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        // --- メインエディタコンポーネント ---
        const UploadModal = ({ isOpen, onClose, onSubmit, isLoading, loadingMessage }) => {
            if (!isOpen) return null;
        
            const [localPreview, setLocalPreview] = useState(null);
            const [localUseAi, setLocalUseAi] = useState(true);
            const fileInputRef = useRef(null);
        
            const handleFileChange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setLocalPreview(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
        
            const handleSubmit = () => {
                if (localPreview) {
                    onSubmit(localPreview, localUseAi);
                }
            };
        
            const handleClose = () => {
                onClose();
                setLocalPreview(null);
                setLocalUseAi(true);
            };
        
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
                        <h3 className="text-lg font-medium leading-6 text-gray-900 mb-4">下絵のアップロード</h3>
                        {isLoading ? (
                            <div className="flex flex-col items-center justify-center h-64">
                                <svg className="animate-spin -ml-1 mr-3 h-10 w-10 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <p className="mt-4 text-gray-600">{loadingMessage}</p>
                            </div>
                        ) : (
                            <>
                                <div className="space-y-4">
                                    <button
                                        type="button"
                                        onClick={() => fileInputRef.current.click()}
                                        className="w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                    >
                                        ファイルを選択
                                        <input
                                            type="file"
                                            ref={fileInputRef}
                                            onChange={handleFileChange}
                                            accept="image/*"
                                            className="hidden"
                                        />
                                    </button>
        
                                    <div className="w-full h-48 bg-gray-100 border-2 border-dashed border-gray-300 rounded-md flex items-center justify-center">
                                        {localPreview ? (
                                            <img src={localPreview} alt="プレビュー" className="max-h-full max-w-full object-contain" />
                                        ) : (
                                            <span className="text-gray-500">プレビュー</span>
                                        )}
                                    </div>
        
                                    <div className="flex items-center">
                                        <input
                                            id="ai-checkbox"
                                            type="checkbox"
                                            checked={localUseAi}
                                            onChange={(e) => setLocalUseAi(e.target.checked)}
                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                        />
                                        <label htmlFor="ai-checkbox" className="ml-2 block text-sm text-gray-900">
                                            AIで読み取る (Amazon Textract)
                                        </label>
                                    </div>
                                </div>
        
                                <div className="mt-6 flex justify-end space-x-3">
                                    <button
                                        type="button"
                                        onClick={handleClose}
                                        className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                    >
                                        キャンセル
                                    </button>
                                    <button
                                        type="button"
                                        onClick={handleSubmit}
                                        disabled={!localPreview}
                                        className="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        決定
                                    </button>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };
        
        function Editor() {
            // --- ステート定義 ---
            const [isSidebarOpen, setSidebarOpen] = useState(true);
            const [isDisplaySettingsOpen, setDisplaySettingsOpen] = useState(true);
            const [isDrawingToolsOpen, setDrawingToolsOpen] = useState(true);
            const [imageUrl, setImageUrl] = useState('');
            const [historyState, setHistoryState] = useState({ past: [], present: { ocrData: null, svgElements: [] }, future: [] });
            const { ocrData: currentOcrData, svgElements } = historyState.present;
            const [editorMode, setEditorMode] = useState('continuous-create'); // 'continuous-create', 'create', 'edit'
            const [drawingMode, setDrawingMode] = useState(null);
            const [spaceShape, setSpaceShape] = useState('rect');
            const [selectedId, setSelectedId] = useState(null);
            const [dimensions, setDimensions] = useState({ width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT });
            const [drawingStartPoint, setDrawingStartPoint] = useState(null);
            const [linePoints, setLinePoints] = useState([]);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [imageOpacity, setImageOpacity] = useState(0.5);
            const [drawingOpacity, setDrawingOpacity] = useState(0.4);
            const [zoom, setZoom] = useState(0.8);
            const [imageScale, setImageScale] = useState(1);
            const [strokeColor, setStrokeColor] = useState(DEFAULT_STROKE_COLOR);
            const [strokeWidth, setStrokeWidth] = useState(DEFAULT_STROKE_WIDTH);
            const [spaceType, setSpaceType] = useState('LDK');
            const [fillColor, setFillColor] = useState(DEFAULT_FILL_COLORS[spaceType]);
            const [lineStyle, setLineStyle] = useState('solid');
            const [backgroundPattern, setBackgroundPattern] = useState('none');
            const [isGridVisible, setGridVisible] = useState(true);
            const [gridSize, setGridSize] = useState(5);
            const [fontSize, setFontSize] = useState(12);
            const [fontFamily, setFontFamily] = useState('sans-serif');
            const [textAlign, setTextAlign] = useState('center');
            const [compassTemplateId, setCompassTemplateId] = useState(COMPASS_TEMPLATES[0].id);
            const [fixtureCategory, setFixtureCategory] = useState('kitchen');
            const [fixtureTemplateId, setFixtureTemplateId] = useState(FIXTURE_TEMPLATES.kitchen[0].id);
            const [fixtureSize, setFixtureSize] = useState(50); // 作成する設備のデフォルトサイズ
            const [fixtureRotation, setFixtureRotation] = useState(0); // 作成する設備のデフォルト回転角度
            const [fixtureFlip, setFixtureFlip] = useState(false);
            const [pendingFixture, setPendingFixture] = useState(null);
            const [guideLines, setGuideLines] = useState([]);
            const [doorTemplateId, setDoorTemplateId] = useState(DOOR_TEMPLATES[0].id);
            const [windowTemplateId, setWindowTemplateId] = useState(WINDOW_TEMPLATES[0].id);
            const [stairWidth, setStairWidth] = useState(DEFAULT_STAIR_WIDTH);
            const [stairDirection, setStairDirection] = useState('up');
            const [spaceTypeTab, setSpaceTypeTab] = useState('main');
            const [lastFillColor, setLastFillColor] = useState('#ffffff');
            const [editLastFillColor, setEditLastFillColor] = useState('#ffffff');
            const [isPickingColor, setIsPickingColor] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const [resizingHandleInfo, setResizingHandleInfo] = useState(null); // { id, handleIndex, type: 'wall' | 'spaceCorner' | 'spaceEdge' }
            const [isSnappingToStart, setIsSnappingToStart] = useState(false);
            const [isSnapToWall, setSnapToWall] = useState(true);
            const activeSnapWallRef = useRef(null);
            const [wallObjectThickness, setWallObjectThickness] = useState(5);
            const [pendingWindow, setPendingWindow] = useState(null);
            const [imagePosition, setImagePosition] = useState({ x: 0, y: 0 });
            const [snappedInfo, setSnappedInfo] = useState(null);
            const [tooltip, setTooltip] = useState({ visible: false, fading: false, x: 0, y: 0, message: '' });
            const [isModifierKeyDown, setIsModifierKeyDown] = useState(false);
            const [saveStatus, setSaveStatus] = useState('保存済み'); // '保存済み', '未保存', '保存中...', 'エラー'
            const [madorizuName, setMadorizuName] = useState('読み込み中...');
            const [isEditingName, setIsEditingName] = useState(false);
            const isInitialNameLoad = useRef(true);
            const [isUploadModalOpen, setUploadModalOpen] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [originalImageDimensions, setOriginalImageDimensions] = useState(null);

            // --- Ref定義 ---
            const imageRef = useRef(null);
            const tooltipTimers = useRef([]);
            const sidebarRef = useRef(null);
            const imageDragInfo = useRef(null);
            const canvasRef = useRef(null);
            const editorAreaRef = useRef(null);
            const editorContainerRef = useRef(null);
            const svgRef = useRef(null);
            const displaySettingsRef = useRef(null);
            const dragInfo = useRef(null);
            const historyOnActionStart = useRef(null);
            const mouseDownInfo = useRef(null);
            const dragTarget = useRef(null); // Ref to store the potential drag target
            const textEditAreaRef = useRef(null);
            const prevSelectedIdRef = useRef(null);

            const selectedElement = svgElements.find(el => el.id === selectedId);

            const handleSelectedElementUpdate = useCallback((updates) => {
                if (!selectedId) return;
                 setHistoryState(prevState => {
                    const currentElement = prevState.present.svgElements.find(el => el.id === selectedId);
                    const newElement = { ...currentElement, ...updates };
                    
                    if (JSON.stringify(currentElement) === JSON.stringify(newElement)) {
                        return prevState;
                    }

                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.id === selectedId) {
                            return newElement;
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedId]);
            
            const handleSelectedWallsUpdate = useCallback((key, value) => {
                const groupId = selectedElement?.id;
                if (!groupId || selectedElement?.type !== 'space') return;

                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.groupId === groupId && el.type === 'wall') {
                            return { ...el, [key]: value };
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedElement]);


            const handleSelectedGroupUpdate = useCallback((updates) => {
                const activeGroupId = selectedElement?.groupId || (selectedElement?.type === 'space' ? selectedElement.id : null);
                if (!activeGroupId) return;

                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.groupId === activeGroupId) {
                            let newEl = { ...el, ...updates };
                            if (updates.spaceType) {
                                if (el.type === 'space') {
                                    newEl.fill = DEFAULT_FILL_COLORS[updates.spaceType] || '#ffffff';
                                }
                                if (el.type === 'text') {
                                    newEl.text = ["LDK", "DK", "K", "居室", "和室"].includes(updates.spaceType)
                                        ? `${updates.spaceType}\n◯.◯帖`
                                        : updates.spaceType;
                                }
                            }
                            return newEl;
                        }
                        return el;
                    });
                     return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedElement]);

            const analyzeImageWithAI = async (imageDataUrl) => {
                const base64ImageData = imageDataUrl.split(',')[1];
                const prompt = `あなたは、画像化された間取り図を解析し、CADデータのような正確なベクトル情報に変換する、高度なAIアシスタントです。以下の多段階の指示に厳密に従って、JSONを出力してください。`
            
                const payload = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inlineData: { mimeType: "image/png", data: base64ImageData } }
                        ]
                    }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        // ★エラーの原因箇所を修正した完全なスキーマ
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "scaleAnalysis": {
                                    type: "OBJECT",
                                    properties: {
                                        "referenceText": { "type": "STRING" }, // 例: "4,550mm"
                                        "pixelLength": { "type": "NUMBER" },   // 例: 520.5
                                        "pixelsPerMillimeter": { "type": "NUMBER" } // 例: 0.114
                                    }
                                },
                                "Blocks": {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            "type": { "type": "STRING" },
                                            "Text": { "type": "STRING" },
                                            "Geometry": {
                                                type: "OBJECT",
                                                properties: {
                                                    "Polygon": {
                                                        type: "ARRAY",
                                                        items: {
                                                            type: "OBJECT",
                                                            properties: {
                                                                "x": { "type": "NUMBER" },
                                                                "y": { "type": "NUMBER" }
                                                            },
                                                            required: ["x", "y"]
                                                        }
                                                    }
                                                },
                                                required: ["Polygon"]
                                            }
                                        },
                                        required: ["type", "Text", "Geometry"]
                                    }
                                }
                            },
                            required: ["Blocks"]
                        }
                    }
                };
            
                try {
                    const apiKey = "AIzaSyDtgMoGwCRePrz7kHss6iAa9Q_Pj2QeaaU";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
            
                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API Error: ${response.status} ${errorBody}`);
                    }
            
                    const result = await response.json();
            
                    if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        console.log("AIからのレスポンス(生テキスト):", jsonText); 
                        try {
                            const parsedJson = JSON.parse(jsonText);
                            console.log("AIからのレスポンス(パース後):", parsedJson); // パース後のオブジェクトも確認
                            return parsedJson;
                        } catch (e) {
                            console.error("JSONのパースに失敗しました:", e);
                            console.error("パースしようとしたテキスト:", jsonText);
                            return null; // パース失敗時はnullを返す
                        }
                        //return JSON.parse(jsonText);
                    } else {
                        console.error("AIからの応答が予期した形式ではありません。レスポンス全体:", result);
                        throw new Error("AIからの応答が予期した形式ではありません。");
                    }
                } catch (error) {
                    console.error("AIの解析中にエラーが発生しました:", error);
                    alert("AIの解析に失敗しました。時間をおいて再度お試しください。");
                    return null;
                }
            };
            
            const generateDrawingFromAi = useCallback((aiData, dimensions, originalImageDimensions) => {
                if (!originalImageDimensions) return []; 
            
                // 元画像のサイズと、キャンバス上に表示される画像のサイズ・位置を計算
                const canvasWidth = dimensions.width;
                const canvasHeight = dimensions.height;
                const originalWidth = originalImageDimensions.width;
                const originalHeight = originalImageDimensions.height;
            
                const scaleX = canvasWidth / originalWidth;
                const scaleY = canvasHeight / originalHeight;
                const fitScale = Math.min(scaleX, scaleY);
            
                const displayedWidth = originalWidth * fitScale;
                const displayedHeight = originalHeight * fitScale;
            
                const offsetX = (canvasWidth - displayedWidth) / 2;
                const offsetY = (canvasHeight - displayedHeight) / 2;
            
                const newElements = [];
                aiData.Blocks.forEach((block, index) => {
                    if (!block.Geometry.Polygon || block.Geometry.Polygon.length < 3) return;
            
                    // --- ▼▼▼ ここを修正します ▼▼▼ ---
                    // AIからのピクセル座標を、キャンバス上の表示に合わせてスケーリングとオフセット調整
                    const points = block.Geometry.Polygon.map(p => ({
                        x: (p.x * fitScale) + offsetX, 
                        y: (p.y * fitScale) + offsetY
                    }));
                    // --- ▲▲▲ ここまで修正 ▲▲▲ ---
            
                    const subGroupId = `space-group-ai-${Date.now()}-${index}`;
            
                    // 部屋のタイプ名を変換（"Room" -> "居室"など）
                    let spaceType = block.type;
                    const text = block.Text || "";
                    if (spaceType === "Room") {
                        if (text.includes("LDK")) spaceType = "LDK";
                        else if (text.includes("洋室")) spaceType = "居室";
                        else if (text.includes("和室")) spaceType = "和室";
                        else if (text.includes("洗面")) spaceType = "洗面所";
                        else if (text.includes("浴室")) spaceType = "浴室";
                        else if (text.includes("トイレ")) spaceType = "トイレ";
                        else if (text.includes("玄関")) spaceType = "玄関";
                        else spaceType = "居室"; // デフォルト
                    } else if (spaceType === "Storage" || spaceType === "Cabinet") {
                        spaceType = "収納";
                    } else if (spaceType === "Balcony") {
                        spaceType = "バルコニー";
                    }
            
                    // 部屋の塗りつぶし要素を作成
                    const spaceElement = {
                        id: subGroupId,
                        type: 'space',
                        shape: 'polygon',
                        spaceType: spaceType, // 変換後のタイプ名を使用
                        groupId: subGroupId,
                        points: points.map(p => `${p.x},${p.y}`).join(' '),
                        fill: DEFAULT_FILL_COLORS[spaceType] || '#ffffff',
                        backgroundPattern: 'none'
                    };
                    newElements.push(spaceElement);
            
                    // 頂点データから壁要素を作成
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        newElements.push({
                            id: `wall-ai-${Date.now()}-${index}-${i}`,
                            type: 'wall',
                            groupId: subGroupId,
                            edgeIndex: i,
                            x1: p1.x, y1: p1.y,
                            x2: p2.x, y2: p2.y,
                            color: DEFAULT_STROKE_COLOR,
                            strokeWidth: DEFAULT_STROKE_WIDTH,
                            lineStyle: 'solid'
                        });
                    }
            
                    // 部屋のラベル要素を作成
                    const centroid = getPolygonCentroid(points);
                    const labelElement = {
                        id: `text-ai-${Date.now()}-${index}`,
                        type: 'text',
                        groupId: subGroupId,
                        x: (centroid.x / dimensions.width) * 100,
                        y: (centroid.y / dimensions.height) * 100,
                        text: block.Text,
                        color: '#000000',
                        backgroundColor: 'none',
                        fontSize: 16,
                        fontFamily: 'sans-serif',
                        textAlign: 'center',
                    };
                    newElements.push(labelElement);
                });
            
                return newElements;
            }, [dimensions]);

            const handleModalSubmit = useCallback(async (imageDataUrl, useAi) => {
                const img = new Image();
                img.onload = async () => {
                    const imageWidth = img.naturalWidth;
                    const imageHeight = img.naturalHeight;
            
                    setOriginalImageDimensions({ width: imageWidth, height: imageHeight });
            
                    const canvasWidth = dimensions.width;
                    const canvasHeight = dimensions.height;
                    const scaleX = canvasWidth / imageWidth;
                    const scaleY = canvasHeight / imageHeight;
                    const fitScale = Math.min(scaleX, scaleY);
            
                    setImageUrl(imageDataUrl);
                    setImageScale(fitScale);
                    setImagePosition({ x: 0, y: 0 });
            
                    if (useAi) {
                        setIsLoading(true);
                        setLoadingMessage('AIで間取り図を解析中...');
            
                        try {
                            // 実際のAI呼び出し
                            const aiResult = await analyzeImageWithAI(imageDataUrl);
            
                            if (aiResult && aiResult.Blocks) {
                                const newElements = generateDrawingFromAi(aiResult, dimensions, { width: imageWidth, height: imageHeight });
            
                                setHistoryState(prev => ({
                                    past: [...prev.past, prev.present],
                                    present: { 
                                        ...prev.present, 
                                        svgElements: [...prev.present.svgElements, ...newElements], 
                                        ocrData: aiResult 
                                    },
                                    future: []
                                }));
                            } else {
                                console.error("AIからの応答がnullまたは不正な形式です。");
                                alert("AIによる解析に失敗しました。画像の形式を変えるか、時間をおいて再度お試しください。");
                            }
                        } catch (err) {
                            console.error("AI処理エラー:", err);
                            alert(`エラーが発生しました: ${err.message}`);
                        } finally {
                            setIsLoading(false);
                            setUploadModalOpen(false);
                        }
                    } else {
                        setUploadModalOpen(false);
                    }
                };
                img.src = imageDataUrl;
            
            }, [dimensions, analyzeImageWithAI, generateDrawingFromAi]);

            const getCanvasCoords = useCallback((event) => {
                const svg = svgRef.current;
                if (!svg) return { x: 0, y: 0 };
                const svgRect = svg.getBoundingClientRect();
                const x = (event.clientX - svgRect.left) / zoom;
                const y = (event.clientY - svgRect.top) / zoom;
                return { x, y };
            }, [zoom]);

            const getGridSnappedPoint = useCallback((point) => {
                return {
                    x: Math.round(point.x / gridSize) * gridSize,
                    y: Math.round(point.y / gridSize) * gridSize
                };
            }, [gridSize]);

            const finishDrawing = useCallback(() => {
                if (drawingMode === 'space' && spaceShape === 'line' && linePoints.length > 1) {
                    createPolygonSpace(linePoints);
                } else if (drawingMode === 'stairs' && linePoints.length > 1) {
                    createStairs(linePoints);
                }
                setLinePoints([]);
            }, [linePoints, drawingMode, spaceShape, createPolygonSpace, createStairs]);

            const handleCanvasClick = useCallback((e) => {                
                const clickPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');

                if (editorMode === 'edit') {
                    setSelectedId(targetId);
                    return;
                }

                if (editorMode === 'create' || editorMode === 'continuous-create') {
                    // 2クリック目：設備の描画を確定する
                    if (pendingFixture) {
                        const startPoint = pendingFixture;
                        const currentPos = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                        const dx = currentPos.x - startPoint.x;
                        const dy = currentPos.y - startPoint.y;

                        const finalRotation = fixtureRotation + ((dx < 0) ? 180 : 0);
                        const isFlipped = (dy > 0);

                        createItem(startPoint, null, { rotation: finalRotation, isFlipped: isFlipped });

                        setPendingFixture(null);
                        if (editorMode === 'create') {
                            setEditorMode('edit');
                        }
                        return;
                    }

                    // ドア・窓の描画
                    if (drawingMode === 'window' || drawingMode === 'door') {
                        // 3回目のクリック
                        if (pendingWindow) {
                            const center = { x: (pendingWindow.start.x + pendingWindow.end.x) / 2, y: (pendingWindow.start.y + pendingWindow.end.y) / 2 };
                            const dx = clickPos.x - center.x;
                            const dy = clickPos.y - center.y;

                            let rotation = 0;
                            let isInner = false;
                            if (dx < 0 && dy < 0) { rotation = 180; isInner = true; }
                            else if (dx > 0 && dy < 0) { rotation = 0; isInner = false; }
                            else if (dx > 0 && dy > 0) { rotation = 0; isInner = true; }
                            else { rotation = 180; isInner = false; }

                            createItem(pendingWindow.start, pendingWindow.end, { rotation, isInner });

                            setPendingWindow(null);
                            setSnappedInfo(null);
                            activeSnapWallRef.current = null;
                            if (editorMode === 'create') {
                                setEditorMode('edit');
                            }
                            return;
                        }
                        // 2回目のクリック
                        else if (drawingStartPoint) {
                            let clickedEndPoint;
                            const walls = svgElements.filter(el => el.type === 'wall');

                            if (isSnapToWall && !isModifierKeyDown && walls.length > 0) {
                                if (snappedInfo?.wall) {
                                    clickedEndPoint = snappedInfo.point;
                                } else {
                                    clickedEndPoint = getClosestPointOnWalls(clickPos, walls);
                                }
                            } else {
                                clickedEndPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                            }

                            setPendingWindow({ start: drawingStartPoint, end: clickedEndPoint });
                            setDrawingStartPoint(null);
                            setSnappedInfo(null);
                            return;
                        }
                        // 1回目のクリック
                        else {
                            if (isSnapToWall && !isModifierKeyDown && !snappedInfo?.wall) {
                                return;
                            }
                            const startPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(clickPos) : clickPos);
                            setDrawingStartPoint(startPoint);

                            if (isSnapToWall && snappedInfo?.wall) {
                                activeSnapWallRef.current = snappedInfo.wall;
                            }
                            setSnappedInfo(null);
                            return;
                        }
                    }

                    // 多角形（空間・階段）の描画処理
                    if ((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs') {
                        const clickedPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(clickPos) : clickPos);

                        if (linePoints.length > 0) {
                            if (drawingMode === 'stairs') {
                                const lastPoint = linePoints[linePoints.length - 1];
                                const distToLast = Math.sqrt(Math.pow(clickedPoint.x - lastPoint.x, 2) + Math.pow(clickedPoint.y - lastPoint.y, 2));
                                if (distToLast < SNAP_THRESHOLD / zoom) {
                                    createStairs(linePoints);
                                    finishDrawing();
                                    setSnappedInfo(null);
                                    return;
                                }
                            }

                            if (drawingMode === 'space' && spaceShape === 'line' && linePoints.length >= 2) {
                                const firstPoint = linePoints[0];
                                const distToStart = Math.sqrt(Math.pow(clickedPoint.x - firstPoint.x, 2) + Math.pow(clickedPoint.y - firstPoint.y, 2));
                                if (distToStart < SNAP_THRESHOLD / zoom) {
                                    createPolygonSpace([...linePoints, firstPoint]);
                                    finishDrawing();
                                    setSnappedInfo(null);
                                    return;
                                }
                            }
                        }

                        setLinePoints(prev => [...prev, clickedPoint]);
                        setSnappedInfo(null);
                        return;
                    }

                    // 2点クリックで完了する描画処理
                    if (drawingStartPoint) {
                        let finalEndPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(clickPos) : clickPos);
                        if (drawingMode === 'space' && spaceShape === 'rect') {
                            const x1 = Math.min(drawingStartPoint.x, finalEndPoint.x);
                            const y1 = Math.min(drawingStartPoint.y, finalEndPoint.y);
                            const x2 = Math.max(drawingStartPoint.x, finalEndPoint.x);
                            const y2 = Math.max(drawingStartPoint.y, finalEndPoint.y);
                            const rectPoints = [{x: x1, y: y1}, {x: x2, y: y1}, {x: x2, y: y2}, {x: x1, y: y2}];
                            createPolygonSpace(rectPoints);
                        } else {
                            createItem(drawingStartPoint, finalEndPoint);
                        }
                        setDrawingStartPoint(null);
                        setSnappedInfo(null);
                        return;
                    }

                    // 1点クリック or 始点を決める処理
                    if (drawingMode === 'text' || drawingMode === 'compass' || drawingMode === 'fixture' || drawingMode === 'wall' || (drawingMode === 'space' && spaceShape === 'rect')) {
                        const startPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(clickPos) : clickPos);

                        // ▼▼▼ FIX PART 2: MODIFY FIXTURE 1ST CLICK LOGIC ▼▼▼
                        if (drawingMode === 'fixture') {
                            setPendingFixture(startPoint);
                        } else if ((drawingMode === 'space' && spaceShape === 'rect') || drawingMode === 'wall' || drawingMode === 'compass') {
                            setDrawingStartPoint(startPoint);
                        } else { // text の場合
                            createItem(startPoint);
                        }
                        // ▲▲▲ FIX PART 2 ▲▲▲
                        setSnappedInfo(null);
                    }
                }
            }, [
                // ▼▼▼ 依存配列もこちらに置き換えてください ▼▼▼
                svgElements, editorMode, drawingMode, spaceShape, drawingStartPoint, linePoints, pendingWindow, pendingFixture,
                isGridVisible, getCanvasCoords, getGridSnappedPoint, dimensions, strokeColor,
                fontSize, fontFamily, textAlign, fixtureTemplateId, fixtureCategory, spaceType,
                fillColor, lineStyle, compassTemplateId, doorTemplateId, windowTemplateId, zoom,
                backgroundPattern, createPolygonSpace, createItem, createStairs,
                isSnapToWall, snappedInfo, fixtureRotation, fixtureFlip, isModifierKeyDown
            ]);

            const createPolygonSpace = useCallback((points) => {
                const groupId = `space-group-${Date.now()}`;
                const newElements = [];

                const specialProps = SUB_TYPE_PROPERTIES[spaceType];
                const finalLineStyle = specialProps?.lineStyle !== undefined ? specialProps.lineStyle : lineStyle;
                const finalStrokeWidth = specialProps?.strokeWidth !== undefined ? specialProps.strokeWidth : strokeWidth;

                for (let i = 0; i < points.length; i++) {
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];
                    const wallElement = {
                        id: `wall-${Date.now()}-${i}`, type: 'wall', groupId, edgeIndex: i,
                        x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
                        color: strokeColor, strokeWidth: finalStrokeWidth, lineStyle: finalLineStyle
                    };
                    newElements.push(wallElement);
                }

                let finalBackgroundPattern = backgroundPattern;
                if (spaceType === '玄関') finalBackgroundPattern = 'grid-small';
                if (spaceType === '和室') finalBackgroundPattern = 'grid-large';
                if (['吹抜', 'グルニエ', '折上天井', '床下収納', '冷蔵庫', '洗濯機'].includes(spaceType)) {
                    finalBackgroundPattern = 'dotted-x';
                }

                const spaceElement = {
                    id: groupId, type: 'space', shape: 'polygon', spaceType: spaceType, groupId,
                    points: points.map(p => `${p.x},${p.y}`).join(' '),
                    fill: specialProps?.fill !== undefined ? specialProps.fill : fillColor,
                    backgroundPattern: finalBackgroundPattern,
                };
                newElements.push(spaceElement);

                const centroid = getPolygonCentroid([...points]);
                const labelElement = createSpaceLabel(spaceType, centroid, dimensions);
                if (labelElement) {
                    newElements.push(labelElement);
                }
                
                setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                if (editorMode === 'create') {
                    setEditorMode('edit');
                }
                if (editorMode !== 'continuous-create') {
                    setSelectedId(groupId);
                }
            }, [spaceType, backgroundPattern, fillColor, strokeColor, lineStyle, dimensions, editorMode, strokeWidth]);

            const createStairs = useCallback((points) => {
                const stairId = `stairs-${Date.now()}`; // 階段とテキストの共通ID

                // 1. 階段要素を作成
                const newStairElement = {
                    id: stairId,
                    type: 'stairs',
                    groupId: stairId, // グループIDを追加
                    points: points.map(p => `${p.x},${p.y}`).join(' '),
                    width: stairWidth,
                    color: strokeColor,
                    strokeWidth: DEFAULT_STROKE_WIDTH,
                };

                // 2. 階段に付随するテキスト要素を別途作成
                let newTextElement = null;
                if (points.length >= 2) {
                    const startPoint = points[0];
                    const nextPoint = points[1];

                    const arrowVec = { x: nextPoint.x - startPoint.x, y: nextPoint.y - startPoint.y };
                    const arrowLen = Math.sqrt(arrowVec.x**2 + arrowVec.y**2);
                    const arrowDir = arrowLen > 0 ? { x: arrowVec.x / arrowLen, y: arrowVec.y / arrowLen } : { x: 0, y: 0 };
                    const arrowAngle = Math.atan2(arrowDir.y, arrowDir.x) * 180 / Math.PI;

                    const textOffsetX = -arrowDir.x * 20;
                    const textOffsetY = -arrowDir.y * 20;

                    const textContent = stairDirection === 'up' ? 'UP' : stairDirection === 'down' ? 'DN' : '';

                    // テキストが非表示でない場合のみ要素を作成
                    if (stairDirection !== 'none') {
                        newTextElement = {
                            id: `text-${Date.now()}`,
                            type: 'text',
                            groupId: stairId,
                            x: ((startPoint.x + textOffsetX) / dimensions.width) * 100,
                            y: ((startPoint.y + textOffsetY) / dimensions.height) * 100,
                            text: textContent,
                            color: strokeColor,
                            fontSize: 12,
                            fontFamily: 'sans-serif',
                            textAlign: 'center',
                            rotation: arrowAngle + 90
                        };
                    }
                }

                const elementsToAdd = [newStairElement];
                if (newTextElement) {
                    elementsToAdd.push(newTextElement);
                }

                setHistoryState(prev => ({ 
                    past: [...prev.past, prev.present], 
                    present: { ...prev.present, svgElements: [...prev.present.svgElements, ...elementsToAdd] }, 
                    future: [] 
                }));

                if (editorMode === 'create') {
                    setEditorMode('edit');
                }
                if (editorMode !== 'continuous-create') {
                    setSelectedId(newStairElement.id);
                }
            }, [stairWidth, stairDirection, strokeColor, editorMode, dimensions]);

            const createItem = (start, end, options = {}) => {
                const newElements = [];
                let newElementId = null;

                if (drawingMode === 'wall') {
                    const newElement = { id: `wall-${Date.now()}`, type: 'wall', x1: start.x, y1: start.y, x2: end.x, y2: end.y, color: strokeColor, strokeWidth: strokeWidth, lineStyle: lineStyle };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'compass') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const size = Math.min(300, Math.max(20, distance));
                    const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                    const newElement = { id: `compass-${Date.now()}`, type: 'compass', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100, size: size, rotation: rotation, templateId: compassTemplateId };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'door' || drawingMode === 'window') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const baseAngle = Math.atan2(dy, dx) * 180 / Math.PI;

                    const finalWallThickness = (isSnapToWall && activeSnapWallRef.current)
                    ? activeSnapWallRef.current.strokeWidth
                    : wallObjectThickness;

                    const newElement = {
                        id: `${drawingMode}-${Date.now()}`,
                        type: drawingMode,
                        templateId: drawingMode === 'door' ? doorTemplateId : windowTemplateId,
                        x1: start.x,
                        y1: start.y,
                        x2: end.x,
                        y2: end.y,
                        length: length,
                        baseAngle: baseAngle,
                        // ▼▼▼ options から回転と反転フラグを受け取るように修正 ▼▼▼
                        rotation: options.rotation || 0,
                        isInner: options.isInner !== undefined ? options.isInner : true,
                        // ▲▲▲ ここまで ▲▲▲
                        swingDirection: 'clockwise',
                        wallThickness: finalWallThickness,
                        color: DEFAULT_STROKE_COLOR,
                        strokeWidth: DEFAULT_STROKE_WIDTH
                    };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'text') {
                    const newElement = { id: `text-${Date.now()}`, type: 'text', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100, text: "テキスト", color: strokeColor, fontSize: fontSize, fontFamily: fontFamily, textAlign: textAlign, backgroundColor: 'none' };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'fixture') {
                    const template = FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {};
                    const baseSize = BASE_FIXTURE_DEFAULT_SIZE;
                    const templateDefaultSize = template.defaultSize || baseSize; // defaultSizeが未定義なら基準サイズを使う
                    // UIスライダーの値とdefaultSizeから、実際の描画サイズを計算
                    const actualWidth = fixtureSize * (baseSize / templateDefaultSize);
                    const aspectRatio = template.aspectRatio || 1;
                    const actualHeight = actualWidth / aspectRatio;
                    const newElement = {
                        id: `fixture-${Date.now()}`,
                        type: 'fixture',
                        x: (start.x / dimensions.width) * 100,
                        y: (start.y / dimensions.height) * 100,
                        templateId: fixtureTemplateId,
                        width: actualWidth,
                        height: actualHeight,
                        rotation: options.rotation !== undefined ? options.rotation : fixtureRotation,
                        isFlipped: options.isFlipped !== undefined ? options.isFlipped : fixtureFlip,
                        fill: template.defaultFill,
                        stroke: template.defaultStroke,
                        strokeWidth: template.defaultStrokeWidth
                    };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                }

                if (newElements.length > 0) {
                    setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                     if (editorMode === 'create') {
                        setEditorMode('edit');
                    }
                    if (editorMode !== 'continuous-create') {
                        setSelectedId(newElementId);
                    }
                }
            };

            const handleMouseDown = useCallback((e) => {
                e.stopPropagation();

                if (!drawingMode && !imageUrl && editorMode !== 'edit') {
                    const clickPos = getCanvasCoords(e);

                    // 既存のタイマーをクリア
                    tooltipTimers.current.forEach(clearTimeout);

                    setTooltip({
                        visible: true,
                        fading: false,
                        x: clickPos.x,
                        y: clickPos.y,
                        message: "下絵を選択、もしくは描画したい項目を選択してください。"
                    });

                    // 3秒後にフェードアウトを開始するタイマー
                    const fadeTimer = setTimeout(() => {
                        setTooltip(prev => ({ ...prev, fading: true }));
                    }, 3000);

                    // 5秒後 (3秒表示 + 2秒フェード) に完全に非表示にするタイマー
                    const hideTimer = setTimeout(() => {
                        setTooltip(prev => ({ ...prev, visible: false, fading: false }));
                    }, 5000);

                    tooltipTimers.current = [fadeTimer, hideTimer];
                }

                if (isDisplaySettingsOpen) {
                    // 表示設定が開いている時は、下絵のドラッグ操作を開始する
                    imageDragInfo.current = {
                        startMouseX: e.clientX,
                        startMouseY: e.clientY,
                        initialImageX: imagePosition.x,
                        initialImageY: imagePosition.y
                    };
                    return; // 図形描画処理は行わずに終了
                }

                const startCanvasX = getCanvasCoords(e).x;
                const startCanvasY = getCanvasCoords(e).y;
                mouseDownInfo.current = { x: e.clientX, y: e.clientY };

                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);

                if (editorMode === 'edit') {
                    const handleIndex = e.target.dataset.handleIndex;
                    const handleType = e.target.dataset.handleType;
                    if (handleIndex !== undefined && selectedId) {
                        setResizingHandleInfo({ id: selectedId, handleIndex: parseInt(handleIndex, 10), type: handleType });
                        historyOnActionStart.current = historyState.present;
                        return;
                    }

                    dragTarget.current = targetElement;
                    if (targetElement) {
                        const initialElementCenter = getCenterPointForElement(targetElement, dimensions);
                        dragInfo.current = {
                            startMouseX: startCanvasX,
                            startMouseY: startCanvasY,
                            initialElementCenterX: initialElementCenter.x,
                            initialElementCenterY: initialElementCenter.y,
                        };
                        historyOnActionStart.current = historyState.present;
                    } else {
                        setSelectedId(null);
                    }
                } else { // create mode
                    if (!((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs')) {
                        setLinePoints([]);
                    }
                }
            }, [
                isDisplaySettingsOpen, imagePosition, getCanvasCoords, svgElements, editorMode, 
                selectedId, historyState.present, drawingMode, spaceShape, dimensions,
                isDisplaySettingsOpen, imagePosition, getCanvasCoords, svgElements, editorMode, 
                selectedId, historyState.present, drawingMode, spaceShape, dimensions, imageUrl, setTooltip
            ]);

            const handleMouseMove = useCallback((e) => {
                const currentMousePos = getCanvasCoords(e);
                setMousePos(currentMousePos);

                if (imageDragInfo.current) {
                    const dx = e.clientX - imageDragInfo.current.startMouseX;
                    const dy = e.clientY - imageDragInfo.current.startMouseY;
                    setImagePosition({
                        x: imageDragInfo.current.initialImageX + (dx / zoom),
                        y: imageDragInfo.current.initialImageY + (dy / zoom)
                    });
                    return;
                }

                // ▼▼▼【修正点】ここからスナップ処理全体を修正 ▼▼▼
                const isSnappingEnabled = (drawingMode === 'window' || drawingMode === 'door' || drawingMode === 'space') && isSnapToWall && !isModifierKeyDown;

                // 毎回のマウス移動でガイドラインを初期化
                let newGuideLines = [];
                let snappedPos = isGridVisible ? getGridSnappedPoint(currentMousePos) : { ...currentMousePos };

                if (isSnappingEnabled) {
                    let closestSnap = null;
                    let minDistance = SNAP_THRESHOLD / zoom;

                    // 1. 軸スナップの計算とガイドラインの生成
                    let closestXSnap = { dist: minDistance, point: null };
                    let closestYSnap = { dist: minDistance, point: null };
                    for (const wall of svgElements.filter(el => el.type === 'wall')) {
                        const vertices = [{x: wall.x1, y: wall.y1}, {x: wall.x2, y: wall.y2}];
                        vertices.forEach(vertex => {
                            const distX = Math.abs(currentMousePos.x - vertex.x);
                            const distY = Math.abs(currentMousePos.y - vertex.y);
                            if (distX < closestXSnap.dist) { closestXSnap = { dist: distX, point: vertex }; }
                            if (distY < closestYSnap.dist) { closestYSnap = { dist: distY, point: vertex }; }
                        });
                    }
                    if (closestXSnap.point) {
                        snappedPos.x = closestXSnap.point.x;
                        newGuideLines.push({ x1: closestXSnap.point.x, y1: closestXSnap.point.y, x2: snappedPos.x, y2: snappedPos.y });
                    }
                    if (closestYSnap.point) {
                        snappedPos.y = closestYSnap.point.y;
                        newGuideLines.push({ x1: closestYSnap.point.x, y1: closestYSnap.point.y, x2: snappedPos.x, y2: snappedPos.y });
                    }

                    // 2. 近接スナップの計算 (頂点を優先)
                    for (const wall of svgElements.filter(el => el.type === 'wall')) {
                        const vertices = [{x: wall.x1, y: wall.y1}, {x: wall.x2, y: wall.y2}];
                        for (const vertex of vertices) {
                            const distance = Math.sqrt(Math.pow(snappedPos.x - vertex.x, 2) + Math.pow(snappedPos.y - vertex.y, 2));
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestSnap = { point: vertex, type: 'vertex' };
                            }
                        }
                    }
                    if (!closestSnap) { // 頂点にスナップしなかった場合のみ、壁の線上を探す
                        for (const wall of svgElements.filter(el => el.type === 'wall')) {
                            const p1 = { x: wall.x1, y: wall.y1 }, p2 = { x: wall.x2, y: wall.y2 };
                            const dx = p2.x - p1.x, dy = p2.y - p1.y;
                            if (dx === 0 && dy === 0) continue;
                            const t = ((snappedPos.x - p1.x) * dx + (snappedPos.y - p1.y) * dy) / (dx * dx + dy * dy);
                            const clampedT = Math.max(0, Math.min(1, t));
                            const pointOnLine = { x: p1.x + clampedT * dx, y: p1.y + clampedT * dy };
                            const distance = Math.sqrt(Math.pow(snappedPos.x - pointOnLine.x, 2) + Math.pow(snappedPos.y - pointOnLine.y, 2));
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestSnap = { point: pointOnLine, type: 'wall', wall: wall }; // ✅ wallオブジェクトを追加
                            }
                        }
                    }

                    // 3. 最終的なスナップ情報をセット
                    if (closestSnap) {
                        setSnappedInfo(closestSnap);
                    } else if (newGuideLines.length > 0) {
                        setSnappedInfo({ point: snappedPos, type: 'extension' });
                    } else {
                         setSnappedInfo(null);
                    }
                } else {
                    setSnappedInfo(null);
                }
                setGuideLines(newGuideLines);

                // 始点へのスナップ処理
                const isDrawingPolygon = (drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs';
                if (isDrawingPolygon && linePoints.length >= 2) {
                    const firstPoint = linePoints[0];
                    const distToStart = Math.sqrt(Math.pow(currentMousePos.x - firstPoint.x, 2) + Math.pow(currentMousePos.y - firstPoint.y, 2));
                    setIsSnappingToStart(distToStart < SNAP_THRESHOLD / zoom);
                } else if (isSnappingToStart) {
                    setIsSnappingToStart(false);
                }

                // ドラッグ開始の判定は編集モードの時だけ行う
                if (editorMode === 'edit' && dragTarget.current && dragInfo.current && mouseDownInfo.current) {
                    const dist = Math.sqrt(Math.pow(e.clientX - mouseDownInfo.current.x, 2) + Math.pow(e.clientY - mouseDownInfo.current.y, 2));
                    if (!isDragging && dist > 5) {
                        setIsDragging(true);
                        setSelectedId(dragTarget.current.id);
                    }
                }

                // リサイズ処理
                if (resizingHandleInfo) {
                    const { id, handleIndex, type } = resizingHandleInfo;
                    const snappedPos = isGridVisible ? getGridSnappedPoint(currentMousePos) : currentMousePos;
                    let newElements = [...historyOnActionStart.current.svgElements];
                    const elementIndex = newElements.findIndex(el => el.id === id);
                    if (elementIndex === -1) return;

                    if (type === 'fixtureCorner' || type === 'fixtureEdge') {
                        const originalElement = { ...newElements[elementIndex] };
                        const cx = originalElement.x / 100 * dimensions.width;
                        const cy = originalElement.y / 100 * dimensions.height;
                        const rad = (originalElement.rotation || 0) * Math.PI / 180;
                        
                        const mouseDx = snappedPos.x - cx;
                        const mouseDy = snappedPos.y - cy;
                        
                        const unrotatedMouseX = mouseDx * Math.cos(-rad) - mouseDy * Math.sin(-rad);
                        const unrotatedMouseY = mouseDx * Math.sin(-rad) + mouseDy * Math.cos(-rad);

                        let newWidth = originalElement.width;
                        let newHeight = originalElement.height;

                        if (type === 'fixtureCorner') { // 四隅のポッチ（アスペクト比を維持してリサイズ）
                            const originalAspectRatio = originalElement.width / originalElement.height;
                            const newHalfWidth = Math.abs(unrotatedMouseX);
                            const newHalfHeight = Math.abs(unrotatedMouseY);

                            if (newHalfWidth / originalAspectRatio > newHalfHeight) {
                                newWidth = newHalfWidth * 2;
                                newHeight = newWidth / originalAspectRatio;
                            } else {
                                newHeight = newHalfHeight * 2;
                                newWidth = newHeight * originalAspectRatio;
                            }
                        } else if (type === 'fixtureEdge') { // 各辺のひし形（幅・高さのみリサイズ）
                            switch (handleIndex) {
                                case 0: // 上
                                case 2: // 下
                                    newHeight = Math.abs(unrotatedMouseY) * 2;
                                    break;
                                case 1: // 右
                                case 3: // 左
                                    newWidth = Math.abs(unrotatedMouseX) * 2;
                                    break;
                            }
                        }
                        
                        newElements[elementIndex] = { ...originalElement, width: Math.max(10, newWidth), height: Math.max(10, newHeight) };

                    } else if (type === 'wall' || type === 'door' || type === 'window') { // ▼▼▼【修正】条件を統合 ▼▼▼
                        const newElement = { ...newElements[elementIndex] };

                        if (handleIndex === 0) { // 始点を更新
                            newElement.x1 = snappedPos.x;
                            newElement.y1 = snappedPos.y;
                        } else { // 終点を更新
                            newElement.x2 = snappedPos.x;
                            newElement.y2 = snappedPos.y;
                        }

                        // ▼▼▼【追加】ドアと窓のために長さと角度を再計算 ▼▼▼
                        if (type === 'door' || type === 'window') {
                            const dx = newElement.x2 - newElement.x1;
                            const dy = newElement.y2 - newElement.y1;
                            newElement.length = Math.sqrt(dx * dx + dy * dy);
                            newElement.baseAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        }
                        
                        newElements[elementIndex] = newElement;

                        // ▼▼▼【修正】壁グループの更新ロジックを壁線の場合のみに限定 ▼▼▼
                        if (type === 'wall' && newElement.groupId) {
                            const spaceIndex = newElements.findIndex(el => el.id === newElement.groupId);
                            if (spaceIndex > -1) {
                                const newSpace = { ...newElements[spaceIndex] };
                                let points = newSpace.points.split(' ').map(p => ({x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1])}));
                                const pointIndexToUpdate = (handleIndex === 0) ? newElement.edgeIndex : (newElement.edgeIndex + 1) % points.length;
                                points[pointIndexToUpdate] = { x: snappedPos.x, y: snappedPos.y };
                                const adjacentWallIndex = (handleIndex === 0) ? (newElement.edgeIndex - 1 + points.length) % points.length : (newElement.edgeIndex + 1) % points.length;
                                const adjacentWall = newElements.find(el => el.groupId === newElement.groupId && el.edgeIndex === adjacentWallIndex);
                                if(adjacentWall) {
                                    const adjWallIdxInArray = newElements.findIndex(el => el.id === adjacentWall.id);
                                    const newAdjWall = {...newElements[adjWallIdxInArray]};
                                    if(handleIndex === 0) { newAdjWall.x2 = snappedPos.x; newAdjWall.y2 = snappedPos.y; }
                                    else { newAdjWall.x1 = snappedPos.x; newAdjWall.y1 = snappedPos.y; }
                                    newElements[adjWallIdxInArray] = newAdjWall;
                                }
                                newSpace.points = points.map(p => `${p.x},${p.y}`).join(' ');
                                newElements[spaceIndex] = newSpace;
                                const labelIndex = newElements.findIndex(el => el.groupId === newElement.groupId && el.type === 'text');
                                if (labelIndex > -1) {
                                    const newLabel = {...newElements[labelIndex]};
                                    const newCentroid = getPolygonCentroid(points);
                                    newLabel.x = (newCentroid.x / dimensions.width) * 100;
                                    newLabel.y = (newCentroid.y / dimensions.height) * 100;
                                    newElements[labelIndex] = newLabel;
                                }
                            }
                        }
                    } else if (type === 'spaceCorner' || type === 'spaceEdge') {
                        const groupElements = newElements.filter(el => el.groupId === id);
                        const spaceEl = groupElements.find(el => el.type === 'space');
                        if (!spaceEl) return;
                        const originalPoints = spaceEl.points.split(' ').map(p => ({x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1])}));
                        const xs = originalPoints.map(p => p.x);
                        const ys = originalPoints.map(p => p.y);
                        const originalBbox = { minX: Math.min(...xs), minY: Math.min(...ys), maxX: Math.max(...xs), maxY: Math.max(...ys) };
                        let newPoints;
                        if (type === 'spaceCorner') {
                            const corners = [
                                {x: originalBbox.minX, y: originalBbox.minY}, {x: originalBbox.maxX, y: originalBbox.minY},
                                {x: originalBbox.maxX, y: originalBbox.maxY}, {x: originalBbox.minX, y: originalBbox.maxY}
                            ];
                            const anchor = corners[(handleIndex + 2) % 4];
                            const originalCorner = corners[handleIndex];
                            const scaleX = (originalCorner.x - anchor.x) === 0 ? 1 : (snappedPos.x - anchor.x) / (originalCorner.x - anchor.x);
                            const scaleY = (originalCorner.y - anchor.y) === 0 ? 1 : (snappedPos.y - anchor.y) / (originalCorner.y - anchor.y);
                            newPoints = originalPoints.map(p => ({
                                x: Math.round(anchor.x + (p.x - anchor.x) * scaleX),
                                y: Math.round(anchor.y + (p.y - anchor.y) * scaleY)
                            }));
                        } else { // spaceEdge
                            newPoints = originalPoints.map(p => {
                                let newP = {...p};
                                if (handleIndex === 0 && p.y === originalBbox.minY) newP.y = snappedPos.y;
                                if (handleIndex === 1 && p.x === originalBbox.maxX) newP.x = snappedPos.x;
                                if (handleIndex === 2 && p.y === originalBbox.maxY) newP.y = snappedPos.y;
                                if (handleIndex === 3 && p.x === originalBbox.minX) newP.x = snappedPos.x;
                                return newP;
                            });
                        }
                        const newPointsStr = newPoints.map(p => `${p.x},${p.y}`).join(' ');
                        const newCentroid = getPolygonCentroid([...newPoints]);
                        newElements = newElements.map(el => {
                            if (el.groupId !== id) return el;
                            if (el.type === 'space') return {...el, points: newPointsStr};
                            if (el.type === 'text') return {...el, x: (newCentroid.x / dimensions.width) * 100, y: (newCentroid.y / dimensions.height) * 100};
                            if (el.type === 'wall') {
                                const p1 = newPoints[el.edgeIndex];
                                const p2 = newPoints[(el.edgeIndex + 1) % newPoints.length];
                                return {...el, x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
                            }
                            return el;
                        });
                    }
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                    return;
                }

                // ドラッグ中の処理
                if (isDragging) {
                    const initialElementCenterX = dragInfo.current.initialElementCenterX;
                    const initialElementCenterY = dragInfo.current.initialElementCenterY;
                    const startMouseCanvasX = dragInfo.current.startMouseX;
                    const startMouseCanvasY = dragInfo.current.startMouseY;
                    const mouseMoveDx = currentCanvasX - startMouseCanvasX;
                    const mouseMoveDy = currentCanvasY - startMouseCanvasY;
                    let proposedFinalCenterX = initialElementCenterX + mouseMoveDx;
                    let proposedFinalCenterY = initialElementCenterY + mouseMoveDy;
                    if (isGridVisible) {
                        const snappedX = Math.round(proposedFinalCenterX / gridSize) * gridSize;
                        const snappedY = Math.round(proposedFinalCenterY / gridSize) * gridSize;
                        const distX = Math.abs(proposedFinalCenterX - snappedX);
                        const distY = Math.abs(proposedFinalCenterY - snappedY);
                        if (distX < SNAP_THRESHOLD && distY < SNAP_THRESHOLD) {
                            proposedFinalCenterX = snappedX;
                            proposedFinalCenterY = snappedY;
                        }
                    }
                    const finalDeltaX = proposedFinalCenterX - initialElementCenterX;
                    const finalDeltaY = proposedFinalCenterY - initialElementCenterY;
                    const elementToDragOriginal = historyOnActionStart.current.svgElements.find(el => el.id === selectedId);
                    if(!elementToDragOriginal) return;
                    const groupId = elementToDragOriginal.groupId || (elementToDragOriginal.type === 'space' ? elementToDragOriginal.id : null);
                    const isGroupDrag = !!groupId && elementToDragOriginal.type === 'space'; 
                    const elementsToUpdate = isGroupDrag
                        ? historyOnActionStart.current.svgElements.filter(el => el.groupId === groupId)
                        : [elementToDragOriginal];
                    const newElements = historyOnActionStart.current.svgElements.map(el => {
                        const originalEl = elementsToUpdate.find(u_el => u_el.id === el.id);
                        if (originalEl) {
                            const newEl = { ...el };
                            switch (originalEl.type) {
                                case 'text':
                                case 'fixture':
                                case 'compass':
                                    newEl.x = originalEl.x + (finalDeltaX / dimensions.width) * 100;
                                    newEl.y = originalEl.y + (finalDeltaY / dimensions.height) * 100;
                                    break;
                                case 'door':
                                case 'window':
                                case 'wall':
                                    newEl.x1 = originalEl.x1 + finalDeltaX;
                                    newEl.y1 = originalEl.y1 + finalDeltaY;
                                    newEl.x2 = originalEl.x2 + finalDeltaX;
                                    newEl.y2 = originalEl.y2 + finalDeltaY;
                                    break;
                                case 'space':
                                case 'stairs':
                                    const originalPoints = originalEl.points.split(' ').map(p_str => ({x: parseFloat(p_str.split(',')[0]), y: parseFloat(p_str.split(',')[1])}));
                                    const movedPoints = originalPoints.map(p => ({ x: p.x + finalDeltaX, y: p.y + finalDeltaY }));
                                    newEl.points = movedPoints.map(p => `${p.x},${p.y}`).join(' ');
                                    break;
                            }
                            return newEl;
                        }
                        return el;
                    });
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                }
            }, [
                getCanvasCoords, resizingHandleInfo, isDragging, isGridVisible, getGridSnappedPoint, dimensions, dragInfo, historyOnActionStart,
                drawingMode, spaceShape, linePoints, zoom, isSnappingToStart,
                isSnapToWall, svgElements, drawingStartPoint, activeSnapWallRef, mouseDownInfo, selectedId, editorMode, imagePosition, isModifierKeyDown
            ]);


            const handleMouseUp = (e) => {
                const wasDraggingImage = !!imageDragInfo.current;
                if (imageDragInfo.current) {
                    imageDragInfo.current = null;
                }
                if (!mouseDownInfo.current) {
                    return;
                }

                if (!isDragging && !resizingHandleInfo && !wasDraggingImage) { 
                    handleCanvasClick(e);
                } else {
                    const draggedElement = historyOnActionStart.current?.svgElements.find(el => el.id === selectedId);
                    if (draggedElement && draggedElement.type === 'wall' && draggedElement.groupId && isDragging) {
                        setHistoryState(prevState => {
                            const updatedElements = prevState.present.svgElements.map(el => {
                                if (el.id === selectedId) {
                                    const { groupId, edgeIndex, ...independentWall } = el;
                                    return independentWall;
                                }
                                return el;
                            });
                            return {
                                past: [...prevState.past, historyOnActionStart.current],
                                present: { ...prevState.present, svgElements: updatedElements },
                                future: []
                            };
                        });
                    } else if (historyOnActionStart.current && JSON.stringify(historyOnActionStart.current.svgElements) !== JSON.stringify(svgElements)) {
                        setHistoryState(prev => ({ ...prev, past: [...prev.past, historyOnActionStart.current], future: [] }));
                    }
                }
                
                setIsDragging(false);
                setResizingHandleInfo(null);
                dragTarget.current = null;
                dragInfo.current = null;
                historyOnActionStart.current = null;
                mouseDownInfo.current = null;
            };

            const StairsPreviewRenderer = ({ points, width, color }) => {
                if (points.length < 2) return null;

                // StairsRendererから、プレビューに必要な計算ロジックのみを抜粋
                const outlines = [[], []];
                for (let i = 0; i < points.length; i++) {
                    const p_curr = points[i];
                    const p_prev = i > 0 ? points[i - 1] : null;
                    const p_next = i < points.length - 1 ? points[i + 1] : null;
                    const getPerp = (p1, p2) => {
                        const vec = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const len = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                        return len > 0 ? { x: -vec.y / len, y: vec.x / len } : { x: 0, y: 0 };
                    };
                    if (!p_prev) {
                        const perp = getPerp(p_curr, p_next);
                        outlines[0].push({ x: p_curr.x + perp.x * width / 2, y: p_curr.y + perp.y * width / 2 });
                        outlines[1].push({ x: p_curr.x - perp.x * width / 2, y: p_curr.y - perp.y * width / 2 });
                    } else if (!p_next) {
                        const perp = getPerp(p_prev, p_curr);
                        outlines[0].push({ x: p_curr.x + perp.x * width / 2, y: p_curr.y + perp.y * width / 2 });
                        outlines[1].push({ x: p_curr.x - perp.x * width / 2, y: p_curr.y - perp.y * width / 2 });
                    } else {
                        const getLineIntersection = (p1, p2, p3, p4) => {
                            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                            if (Math.abs(d) < 1e-8) { return null; }
                            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
                            return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                        };
                        const perp_in = getPerp(p_prev, p_curr);
                        const perp_out = getPerp(p_curr, p_next);
                        [1, -1].forEach(side => {
                            const outline_index = side === 1 ? 0 : 1;
                            const p1 = { x: p_prev.x + side * perp_in.x * width / 2, y: p_prev.y + side * perp_in.y * width / 2 };
                            const p2 = { x: p_curr.x + side * perp_in.x * width / 2, y: p_curr.y + side * perp_in.y * width / 2 };
                            const p3 = { x: p_curr.x + side * perp_out.x * width / 2, y: p_curr.y + side * perp_out.y * width / 2 };
                            const p4 = { x: p_next.x + side * perp_out.x * width / 2, y: p_next.y + side * perp_out.y * width / 2 };
                            let cornerPoint = getLineIntersection(p1, p2, p3, p4);
                            if (!cornerPoint) { cornerPoint = p2; }
                            outlines[outline_index].push(cornerPoint);
                        });
                    }
                }

                return (
                    <g style={{pointerEvents: 'none', opacity: 0.7}}>
                        <path d={`M ${outlines[0].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5" />
                        <path d={`M ${outlines[1].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5" />
                        <path d={`M ${points.map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={1} strokeDasharray="5,5"/>
                    </g>
                );
            };

            const deleteSelectedElement = useCallback(() => {
                if (!selectedId) return;

                const elementToDelete = svgElements.find(el => el.id === selectedId);
                if (!elementToDelete) return;

                setHistoryState(prevState => {
                    const presentElements = prevState.present.svgElements;
                    let newSvgElements;

                    const groupId = elementToDelete.groupId || 
                          (elementToDelete.type === 'space' ? elementToDelete.id : null) ||
                          (elementToDelete.type === 'stairs' ? elementToDelete.id : null);
                          
                    if (elementToDelete.type === 'wall' && groupId) {
                        // 削除された壁線はグループから独立させる
                        newSvgElements = presentElements.filter(el => el.id !== selectedId);
                        // グループのスペースとテキストはそのまま残す
                    } else if (groupId) {
                        // 空間の塗りつぶし、ラベル、またはグループに属する他の要素が選択された場合は、グループ全体を削除する
                        newSvgElements = presentElements.filter(el => el.groupId !== groupId);
                    } else {
                        // 独立した要素が削除された場合
                        newSvgElements = presentElements.filter(el => el.id !== selectedId);
                    }

                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: newSvgElements },
                        future: []
                    };
                });

                setSelectedId(null);
            }, [selectedId, svgElements]);

            const handleStairDirectionChange = (newDirection) => {
                if (!selectedElement) return;
                const groupId = selectedElement.groupId || selectedElement.id;

                setHistoryState(prevState => {
                    const past = [...prevState.past, prevState.present];
                    let future = [];
                    let newElements = [...prevState.present.svgElements];
                    
                    const existingText = newElements.find(el => el.groupId === groupId && el.type === 'text');
                    const stair = newElements.find(el => el.id === groupId);

                    const textContent = newDirection === 'up' ? 'UP' : newDirection === 'down' ? 'DN' : '';

                    if (existingText) {
                        if (newDirection === 'none') {
                            // テキストを削除
                            newElements = newElements.filter(el => el.id !== existingText.id);
                        } else {
                            // テキストを更新
                            newElements = newElements.map(el => el.id === existingText.id ? { ...el, text: textContent } : el);
                        }
                    } else if (newDirection !== 'none' && stair) {
                        // テキストが存在せず、'none'以外が選択された場合は新規作成
                        const points = stair.points.split(' ').map(p => ({ x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1]) }));
                        const startPoint = points[0];
                        const nextPoint = points[1];
                        const arrowVec = { x: nextPoint.x - startPoint.x, y: nextPoint.y - startPoint.y };
                        const arrowLen = Math.sqrt(arrowVec.x**2 + arrowVec.y**2);
                        const arrowDir = arrowLen > 0 ? { x: arrowVec.x / arrowLen, y: arrowVec.y / arrowLen } : { x: 0, y: 0 };
                        const arrowAngle = Math.atan2(arrowDir.y, arrowDir.x) * 180 / Math.PI;
                        const textOffsetX = -arrowDir.x * 20;
                        const textOffsetY = -arrowDir.y * 20;

                        const newTextElement = {
                            id: `text-${Date.now()}`,
                            type: 'text',
                            groupId: groupId,
                            x: ((startPoint.x + textOffsetX) / dimensions.width) * 100,
                            y: ((startPoint.y + textOffsetY) / dimensions.height) * 100,
                            text: textContent,
                            color: stair.color,
                            fontSize: 12,
                            fontFamily: 'sans-serif',
                            textAlign: 'center',
                            rotation: arrowAngle + 90
                        };
                        newElements.push(newTextElement);
                    }

                    return { past, present: { ...prevState.present, svgElements: newElements }, future };
                });
            };


            const handleUndo = useCallback(() => {
                setHistoryState(prevState => {
                    const past = [...prevState.past];
                    const newPresent = past.pop();
                    if (!newPresent) return prevState;
                    return { past: past, present: newPresent, future: [prevState.present, ...prevState.future] };
                });
            }, []);

            const handleRedo = useCallback(() => {
                setHistoryState(prevState => {
                    const future = [...prevState.future];
                    const newPresent = future.shift();
                    if (!newPresent) return prevState;
                    return { past: [...prevState.past, prevState.present], present: newPresent, future: future };
                });
            }, []);

            const rotateSelectedElement90Degrees = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window' || selectedElement.type === 'compass' || selectedElement.type === 'fixture')) {
                    let newRotation = (selectedElement.rotation || 0) + 90;
                    if (newRotation > 180) {
                        newRotation -= 360;
                    }
                    handleSelectedElementUpdate({ rotation: newRotation });
                }
            }, [selectedElement, handleSelectedElementUpdate]);

            const toggleSelectedElementSwingDirection = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window')) {
                    const newIsInner = !selectedElement.isInner;
                    handleSelectedElementUpdate({ isInner: newIsInner });
                }
            }, [selectedElement, handleSelectedElementUpdate]);

            const handleSaveImage = async () => {
                const storedId = selectedId;
                setSelectedId(null);

                await new Promise(resolve => setTimeout(resolve, 0));

                const svgNode = svgRef.current;
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = dimensions.width;
                exportCanvas.height = dimensions.height;
                const ctx = exportCanvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                const svgClone = svgNode.cloneNode(true);
                svgClone.style.opacity = 1;

                const images = svgClone.querySelectorAll('image');
                const promises = Array.from(images).map(imageNode => {
                    const href = imageNode.getAttribute('href');
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    return fetch(proxyUrl + encodeURIComponent(href))
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Network response was not ok for ${href}`);
                            }
                            return response.blob();
                        })
                        .then(blob => new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                imageNode.setAttribute('href', reader.result);
                                resolve();
                            };
                            reader.onerror = () => {
                                reject(new Error('FileReader error'));
                            };
                            reader.readAsDataURL(blob);
                        }))
                        .catch(error => {
                            console.error(`Failed to fetch and embed image from ${href}:`, error);
                        });
                });

                try {
                    await Promise.all(promises);
                } catch (error) {
                    console.error("PNG保存エラー: 画像の埋め込みに失敗しました。", error);
                }

                const svgString = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                const img = new Image();

                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);
                    const link = document.createElement('a');
                    const today = new Date();
                    const yyyy = today.getFullYear();
                    const mm = String(today.getMonth() + 1).padStart(2, '0');
                    const dd = String(today.getDate()).padStart(2, '0');
                    link.download = `floorplan_${yyyy}${mm}${dd}.png`;
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                    setSelectedId(storedId);
                };
                img.onerror = () => {
                    console.error("Failed to load SVG blob into image for export.");
                    setSelectedId(storedId);
                }
                img.src = url;
            };



            useEffect(() => {
                // 設備のカテゴリが変更されたら、選択中の設備IDをそのカテゴリの先頭のIDに更新する
                const templates = FIXTURE_TEMPLATES[fixtureCategory];
                if (templates && templates.length > 0) {
                    setFixtureTemplateId(templates[0].id);
                }
            }, [fixtureCategory]); // fixtureCategory が変更された時だけこの処理を実行

            useEffect(() => {
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [svgElements, editorMode, selectedId, isDragging, resizingHandleInfo, dragInfo.current, handleCanvasClick, getCanvasCoords, getGridSnappedPoint, zoom, drawingMode, spaceShape, isGridVisible, mouseDownInfo.current]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }, [zoom, isGridVisible]);


            useEffect(() => {
                if (editorAreaRef.current) {
                    const area = editorAreaRef.current;
                    const timer = setTimeout(() => {
                        area.scrollTop = (area.scrollHeight - area.clientHeight) / 2;
                        const scrollLeftCenter = (area.scrollWidth - area.clientWidth) / 2;
                        const sidebarWidth = 320;
                        const newScrollLeft = isSidebarOpen ? scrollLeftCenter - (sidebarWidth / 2) : scrollLeftCenter;
                        area.scrollLeft = newScrollLeft;
                    }, 0);
                    return () => clearTimeout(timer);
                }
            }, [imageUrl, isSidebarOpen]);

            useEffect(() => {
                setFillColor(DEFAULT_FILL_COLORS[spaceType] || '#ffffff');
            }, [spaceType]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); handleUndo(); }
                    else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); handleRedo(); }
                    else if (e.key === 'Delete') { 
                        if (selectedId) {
                            e.preventDefault(); 
                            deleteSelectedElement();
                        }
                    }
                    else if (e.key === 'Escape') {
                        setDrawingStartPoint(null);
                        setLinePoints([]);
                        setSelectedId(null);
                        setResizingHandleInfo(null);
                        setPendingWindow(null);
                        setPendingFixture(null);
                        activeSnapWallRef.current = null;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleUndo, handleRedo, deleteSelectedElement, selectedId]);

            useEffect(() => {
                const editorArea = editorAreaRef.current;
                const editorContainer = editorContainerRef.current;
                if (!editorArea) return;

                    const handleWheel = (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();

                        const oldZoom = zoom;
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        const newZoom = Math.max(0.2, Math.min(3, oldZoom + delta));

                        const rect = editorArea.getBoundingClientRect();

                        // マウスカーソルのビューポート内での相対座標
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;

                        // ズーム前のマウスカーソルが指している、キャンバス全体のコンテンツ座標
                        // editorContainerがtranslate(-50%, -50%)されていることを考慮する必要がある
                        // scroll-wrapperの原点からの座標で考える
                        const contentMouseX = editorArea.scrollLeft + mouseX;
                        const contentMouseY = editorArea.scrollTop + mouseY;

                        // ズーム前のeditorContainerの左上基準の座標 (px)
                        // editorContainerはscroll-wrapperの中央に配置されているため、そのオフセットを計算
                        const currentContainerLeft = (editorArea.scrollWidth - dimensions.width * oldZoom) / 2;
                        const currentContainerTop = (editorArea.scrollHeight - dimensions.height * oldZoom) / 2;

                        // マウスが指している「editor-container」内の相対座標
                        const mouseInContainerX = (contentMouseX - currentContainerLeft) / oldZoom;
                        const mouseInContainerY = (contentMouseY - currentContainerTop) / oldZoom;


                        // ズーム率を更新
                        setZoom(newZoom);

                        // 新しいズーム率でのeditorContainerのサイズ
                        const newContainerWidth = dimensions.width * newZoom;
                        const newContainerHeight = dimensions.height * newZoom;

                        // 新しいズーム率でのeditorContainerの左上基準の座標
                        const newContainerLeft = (editorArea.scrollWidth - newContainerWidth) / 2;
                        const newContainerTop = (editorArea.scrollHeight - newContainerHeight) / 2;

                        // マウスが指しているeditor-container内の相対座標を新しいズーム率で計算し、
                        // 新しいeditorContainerの左上からのオフセットを加算
                        const newScrollLeft = (mouseInContainerX * newZoom) + newContainerLeft - mouseX;
                        const newScrollTop = (mouseInContainerY * newZoom) + newContainerTop - mouseY;

                        // スクロール位置を調整
                        editorArea.scrollLeft = newScrollLeft;
                        editorArea.scrollTop = newScrollTop;
                    }
                };

                editorArea.addEventListener('wheel', handleWheel, { passive: false });
                return () => editorArea.removeEventListener('wheel', handleWheel);
            }, [zoom, dimensions.width, dimensions.height]); // dimensionsも依存配列に追加

            useEffect(() => {
                setDrawingStartPoint(null);
                setLinePoints([]);
                setPendingWindow(null);
                setPendingFixture(null);
                setGuideLines([]);
                activeSnapWallRef.current = null;
            }, [editorMode, drawingMode, spaceShape]);

            useEffect(() => {
                if (!isDisplaySettingsOpen) return;
                function handleClickOutside(event) {
                    if (displaySettingsRef.current && !displaySettingsRef.current.contains(event.target) && editorAreaRef.current && !editorAreaRef.current.contains(event.target)) {
                        setDisplaySettingsOpen(false);
                    }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [isDisplaySettingsOpen]);

            useEffect(() => {
                if (editorMode === 'create' || editorMode === 'continuous-create') {
                    setSelectedId(null);
                }
            }, [editorMode]);

            useEffect(() => {
                const selectedEl = svgElements.find(el => el.id === selectedId);
             
                // 選択が解除された場合、前回IDの記録をリセット
                if (!selectedEl) {
                    prevSelectedIdRef.current = null;
                    return;
                }
    
                // テキスト要素が選択された場合
                if (selectedEl.type === 'text' && textEditAreaRef.current) {
                    // 前回選択されていたIDと現在のIDが異なる場合（＝新しく選択された場合）のみ全選択を実行
                    if (selectedId !== prevSelectedIdRef.current) {
                        textEditAreaRef.current.focus();
                        textEditAreaRef.current.select();
                    }
                }
    
                // 設備が選択された場合の処理（変更なし）
                if (selectedEl.type === 'fixture') {
                    const categoryKey = Object.keys(FIXTURE_TEMPLATES).find(cat =>
                        FIXTURE_TEMPLATES[cat].some(t => t.id === selectedEl.templateId)
                    );
                    if (categoryKey) {
                        setFixtureCategory(categoryKey);
                    }
                }

                // 今回のIDを「前回のID」として記録する
                prevSelectedIdRef.current = selectedId;
                
            }, [selectedId, svgElements]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Alt' || e.key === 'Shift') {
                        setIsModifierKeyDown(true);
                    }
                };
                const handleKeyUp = (e) => {
                    if (e.key === 'Alt' || e.key === 'Shift') {
                        setIsModifierKeyDown(false);
                    }
                };
                // ウィンドウからフォーカスが外れた場合もキー状態をリセット
                const handleBlur = () => {
                    setIsModifierKeyDown(false);
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                window.addEventListener('blur', handleBlur);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    window.removeEventListener('blur', handleBlur);
                };
            }, []); // このuseEffectは初回レンダリング時のみ実行

            // ▼▼▼ 自動保存用のuseEffect ▼▼▼
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const madorizuId = params.get('id');
        
                if (!madorizuId) {
                    alert('編集する間取り図が指定されていません。トップページに戻ります。');
                    window.location.href = 'index.html';
                    return;
                }
        
                const fetchMadorizuData = async () => {
                    setSaveStatus('読み込み中...');
                    const API_ENDPOINT = `https://y5cg2tb2yc.execute-api.ap-northeast-1.amazonaws.com/v1/madorizu/${madorizuId}`;
        
                    try {
                        const response = await fetch(API_ENDPOINT);
                        if (!response.ok) throw new Error('データの読み込みに失敗しました。');
        
                        const data = await response.json();
        
                        if (data && data.drawingData && data.drawingData.svgElements) {
                            setMadorizuName(data.name || '無題の間取り図');
                            setHistoryState(prevState => ({
                                ...prevState,
                                present: {
                                    ocrData: data.drawingData.ocrData || null,
                                    svgElements: data.drawingData.svgElements || []
                                }
                            }));
                        } else {
                            setMadorizuName(data.name || '無題の間取り図');
                            setHistoryState({ past: [], present: { ocrData: null, svgElements: [] }, future: [] });
                        }
                         setSaveStatus('保存済み');
                    } catch (error) {
                        console.error("読み込みエラー:", error);
                        setSaveStatus('読み込みエラー');
                        alert(error.message);
                    }
                };
        
                fetchMadorizuData();
            }, []); // このuseEffectは初回のみ実行
            
            // ▼▼▼ 名前変更時の自動保存用useEffect ▼▼▼
        useEffect(() => {
            // 初回読み込み時は、名前がセットされても保存しない
            if (isInitialNameLoad.current) {
                isInitialNameLoad.current = false;
                return;
            }

            // 名前が変更されたら「未保存」にする
            setSaveStatus('未保存');

            // 2秒後に保存処理を実行するタイマーを設定
            const timerId = setTimeout(() => {
                const saveData = async () => {
                    setSaveStatus('保存中...');
                    const params = new URLSearchParams(window.location.search);
                    const madorizuId = params.get('id');
                    if (!madorizuId) {
                        setSaveStatus('エラー');
                        return;
                    }
                    const API_ENDPOINT = `https://y5cg2tb2yc.execute-api.ap-northeast-1.amazonaws.com/v1/madorizu/${madorizuId}`;

                    try {
                        const response = await fetch(API_ENDPOINT, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: madorizuName, // 更新された名前を使用
                                drawingData: historyState.present // 描画データは現在の状態をそのまま使用
                            }),
                        });
                        if (!response.ok) throw new Error('サーバーへの保存に失敗しました。');
                        setSaveStatus('保存済み');
                    } catch (error) {
                        console.error("名前の自動保存エラー:", error);
                        setSaveStatus('エラー');
                    }
                };
                saveData();
            }, 2000); // ユーザーの入力が終わるのを2秒待つ

            // ユーザーがさらに入力を続けた場合、前回のタイマーはキャンセルする
            return () => clearTimeout(timerId);

        }, [madorizuName]); // madorizuNameが変更された時だけこの処理を実行

            const getCursorClass = () => {
                if (isDragging || resizingHandleInfo) return 'cursor-grabbing';
                if (editorMode === 'create' || editorMode === 'continuous-create') return 'cursor-crosshair';
                return 'cursor-default';
            };
            
            const getVerticesAndEdges = (element) => {
                if (!element) return { vertices: [], edges: [] };

                // ▼▼▼【修正】'door'と'window'の場合も壁と同様に頂点を返すようにする ▼▼▼
                if (element.type === 'wall' || element.type === 'door' || element.type === 'window') {
                    return { vertices: [{x: element.x1, y: element.y1}, {x: element.x2, y: element.y2}], edges: [] };
                }
                
                if (element.type === 'space') {
                    const points = element.points.split(' ').map(p => ({x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1])}));
                    const xs = points.map(p => p.x);
                    const ys = points.map(p => p.y);
                    const bbox = { minX: Math.min(...xs), minY: Math.min(...ys), maxX: Math.max(...xs), maxY: Math.max(...ys) };
                    const corners = [
                        {x: bbox.minX, y: bbox.minY}, {x: bbox.maxX, y: bbox.minY},
                        {x: bbox.maxX, y: bbox.maxY}, {x: bbox.minX, y: bbox.maxY}
                    ];
                    const edges = [
                        {x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY}, {x: bbox.maxX, y: (bbox.minY + bbox.maxY) / 2},
                        {x: (bbox.minX + bbox.maxX) / 2, y: bbox.maxY}, {x: bbox.minX, y: (bbox.minY + bbox.maxY) / 2}
                    ];
                    return { vertices: [], corners, edges };
                }
                if (element.type === 'fixture') {
                    const w = element.width;
                    const h = element.height;
                    const corners = [
                        { x: -w / 2, y: -h / 2 }, { x: w / 2, y: -h / 2 },
                        { x: w / 2, y: h / 2 }, { x: -w / 2, y: h / 2 }
                    ];
                    const edges = [
                        { x: 0, y: -h / 2 }, { x: w / 2, y: 0 },
                        { x: 0, y: h / 2 }, { x: -w / 2, y: 0 }
                    ];
                    return { vertices: [], corners, edges };
                }

                return { vertices: [], corners: [], edges: [] };
            }
            
            const getResizeCursor = (index, totalPoints) => {
                if (totalPoints === 4) { // Assume rect-like polygon
                    return ['nwse-resize', 'nesw-resize', 'nwse-resize', 'nesw-resize'][index];
                }
                return 'move';
            }
            
            const sortedElements = [...svgElements].sort((a, b) => {
                const typeOrder = { 'space': 0, 'wall': 1, 'stairs': 2, 'door': 3, 'window': 3, 'fixture': 4, 'compass': 5, 'text': 6 };
                const orderA = typeOrder[a.type] ?? 99;
                const orderB = typeOrder[b.type] ?? 99;
                if (orderA !== orderB) return orderA - orderB;
                if (a.type === 'space' && b.type === 'wall' && a.groupId === b.groupId) return -1;
                if (b.type === 'space' && a.type === 'wall' && b.groupId === a.groupId) return 1;
                return 0;
            });

            const TextRenderer = ({ element, isDirectlySelected, isDragging }) => {
                const textRef = useRef(null);
                const [bbox, setBbox] = useState(null);
                useLayoutEffect(() => {
                    if (textRef.current) {
                        const textBbox = textRef.current.getBBox();
                        setBbox(textBbox);
                    }
                }, [element.text, element.fontSize, element.fontFamily, element.textAlign, element.x, element.y, element.rotation]);

                let textAnchor = 'start';
                if (element.textAlign === 'center') textAnchor = 'middle';
                else if (element.textAlign === 'right') textAnchor = 'end';
                
                const x_px = element.x / 100 * dimensions.width;
                const y_px = element.y / 100 * dimensions.height;

                return (
                    <g data-id={element.id} transform={`rotate(${element.rotation || 0} ${x_px} ${y_px})`}>
                        {bbox && element.backgroundColor && element.backgroundColor !== 'none' && (
                            <rect
                                x={bbox.x - 4} y={bbox.y - 4}
                                width={bbox.width + 8} height={bbox.height + 8}
                                fill={element.backgroundColor}
                                rx="2"
                                style={{ pointerEvents: 'none' }}
                            />
                        )}
                        <text
                            ref={textRef}
                            x={`${element.x}%`}
                            y={`${element.y}%`}
                            fill={element.color}
                            fontSize={element.fontSize}
                            fontFamily={element.fontFamily}
                            style={{ cursor: isDirectlySelected && isDragging ? 'grabbing' : 'grab', pointerEvents: 'all' }}
                            textAnchor={textAnchor}
                        >
                            {element.text.split('\n').map((line, i) => (
                                <tspan key={i} x={`${element.x}%`} dy={i === 0 ? 0 : '1.2em'}>{line}</tspan>
                            ))}
                        </text>
                        {isDirectlySelected && bbox && (
                            <>
                                <rect
                                    x={bbox.x - 4} y={bbox.y - 4}
                                    width={bbox.width + 8} height={bbox.height + 8}
                                    fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2"
                                    rx="2" style={{ pointerEvents: 'none' }}
                                />
                                {/* 回転ハンドル */}
                                <line 
                                    x1={x_px} y1={y_px - bbox.height / 2 - 10}
                                    x2={x_px} y2={y_px - bbox.height / 2 - 20}
                                    stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2"
                                    style={{ pointerEvents: 'none' }}
                                />
                                <circle 
                                    data-id={element.id}
                                    data-handle-type="textRotation"
                                    cx={x_px} cy={y_px - bbox.height / 2 - 25} r={5 / zoom}
                                    fill="white" stroke={SELECTED_ELEMENT_COLOR} strokeWidth={2 / zoom}
                                    style={{ cursor: 'alias' }}
                                />
                            </>
                        )}
                    </g>
                );
            };

            // 背景パターンを描画するためのコンポーネント
            const BackgroundRenderer = ({ element }) => {
                if (!element.backgroundPattern || element.backgroundPattern === 'none' || element.type !== 'space') {
                    return null;
                }

                const points = element.points.split(' ').map(p_str => {
                    const [x, y] = p_str.split(',').map(parseFloat);
                    return { x, y };
                });

                if (points.length < 3) return null;

                const clipPathId = `clip-${element.id}`;

                const xs = points.map(p => p.x);
                const ys = points.map(p => p.y);
                const bbox = {
                    minX: Math.min(...xs),
                    minY: Math.min(...ys),
                    maxX: Math.max(...xs),
                    maxY: Math.max(...ys),
                };
                bbox.width = bbox.maxX - bbox.minX;
                bbox.height = bbox.maxY - bbox.minY;

                const renderPattern = () => {
                    const pattern = element.backgroundPattern;
                    const paths = [];
                    const strokeColor = '#cccccc';
                    const strokeWidth = 1;

                    switch (pattern) {
                        case 'vertical-lines': {
                            const step = 10;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'horizontal-lines': {
                            const step = 10;
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'grid-small': {
                            const step = 10;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'grid-large': {
                            const step = 30;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={'#000000'} strokeWidth={strokeWidth} />);
                            }
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={'#000000'} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'solid-x':
                        case 'dotted-x': {
                            const dashArray = pattern === 'dotted-x' ? '2 2' : 'none';
                            paths.push(<line key="x1" x1={bbox.minX} y1={bbox.minY} x2={bbox.maxX} y2={bbox.maxY} stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            paths.push(<line key="x2" x1={bbox.minX} y1={bbox.maxY} x2={bbox.maxX} y2={bbox.minY} stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            return paths;
                        }
                        case 'solid-triangle':
                        case 'dotted-triangle': {
                            const leftPoints = points.filter(p => p.x === bbox.minX).sort((a,b) => a.y - b.y);
                            const rightPoints = points.filter(p => p.x === bbox.maxX).sort((a,b) => a.y - b.y);

                            if (leftPoints.length >= 2 && rightPoints.length >= 1) {
                                const p1 = leftPoints[0];
                                const p2 = leftPoints[leftPoints.length - 1];
                                const pm = { x: bbox.maxX, y: (bbox.maxY + bbox.minY) / 2 };
                                const dashArray = pattern === 'dotted-triangle' ? '2 2' : 'none';
                                paths.push(<path key="tri" d={`M${p1.x},${p1.y} L${p2.x},${p2.y} L${pm.x},${pm.y} Z`} fill="none" stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            }
                            return paths;
                        }
                        default:
                            return null;
                    }
                };

                return (
                    <g style={{pointerEvents: 'none'}}>
                        <defs>
                            <clipPath id={clipPathId}>
                                <polygon points={element.points} />
                            </clipPath>
                        </defs>
                        <g clipPath={`url(#${clipPathId})`}>
                            {renderPattern()}
                        </g>
                    </g>
                );
            };

            const StairsRenderer = ({ element }) => {
                const { points: pointsStr, width, direction, color, strokeWidth } = element;

                // ヘルパー関数: 2直線の交点を計算
                const getLineIntersection = (p1, p2, p3, p4) => {
                    const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                    if (Math.abs(d) < 1e-8) { return null; }
                    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
                    return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                };

                const points = pointsStr.split(' ').map(p => { const [x, y] = p.split(',').map(parseFloat); return { x, y }; });
                if (points.length < 2) return null;

                const outlines = [[], []];

                // アウトラインの頂点を計算
                for (let i = 0; i < points.length; i++) {
                    const p_curr = points[i];
                    const p_prev = i > 0 ? points[i - 1] : null;
                    const p_next = i < points.length - 1 ? points[i + 1] : null;
                    const getPerp = (p1, p2) => {
                        const vec = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const len = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                        return len > 0 ? { x: -vec.y / len, y: vec.x / len } : { x: 0, y: 0 };
                    };

                    if (!p_prev) { // 始点
                        const perp = getPerp(p_curr, p_next);
                        outlines[0].push({ x: p_curr.x + perp.x * width / 2, y: p_curr.y + perp.y * width / 2 });
                        outlines[1].push({ x: p_curr.x - perp.x * width / 2, y: p_curr.y - perp.y * width / 2 });
                    } else if (!p_next) { // 終点
                        const perp = getPerp(p_prev, p_curr);
                        outlines[0].push({ x: p_curr.x + perp.x * width / 2, y: p_curr.y + perp.y * width / 2 });
                        outlines[1].push({ x: p_curr.x - perp.x * width / 2, y: p_curr.y - perp.y * width / 2 });
                    } else { // 角
                        const perp_in = getPerp(p_prev, p_curr);
                        const perp_out = getPerp(p_curr, p_next);
                        [1, -1].forEach(side => {
                            const outline_index = side === 1 ? 0 : 1;
                            const p1 = { x: p_prev.x + side * perp_in.x * width / 2, y: p_prev.y + side * perp_in.y * width / 2 };
                            const p2 = { x: p_curr.x + side * perp_in.x * width / 2, y: p_curr.y + side * perp_in.y * width / 2 };
                            const p3 = { x: p_curr.x + side * perp_out.x * width / 2, y: p_curr.y + side * perp_out.y * width / 2 };
                            const p4 = { x: p_next.x + side * perp_out.x * width / 2, y: p_next.y + side * perp_out.y * width / 2 };
                            let cornerPoint = getLineIntersection(p1, p2, p3, p4);
                            if (!cornerPoint) { cornerPoint = p2; }
                            outlines[outline_index].push(cornerPoint);
                        });
                    }
                }

                const steps = [];
                const stepInterval = 15;
                let accumulatedLength = 0;

                const cornerMargins = new Array(points.length).fill(0);
                for (let i = 1; i < points.length - 1; i++) {
                    const p_prev = points[i-1], p_curr = points[i], p_next = points[i+1];
                    const vec_in = { x: p_curr.x - p_prev.x, y: p_curr.y - p_prev.y };
                    const vec_out = { x: p_next.x - p_curr.x, y: p_next.y - p_curr.y };
                    const len_in = Math.sqrt(vec_in.x**2 + vec_in.y**2);
                    const len_out = Math.sqrt(vec_out.x**2 + vec_out.y**2);
                    const dir_in = len_in > 0 ? {x: vec_in.x/len_in, y: vec_in.y/len_in} : {x:0, y:0};
                    const dir_out = len_out > 0 ? {x: vec_out.x/len_out, y: vec_out.y/len_out} : {x:0, y:0};
                    let dot = dir_in.x * dir_out.x + dir_in.y * dir_out.y;
                    dot = Math.max(-1, Math.min(1, dot));
                    const angle = Math.acos(dot);

                    if (angle >= Math.PI / 4) {
                        cornerMargins[i] = Math.min(width / 2, len_in / 2, len_out / 2);
                    }
                }

                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i], p2 = points[i+1];
                    const segmentVec = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const segmentLen = Math.sqrt(segmentVec.x**2 + segmentVec.y**2);
                    if (segmentLen < 1) continue;
                    
                    const startMargin = cornerMargins[i];
                    const endMargin = cornerMargins[i+1];

                    const segmentDir = { x: segmentVec.x / segmentLen, y: segmentVec.y / segmentLen };
                    const perp = { x: -segmentDir.y, y: segmentDir.x };
                    let nextStepDist = Math.ceil((accumulatedLength + startMargin) / stepInterval) * stepInterval;
                    
                    while(nextStepDist < accumulatedLength + segmentLen - endMargin) {
                        const l = nextStepDist - accumulatedLength;
                        if (l >= startMargin) {
                            const stepCenter = { x: p1.x + segmentDir.x * l, y: p1.y + segmentDir.y * l };
                            const s1 = { x: stepCenter.x + perp.x * width / 2, y: stepCenter.y + perp.y * width / 2 };
                            const s2 = { x: stepCenter.x - perp.x * width / 2, y: stepCenter.y - perp.y * width / 2 };
                            steps.push(<line key={`step-s-${i}-${l}`} x1={s1.x} y1={s1.y} x2={s2.x} y2={s2.y} stroke={color} strokeWidth={1} />);
                        }
                        nextStepDist += stepInterval;
                    }
                    accumulatedLength += segmentLen;
                }

                for (let i = 1; i < points.length - 1; i++) {
                    const margin = cornerMargins[i];
                    const crossProduct = (points[i].x - points[i-1].x) * (points[i+1].y - points[i].y) - (points[i].y - points[i-1].y) * (points[i+1].x - points[i].x);

                    if (margin === 0) {
                        const innerCornerPoint = outlines[(crossProduct > 0) ? 1 : 0][i];
                        const outerCornerPoint = outlines[(crossProduct > 0) ? 0 : 1][i];
                        steps.push(<line key={`step-c-${i}`} x1={innerCornerPoint.x} y1={innerCornerPoint.y} x2={outerCornerPoint.x} y2={outerCornerPoint.y} stroke={color} strokeWidth={1} />);
                    } else {
                        const innerOutlineIndex = (crossProduct > 0) ? 1 : 0;
                        const outerOutlineIndex = (crossProduct > 0) ? 0 : 1;
                        
                        const innerCornerPoint = outlines[innerOutlineIndex][i];
                        const outerCornerPoint = outlines[outerOutlineIndex][i];

                        const prevInnerPoint = outlines[innerOutlineIndex][i-1];
                        const nextInnerPoint = outlines[innerOutlineIndex][i+1];
                        const vecInnerIn = { x: prevInnerPoint.x - innerCornerPoint.x, y: prevInnerPoint.y - innerCornerPoint.y };
                        const lenInnerIn = Math.sqrt(vecInnerIn.x**2 + vecInnerIn.y**2);
                        const dirInnerIn = { x: vecInnerIn.x / lenInnerIn, y: vecInnerIn.y / lenInnerIn };
                        const innerP1 = { x: innerCornerPoint.x + dirInnerIn.x * margin, y: innerCornerPoint.y + dirInnerIn.y * margin };
                        const vecInnerOut = { x: nextInnerPoint.x - innerCornerPoint.x, y: nextInnerPoint.y - innerCornerPoint.y };
                        const lenInnerOut = Math.sqrt(vecInnerOut.x**2 + vecInnerOut.y**2);
                        const dirInnerOut = { x: vecInnerOut.x / lenInnerOut, y: vecInnerOut.y / lenInnerOut };
                        const innerP2 = { x: innerCornerPoint.x + dirInnerOut.x * margin, y: innerCornerPoint.y + dirInnerOut.y * margin };
                        
                        steps.push(<line key={`step-c-${i}-1`} x1={innerP1.x} y1={innerP1.y} x2={outerCornerPoint.x} y2={outerCornerPoint.y} stroke={color} strokeWidth={1} />);
                        steps.push(<line key={`step-c-${i}-2`} x1={innerP2.x} y1={innerP2.y} x2={outerCornerPoint.x} y2={outerCornerPoint.y} stroke={color} strokeWidth={1} />);
                    }
                }

                // ▼▼▼ 修正点: 矢印とテキストの基準点を始点に変更 ▼▼▼
                const startPoint = points[0];
                const nextPoint = points[1];
                const arrowVec = { x: nextPoint.x - startPoint.x, y: nextPoint.y - startPoint.y };
                const arrowLen = Math.sqrt(arrowVec.x**2 + arrowVec.y**2);
                const arrowDir = arrowLen > 0 ? { x: arrowVec.x / arrowLen, y: arrowVec.y / arrowLen } : { x: 0, y: 0 };
                const arrowText = direction ? direction.toUpperCase() : '';
                const arrowAngle = Math.atan2(arrowDir.y, arrowDir.x) * 180 / Math.PI;

                // テキストと矢印のオフセット
                const textOffsetX = -arrowDir.x * 20;
                const textOffsetY = -arrowDir.y * 20;

                return (
                    <g data-id={element.id} style={{ pointerEvents: 'all', cursor: 'grab' }}>
                        <path d={`M ${outlines[0].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={strokeWidth} strokeLinejoin="miter" strokeLinecap="square" />
                        <path d={`M ${outlines[1].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={strokeWidth} strokeLinejoin="miter" strokeLinecap="square" />
                        {steps}
                        {/* ▼▼▼ テキスト描画を削除し、矢印(中心線)は常に表示 ▼▼▼ */}
                        <path d={`M ${points.map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={1} markerEnd="url(#arrowhead)" />
                    </g>
                );
            };

            return (                    
                <div className="flex flex-col h-screen">
                    <UploadModal
                        isOpen={isUploadModalOpen}
                        onClose={() => setUploadModalOpen(false)}
                        onSubmit={handleModalSubmit}
                        isLoading={isLoading}
                        loadingMessage={loadingMessage}
                    />
                    <header className="bg-white shadow-md p-2 flex items-center justify-between z-30 flex-shrink-0">
                        <div className="flex items-center space-x-4">
                            {isEditingName ? (
                                <input
                                    type="text"
                                    value={madorizuName}
                                    onChange={(e) => setMadorizuName(e.target.value)}
                                    onBlur={() => setIsEditingName(false)}
                                    onKeyDown={(e) => { if (e.key === 'Enter') setIsEditingName(false); }}
                                    className="text-xl font-bold text-gray-800 ml-4 bg-gray-100 border-b-2 border-indigo-500 focus:outline-none"
                                    autoFocus
                                />
                            ) : (
                                <span
                                    onClick={() => setIsEditingName(true)}
                                    className="text-xl font-bold text-gray-800 ml-4 cursor-pointer hover:bg-gray-100 p-1 rounded-md"
                                    title="クリックして名前を編集"
                                >
                                    {madorizuName}
                                </span>
                            )}
                            <div className={`text-sm transition-opacity duration-300 
                                ${saveStatus === '保存済み' ? 'text-gray-500' : 
                                saveStatus === '保存中...' ? 'text-blue-500 animate-pulse' : 
                                'text-gray-800 font-medium'
                                }`}>
                                {saveStatus}
                            </div>
                        </div>
                        <div className="flex items-center space-x-4">
                            <button onClick={() => window.location.href = 'index.html'} className="px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600">TOPに戻る</button>
                            <button onClick={handleSaveImage} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">PNGで保存</button>
                            <button onClick={handleUndo} disabled={historyState.past.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">戻る</button>
                            <button onClick={handleRedo} disabled={historyState.future.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">進む</button>
                            <div className="flex items-center space-x-2">
                                <button onClick={() => setZoom(z => Math.max(0.2, z - 0.1))} className="px-3 py-1 bg-gray-200 rounded">-</button>
                                <span>{Math.round(zoom * 100)}%</span>
                                <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="px-3 py-1 bg-gray-200 rounded">+</button>
                            </div>
                        </div>
                    </header>

                    <div className="flex-1 relative overflow-hidden">
                        <main ref={editorAreaRef} className="editor-area w-full h-full bg-gray-200">
                            <div className="scroll-wrapper">
                                <div ref={editorContainerRef} className="editor-container" style={{ width: dimensions.width, height: dimensions.height, transform: `translate(-50%, -50%) scale(${zoom})`, ...(isGridVisible && { backgroundImage: `linear-gradient(to right, #f3f4f6 1px, transparent 1px), linear-gradient(to bottom, #f3f4f6 1px, transparent 1px)`, backgroundSize: `${gridSize}px ${gridSize}px` }) }}>
                                    {imageUrl && <img 
                                        ref={imageRef} 
                                        src={imageUrl} 
                                        alt="間取り図" 
                                        className="editor-image" 
                                        style={{ 
                                            opacity: 1 - imageOpacity, 
                                            transform: `translate(-50%, -50%) translate(${imagePosition.x}px, ${imagePosition.y}px) scale(${imageScale})`,
                                            cursor: isDisplaySettingsOpen ? 'grab' : 'default',
                                            pointerEvents: isDisplaySettingsOpen ? 'all' : 'none'
                                        }} 
                                        crossOrigin="anonymous"
                                    />}
                                    <canvas ref={canvasRef} className={getCursorClass()} width={dimensions.width} height={dimensions.height} />
                                    <svg ref={svgRef} className="editor-svg" width={dimensions.width} height={dimensions.height} xmlns="http://www.w3.org/2000/svg" style={{ opacity: 1 - drawingOpacity }} onMouseDown={handleMouseDown}>
                                        <defs>
                                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                                <polygon points="0 0, 10 3.5, 0 7" />
                                            </marker>
                                        </defs>
                                        {sortedElements.map(el => {
                                            const isDirectlySelected = el.id === selectedId;
                                            const isPartOfSelectedSpace = selectedElement?.type === 'space' && el.groupId === selectedId;
                                            const isHighlighted = (isDirectlySelected || isPartOfSelectedSpace) && !isPickingColor;

                                            const stroke = isHighlighted ? SELECTED_ELEMENT_COLOR : (el.color || el.stroke || DEFAULT_STROKE_COLOR); 
                                            const strokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                            const style = LINE_STYLES.find(s => s.id === el.lineStyle);
                                            
                                            if (el.type === 'space') {
                                                return (
                                                    <g key={el.id}>
                                                        <polygon data-id={el.id} points={el.points} fill={el.fill} stroke="none" shapeRendering="crispEdges" style={{ pointerEvents: (editorMode === 'create' || editorMode === 'continuous-create') ? 'none' : 'all' }} />
                                                        <BackgroundRenderer element={el} />
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'wall') {
                                                let { x1, y1, x2, y2 } = el;
                                                const extension = el.strokeWidth / 2;
                                                const dx_orig = el.x2 - el.x1;
                                                const dy_orig = el.y2 - el.y1;
                                                const len_orig = Math.sqrt(dx_orig * dx_orig + dy_orig * dy_orig);
                                                if (len_orig > 0) {
                                                    const ux = dx_orig / len_orig;
                                                    const uy = dy_orig / len_orig;
                                                    x1 -= ux * extension;
                                                    y1 -= uy * extension;
                                                    x2 += ux * extension;
                                                    y2 += uy * extension;
                                                }

                                                const pointerEvents = (editorMode === 'create' || editorMode === 'continuous-create') ? 'none' : 'all';
                                                const style = LINE_STYLES.find(s => s.id === el.lineStyle);
                                                const strokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                                const stroke = isHighlighted ? SELECTED_ELEMENT_COLOR : (el.color || el.stroke || DEFAULT_STROKE_COLOR);

                                                if (el.lineStyle === 'double') {
                                                    const dx = x2 - x1;
                                                    const dy = y2 - y1;
                                                    const len = Math.sqrt(dx * dx + dy * dy);
                                                    if (len === 0) return null;
                                                    const finalStrokeWidth = 0.5;
                                                    const spaceFillerWidth = Math.max(0, strokeW - (2 * finalStrokeWidth));
                                                    const offsetDistance = (strokeW - finalStrokeWidth) / 2;
                                                    const offsetX = -dy / len * offsetDistance;
                                                    const offsetY = dx / len * offsetDistance;
                                                    return (
                                                        <g key={el.id} data-id={el.id} style={{ pointerEvents, cursor: 'pointer' }}>
                                                            {spaceFillerWidth > 0 &&
                                                                <line x1={x1} y1={y1} x2={x2} y2={y2} stroke="white" strokeWidth={spaceFillerWidth} style={{ pointerEvents: 'none' }} />
                                                            }
                                                            <line x1={x1 + offsetX} y1={y1 + offsetY} x2={x2 + offsetX} y2={y2 + offsetY}
                                                                stroke={stroke} strokeWidth={finalStrokeWidth} style={{ pointerEvents: 'none' }} />
                                                            <line x1={x1 - offsetX} y1={y1 - offsetY} x2={x2 - offsetX} y2={y2 - offsetY}
                                                                stroke={stroke} strokeWidth={finalStrokeWidth} style={{ pointerEvents: 'none' }} />
                                                            <line x1={el.x1} y1={el.y1} x2={el.x2} y2={el.y2}
                                                                stroke="transparent" strokeWidth={Math.max(strokeW, 10)} />
                                                        </g>
                                                    );
                                                }

                                                return (
                                                    <g key={el.id} data-id={el.id} style={{ pointerEvents, cursor: 'pointer' }}>
                                                        {/* 見た目用の線 */}
                                                        <line x1={x1} y1={y1} x2={x2} y2={y2} stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} style={{ pointerEvents: 'none' }} />
                                                        {/* クリック判定用の透明な線 */}
                                                        <line x1={x1} y1={y1} x2={x2} y2={y2} stroke="transparent" strokeWidth={Math.max(strokeW, 10)} />
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'stairs') {
                                                return <StairsRenderer key={el.id} element={{...el, color: stroke, strokeWidth: strokeW}} />;
                                            }
                                            if (el.type === 'text') {
                                                return <TextRenderer key={el.id} element={el} isDirectlySelected={isDirectlySelected} isDragging={isDragging} />;
                                            }
                                            if (el.type === 'compass') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const template = COMPASS_TEMPLATES.find(t => t.id === el.templateId) || COMPASS_TEMPLATES[0];
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0})`} style={{cursor: isDirectlySelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <image href={template.src} x={-el.size / 2} y={-el.size / 2} width={el.size} height={el.size} preserveAspectRatio="xMidYMid meet" />
                                                        {isDirectlySelected && <rect x={-el.size/2 - 2} y={-el.size/2 - 2} width={el.size + 4} height={el.size + 4} fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2" />}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'fixture') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === el.templateId))] || FIXTURE_TEMPLATES.kitchen;
                                                const template = templateCategory.find(t => t.id === el.templateId) || FIXTURE_TEMPLATES.kitchen[0];

                                                let handles = null;
                                                // 選択されている場合にのみハンドルを描画
                                                if (isDirectlySelected) {
                                                    const { corners, edges } = getVerticesAndEdges(el);
                                                    handles = (
                                                        <g>
                                                            {/* 青い枠線 */}
                                                            <rect 
                                                                x={-el.width / 2 - 5} y={-el.height / 2 - 5}
                                                                width={el.width + 10} height={el.height + 10}
                                                                fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth={1.5 / zoom}
                                                                strokeDasharray={`${4 / zoom}, ${2 / zoom}`}
                                                                style={{ pointerEvents: 'none' }}
                                                            />
                                                            {/* 四隅の黒いポッチ */}
                                                            {corners.map((corner, index) => (
                                                                <circle key={`handle-corner-${el.id}-${index}`}
                                                                    data-id={el.id} data-handle-index={index} data-handle-type="fixtureCorner"
                                                                    cx={corner.x} cy={corner.y} r={6 / zoom}
                                                                    fill="black" stroke="white" strokeWidth={2 / zoom}
                                                                    style={{ cursor: ['nwse-resize', 'nesw-resize', 'nwse-resize', 'nesw-resize'][index] }}
                                                                />
                                                            ))}
                                                            {/* 各辺の白いひし形 */}
                                                            {edges.map((edge, index) => (
                                                                <rect key={`handle-edge-${el.id}-${index}`}
                                                                    data-id={el.id} data-handle-index={index} data-handle-type="fixtureEdge"
                                                                    x={edge.x - 5 / zoom} y={edge.y - 5 / zoom}
                                                                    width={10 / zoom} height={10 / zoom}
                                                                    fill="white" stroke="black" strokeWidth={1 / zoom}
                                                                    style={{ cursor: (index === 0 || index === 2) ? 'ns-resize' : 'ew-resize' }}
                                                                    transform={`rotate(45 ${edge.x} ${edge.y})`}
                                                                />
                                                            ))}
                                                        </g>
                                                    );
                                                }

                                                let fixtureElement;
                                                if (template.src) {
                                                    fixtureElement = <image
                                                        href={template.src}
                                                        x={-el.width / 2} y={-el.height / 2}
                                                        width={el.width} height={el.height}
                                                        preserveAspectRatio="none"
                                                    />;
                                                } else {
                                                    const scaleX = el.width / template.defaultSize;
                                                    const scaleY = el.height / template.defaultSize;
                                                    fixtureElement = <g transform={`scale(${scaleX}, ${scaleY})`}>
                                                        <path 
                                                            d={template.path} 
                                                            fill={el.fill} 
                                                            stroke={el.stroke} 
                                                            strokeWidth={el.strokeWidth}
                                                            vectorEffect="non-scaling-stroke" // スケールしても線の太さを維持
                                                        />
                                                    </g>;
                                                }

                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0}) ${el.isFlipped ? 'scale(-1, 1)' : ''}`} style={{cursor: isDirectlySelected ? 'default' : 'grab'}}>
                                                        {fixtureElement}
                                                        {handles}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'door' || el.type === 'window') {
                                                // 要素の中心座標を計算
                                                const centerX = (el.x1 + el.x2) / 2;
                                                const centerY = (el.y1 + el.y2) / 2;
                                                const template = el.type === 'door' 
                                                ? (DOOR_TEMPLATES.find(t => t.id === el.templateId) || DOOR_TEMPLATES[0]) 
                                                : (WINDOW_TEMPLATES.find(t => t.id === el.templateId) || WINDOW_TEMPLATES[0]);
                                                
                                                const totalRotation = el.baseAngle + (el.rotation || 0);
                                                const paths = template.path(el.length, el.swingDirection, el.isInner, el.wallThickness);

                                                if (Array.isArray(paths)) {
                                                    const padding = 4 / zoom;
                                                    const clickPadding = 5;
                                                    return (
                                                        <g key={el.id} data-id={el.id} transform={`translate(${centerX}, ${centerY}) rotate(${totalRotation}) translate(${-el.length / 2}, 0)`} style={{cursor: isDirectlySelected && isDragging ? 'grabbing' : 'grab'}}>
                                                            {paths.map((part, index) => (
                                                            <path
                                                                key={index}
                                                                d={part.d}
                                                                fill={part.fill === 'currentColor' ? stroke : part.fill || 'none'}
                                                                stroke={part.stroke === 'currentColor' ? stroke : part.stroke || 'none'}
                                                                strokeWidth={part.strokeWidth || 1}
                                                                strokeLinecap="square"
                                                                style={{pointerEvents: 'none'}}
                                                            />
                                                            ))}
                                                            <rect 
                                                                x={-clickPadding}
                                                                y={-el.wallThickness / 2 - clickPadding}
                                                                width={el.length + clickPadding * 2}
                                                                height={el.wallThickness + clickPadding * 2}
                                                                fill="transparent" 
                                                                style={{pointerEvents: 'all', cursor: 'pointer'}}
                                                            />
                                                            {isHighlighted && (
                                                            <rect
                                                                x={-padding}
                                                                y={-el.wallThickness / 2 - padding}
                                                                width={el.length + padding * 2}
                                                                height={el.wallThickness + padding * 2}
                                                                fill="none"
                                                                stroke={SELECTED_ELEMENT_COLOR}
                                                                strokeWidth={1.5 / zoom}
                                                                strokeDasharray={`4, ${4 / zoom}`}
                                                                style={{ pointerEvents: 'none' }}
                                                            />
                                                            )}
                                                        </g>
                                                    );
                                                }
                                            }
                                            return null;
                                        })}

                                        {guideLines.map((line, index) => (
                                            <line
                                                key={`guide-${index}`}
                                                x1={line.x1}
                                                y1={line.y1}
                                                x2={line.x2}
                                                y2={line.y2}
                                                stroke={SELECTED_ELEMENT_COLOR}
                                                strokeWidth={1 / zoom}
                                                strokeDasharray={`${4 / zoom}, ${4 / zoom}`}
                                                style={{ pointerEvents: 'none' }}
                                            />
                                        ))}

                                        {/* スナップされた位置に表示される丸印 */}
                                        {snappedInfo && (editorMode === 'create' || editorMode === 'continuous-create') && (() => {
                                            let snapStrokeColor;
                                            let snapStrokeWidth;

                                            if (snappedInfo.type === 'vertex' || snappedInfo.type === 'startPoint') { // 'startPoint' を追加
                                                snapStrokeColor = '#FF0000'; // 赤色に統一
                                                snapStrokeWidth = 4 / zoom; // 太めの線
                                            } else if (snappedInfo.type === 'wall') {
                                                snapStrokeColor = '#FF0000'; // 赤色に統一
                                                snapStrokeWidth = 2 / zoom; // 通常の線
                                            } else { // 'grid' の場合
                                                snapStrokeColor = SELECTED_ELEMENT_COLOR; // グリッドスナップはデフォルトの青色
                                                snapStrokeWidth = 2 / zoom;
                                            }

                                            return (
                                                <circle
                                                    cx={snappedInfo.point.x}
                                                    cy={snappedInfo.point.y}
                                                    r={8 / zoom} // ズームによってサイズを調整
                                                    fill="none"
                                                    stroke={snapStrokeColor}
                                                    strokeWidth={snapStrokeWidth}
                                                    style={{ pointerEvents: 'none' }}
                                                />
                                            );
                                        })()}
                                                
                                        {editorMode === 'edit' && (() => {
                                            if (!selectedElement) return null;
                                            if (selectedElement.type === 'wall' || selectedElement.type === 'door' || selectedElement.type === 'window') {
                                                const { vertices } = getVerticesAndEdges(selectedElement);
                                                return (
                                                    <g>
                                                        {vertices.map((vertex, index) => (
                                                            // ▼▼▼【修正】data-handle-typeに要素のタイプを動的に設定 ▼▼▼
                                                            <circle key={`handle-vertex-${selectedElement.id}-${index}`} data-id={selectedElement.id} data-handle-index={index} data-handle-type={selectedElement.type} cx={vertex.x} cy={vertex.y} r={6 / zoom} fill="black" stroke="white" strokeWidth={2 / zoom} style={{ cursor: 'pointer' }} />
                                                        ))}
                                                    </g>
                                                );
                                            }
                                            if (selectedElement.type === 'space') {
                                                const { corners, edges } = getVerticesAndEdges(selectedElement);
                                                return (
                                                    <g>
                                                        {corners.map((corner, index) => (
                                                            <circle key={`handle-corner-${selectedElement.id}-${index}`} data-id={selectedElement.id} data-handle-index={index} data-handle-type="spaceCorner" cx={corner.x} cy={corner.y} r={6 / zoom} fill="black" stroke="white" strokeWidth={2 / zoom} style={{ cursor: getResizeCursor(index, corners.length) }} />
                                                        ))}
                                                        {edges.map((edge, index) => (
                                                             <rect key={`handle-edge-${selectedElement.id}-${index}`} data-id={selectedElement.id} data-handle-index={index} data-handle-type="spaceEdge" x={edge.x - 5 / zoom} y={edge.y - 5 / zoom} width={10 / zoom} height={10 / zoom} fill="white" stroke="black" strokeWidth={1 / zoom} style={{ cursor: (index === 0 || index === 2) ? 'ns-resize' : 'ew-resize' }} transform={`rotate(45 ${edge.x} ${edge.y})`} />
                                                        ))}
                                                    </g>
                                                );
                                            }
                                            return null;
                                        })()}

                                        {/* --- 設備プレビューの描画 --- */}
                                        {(editorMode === 'create' || editorMode === 'continuous-create') && drawingMode === 'fixture' && (() => {
                                            const template = FIXTURE_TEMPLATES[fixtureCategory]?.find(t => t.id === fixtureTemplateId) || FIXTURE_TEMPLATES.kitchen[0];
                                            if (!template) return null;

                                            const baseSize = BASE_FIXTURE_DEFAULT_SIZE;
                                            const templateDefaultSize = template.defaultSize || baseSize;
                                            const scaleRatio = baseSize / templateDefaultSize;
                                            const previewWidth = fixtureSize * scaleRatio;
                                            const aspectRatio = template.aspectRatio || 1;
                                            const previewHeight = previewWidth / aspectRatio;

                                            let previewElement;
                                            if (template.src) {
                                                previewElement = <image href={template.src} x={-previewWidth / 2} y={-previewHeight / 2} width={previewWidth} height={previewHeight} preserveAspectRatio="none" />;
                                            } else {
                                                const scaleX = previewWidth / template.defaultSize;
                                                const scaleY = previewHeight / template.defaultSize;
                                                previewElement = <g transform={`scale(${scaleX}, ${scaleY})`}><path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} vectorEffect="non-scaling-stroke" /></g>;
                                            }

                                            // ▼▼▼【修正点】1クリック前と後で処理を分岐 ▼▼▼
                                            if (pendingFixture) {
                                                // 1クリック後の処理 (位置を固定し、回転/反転をマウスで変更)
                                                const startPoint = pendingFixture;
                                                const endPoint = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                                const dx = endPoint.x - startPoint.x;
                                                const dy = endPoint.y - startPoint.y;
                                                const finalRotation = fixtureRotation + ((dx < 0) ? 180 : 0);
                                                const isFlipped = (dy > 0);
                                                return (
                                                    <g transform={`translate(${startPoint.x}, ${startPoint.y}) rotate(${finalRotation || 0}) ${isFlipped ? 'scale(-1, 1)' : ''}`} style={{ opacity: 0.7, pointerEvents: 'none' }}>
                                                        {previewElement}
                                                    </g>
                                                );
                                            } else {
                                                // 1クリック前の処理 (マウスカーソルに追従)
                                                const previewPos = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                                return (
                                                    <g transform={`translate(${previewPos.x}, ${previewPos.y}) rotate(${fixtureRotation || 0}) ${fixtureFlip ? 'scale(-1, 1)' : ''}`} style={{ opacity: 0.7, pointerEvents: 'none' }}>
                                                        {previewElement}
                                                    </g>
                                                );
                                            }
                                        })()}

                                        {/* --- 方角の1クリック前プレビュー --- */}
                                          {!drawingStartPoint && (editorMode === 'create' || editorMode === 'continuous-create') && drawingMode === 'compass' && (() => {
                                              const template = COMPASS_TEMPLATES.find(t => t.id === compassTemplateId) || COMPASS_TEMPLATES[0];
                                              const previewSize = 50; // プレビュー用のデフォルトサイズ
                                              const previewPos = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                  
                                              return (
                                                  <g transform={`translate(${previewPos.x}, ${previewPos.y})`} style={{ opacity: 0.7, pointerEvents: 'none' }}>
                                                      <image
                                                          href={template.src}
                                                          x={-previewSize / 2}
                                                          y={-previewSize / 2}
                                                          width={previewSize}
                                                          height={previewSize}
                                                          preserveAspectRatio="xMidYMid meet"
                                                      />
                                                  </g>
                                              );
                                          })()}

                                        {/* --- 既存の2クリック描画プレビュー --- */}
                                        {drawingStartPoint && !linePoints.length && (editorMode === 'create' || editorMode === 'continuous-create') && (() => {
                                            let previewEndPoint;
                                            const walls = svgElements.filter(el => el.type === 'wall');

                                            // 「壁の上に描画」が有効な場合
                                            if ((drawingMode === 'door' || drawingMode === 'window') && isSnapToWall && !isModifierKeyDown && walls.length > 0) {
                                                // マウスカーソルから最も近い壁上の点を計算する
                                                previewEndPoint = getClosestPointOnWalls(mousePos, walls);
                                            } else {
                                                // それ以外の場合は、従来通りスナップ情報かグリッド位置を使用
                                                previewEndPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(mousePos) : mousePos);
                                            }
                                            if(drawingMode === 'compass') {
                                                const template = COMPASS_TEMPLATES.find(t => t.id === compassTemplateId) || COMPASS_TEMPLATES[0];
                                                const dx = mousePos.x - drawingStartPoint.x;
                                                const dy = mousePos.y - drawingStartPoint.y;
                                                const distance = Math.sqrt(dx*dx + dy*dy);
                                                const size = Math.min(300, Math.max(20, distance));
                                                const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                                                return (
                                                    <g transform={`translate(${drawingStartPoint.x}, ${drawingStartPoint.y}) rotate(${rotation})`} style={{ pointerEvents: 'none' }}>
                                                        <image href={template.src} x={-size / 2} y={-size / 2} width={size} height={size} preserveAspectRatio="xMidYMid meet" opacity="0.7"/>
                                                    </g>
                                                );
                                            }
                                            if(drawingMode === 'space' && spaceShape === 'rect') return <rect 
                                                x={Math.min(drawingStartPoint.x, previewEndPoint.x)} 
                                                y={Math.min(drawingStartPoint.y, previewEndPoint.y)} 
                                                width={Math.abs(drawingStartPoint.x - previewEndPoint.x)} 
                                                height={Math.abs(drawingStartPoint.y - previewEndPoint.y)} 
                                                fill="transparent" 
                                                stroke={SELECTED_ELEMENT_COLOR}
                                                strokeWidth={DEFAULT_STROKE_WIDTH} 
                                                strokeDasharray="5,5" 
                                                style={{ pointerEvents: 'none' }} 
                                                shapeRendering="crispEdges" 
                                            />;
                                            if(drawingMode === 'door' || drawingMode === 'window' || drawingMode === 'wall') return <line 
                                                x1={drawingStartPoint.x} 
                                                y1={drawingStartPoint.y} 
                                                x2={previewEndPoint.x} 
                                                y2={previewEndPoint.y} 
                                                stroke={SELECTED_ELEMENT_COLOR}
                                                strokeWidth={strokeWidth} 
                                                strokeDasharray="5,5" 
                                                style={{ pointerEvents: 'none' }} 
                                            />;
                                            return null;
                                        })()}
                                        {snappedInfo && (
                                            <g style={{ pointerEvents: 'none' }}>
                                                <circle 
                                                    cx={snappedInfo.point.x} 
                                                    cy={snappedInfo.point.y} 
                                                    r={SNAP_THRESHOLD / zoom} 
                                                    fill="rgba(59, 130, 246, 0.2)" 
                                                />
                                                <circle 
                                                    cx={snappedInfo.point.x} 
                                                    cy={snappedInfo.point.y} 
                                                    r={6 / zoom} 
                                                    fill="white"
                                                    stroke="#3b82f6"
                                                    strokeWidth={1.5 / zoom}
                                                />
                                            </g>
                                        )}
                                        {snappedInfo && !drawingStartPoint && (
                                            <g style={{ pointerEvents: 'none' }}>
                                                <circle 
                                                    cx={snappedInfo.point.x}
                                                    cy={snappedInfo.point.y}
                                                    r={SNAP_THRESHOLD / zoom} 
                                                    fill="rgba(59, 130, 246, 0.2)" 
                                                />
                                                <circle 
                                                    cx={snappedInfo.point.x} 
                                                    cy={snappedInfo.point.y} 
                                                    r={6 / zoom} 
                                                    fill="white"
                                                    stroke="#3b82f6"
                                                    strokeWidth={1.5 / zoom}
                                                />
                                            </g>
                                        )}
                                        {linePoints.length > 0 && (
                                            <g style={{pointerEvents: 'none'}}>
                                                {linePoints.map((p, i) => {
                                                    if (i === 0) return null;
                                                    const p1 = linePoints[i-1];
                                                    return <line key={i} x1={p1.x} y1={p1.y} x2={p.x} y2={p.y} stroke={SELECTED_ELEMENT_COLOR} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray={LINE_STYLES.find(s => s.id === lineStyle)?.dashArray || 'none'} />;
                                                })}
                                                <line
                                                    x1={linePoints[linePoints.length - 1].x}
                                                    y1={linePoints[linePoints.length - 1].y}
                                                    x2={isSnappingToStart ? linePoints[0].x : (isGridVisible ? getGridSnappedPoint(mousePos).x : mousePos.x)}
                                                    y2={isSnappingToStart ? linePoints[0].y : (isGridVisible ? getGridSnappedPoint(mousePos).y : mousePos.y)}
                                                    stroke={SELECTED_ELEMENT_COLOR} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5"
                                                />
                                            </g>
                                        )}
                                        {linePoints.length > 0 && drawingMode === 'stairs' && (
                                            // 階段作成時は、新しいプレビューコンポーネントを呼び出す
                                            <StairsPreviewRenderer 
                                                points={[...linePoints, isGridVisible ? getGridSnappedPoint(mousePos) : mousePos]}
                                                width={stairWidth}
                                                color={strokeColor}
                                            />
                                        )}
                                        {pendingWindow && (editorMode === 'create' || editorMode === 'continuous-create') && (() => {
                                            const { start, end } = pendingWindow;
                                            // 始点と終点の中間点を計算
                                            const center = {
                                                x: (start.x + end.x) / 2,
                                                y: (start.y + end.y) / 2,
                                            };
                                            // 中間点とマウスカーソルの相対位置を計算
                                            const dx = mousePos.x - center.x;
                                            const dy = mousePos.y - center.y;

                                            let rotation = 0;
                                            let isInner = false;

                                            // マウスカーソルの位置から4方向を決定
                                            if (dx < 0 && dy < 0) { // 左上
                                                rotation = 180;
                                                isInner = true;
                                            } else if (dx > 0 && dy < 0) { // 右上
                                                rotation = 0;
                                                isInner = false;
                                            } else if (dx > 0 && dy > 0) { // 右下
                                                rotation = 0;
                                                isInner = true;
                                            } else { // 左下
                                                rotation = 180;
                                                isInner = false;
                                            }

                                            const length = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                                            const baseAngle = Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;
                                            const totalRotation = baseAngle + rotation;
                                            
                                            let template;
                                            if (drawingMode === 'door') {
                                                template = DOOR_TEMPLATES.find(t => t.id === doorTemplateId) || DOOR_TEMPLATES[0];
                                            } else { // windowの場合
                                                template = WINDOW_TEMPLATES.find(t => t.id === windowTemplateId) || WINDOW_TEMPLATES[0];
                                            }
                                            const wallThickness = (isSnapToWall && activeSnapWallRef.current ? activeSnapWallRef.current.strokeWidth : wallObjectThickness);
                                            const paths = template.path(length, 'clockwise', isInner, wallThickness);

                                            if (!Array.isArray(paths)) return null;

                                            // 決定した方向でプレビュー用の窓を描画
                                            return (
                                                <g 
                                                    transform={`translate(${center.x}, ${center.y}) rotate(${totalRotation}) translate(${-length / 2}, 0)`}
                                                    style={{ pointerEvents: 'none', opacity: 0.7 }}
                                                >
                                                    {paths.map((part, index) => (
                                                        <path
                                                            key={index}
                                                            d={part.d}
                                                            fill={part.fill === 'currentColor' ? strokeColor : part.fill || 'none'}
                                                            stroke={part.stroke === 'currentColor' ? strokeColor : part.stroke || 'none'}
                                                            strokeWidth={part.strokeWidth || 1}
                                                            strokeDasharray="5,5" // プレビューなので点線にする
                                                        />
                                                    ))}
                                                </g>
                                            );
                                        })()}
                                        {tooltip.visible && (
                                            <foreignObject x={tooltip.x - 125} y={tooltip.y - 55} width="250" height="60" style={{ pointerEvents: 'none', overflow: 'visible' }}>
                                                <div xmlns="http://www.w3.org/1999/xhtml"
                                                    style={{
                                                        opacity: tooltip.fading ? 0 : 1,
                                                        transition: 'opacity 2s ease-out',
                                                        background: 'rgba(0, 0, 0, 0.75)',
                                                        color: 'white',
                                                        padding: '8px 12px',
                                                        borderRadius: '6px',
                                                        fontSize: '13px',
                                                        fontFamily: "'Noto Sans JP', sans-serif",
                                                        position: 'relative',
                                                        textAlign: 'center',
                                                        userSelect: 'none'
                                                    }}>
                                                        {tooltip.message}
                                                        <div style={{
                                                            position: 'absolute',
                                                            top: '100%',
                                                            left: '50%',
                                                            transform: 'translateX(-50%)',
                                                            width: 0,
                                                            height: 0,
                                                            borderLeft: '8px solid transparent',
                                                            borderRight: '8px solid transparent',
                                                            orderTop: '8px solid rgba(0, 0, 0, 0.75)',
                                                        }} />
                                                    </div>
                                            </foreignObject>
                                        )}
                                    </svg>
                                </div>
                            </div>
                        </main>

                        <button onClick={() => setSidebarOpen(!isSidebarOpen)} className={`absolute top-16 z-20 bg-indigo-600 hover:bg-indigo-700 text-white w-6 h-12 flex items-center justify-center rounded-r-lg cursor-pointer transition-all duration-300 ease-in-out focus:outline-none ${isSidebarOpen ? 'left-80' : '-left-0'}`} aria-label={isSidebarOpen ? "サイドバーを閉じる" : "サイドバーを開く"}>
                            {isSidebarOpen ? '?' : '?'}
                        </button>

                        <aside ref={sidebarRef} className={`absolute top-0 left-0 h-full w-80 bg-gray-50 p-4 space-y-4 z-10 transform transition-transform duration-300 ease-in-out ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`} style={{overflowY: 'auto'}}>
                            <div ref={displaySettingsRef}>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDisplaySettingsOpen(!isDisplaySettingsOpen)}>
                                    <span>表示設定</span>
                                    <span className={`arrow-icon text-gray-400 ${isDisplaySettingsOpen ? 'arrow-icon-open' : 'arrow-icon-closed'}`}>▼</span>
                                </h2>
                                <div className={`accordion-content ${isDisplaySettingsOpen ? 'accordion-content-open' : ''}`}>
                                    <div className="space-y-4">
                                        <div>
                                            <button 
                                                onClick={() => setUploadModalOpen(true)}
                                                className="cursor-pointer block w-full text-sm text-center text-blue-700 bg-blue-50 hover:bg-blue-100 font-semibold py-2 px-4 rounded-full"
                                            >
                                                下絵をアップロード
                                            </button>
                                        </div>
                                        {imageUrl && (
                                            <>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">下絵のサイズ: {Math.round(imageScale * 100)}%</label>
                                                    <div className="flex items-center space-x-2 mt-1">
                                                        <input type="range" min="10" max="300" step="1" value={imageScale * 100} onChange={(e) => setImageScale(parseFloat(e.target.value) / 100)} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        <input type="number" value={Math.round(imageScale * 100)} onChange={(e) => setImageScale(parseInt(e.target.value) / 100 || 0.1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                    </div>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">下絵の透明度: {Math.round(imageOpacity * 100)}%</label>
                                                    <div className="flex items-center space-x-2 mt-1">
                                                        <input type="range" min="0" max="1" step="0.05" value={imageOpacity} onChange={(e) => setImageOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        <input type="number" value={Math.round(imageOpacity * 100)} onChange={(e) => setImageOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                    </div>
                                                </div>
                                            </>
                                        )}
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">レイヤーの透明度: {Math.round(drawingOpacity * 100)}%</label>
                                            <div className="flex items-center space-x-2 mt-1">
                                                <input type="range" min="0" max="1" step="0.05" value={drawingOpacity} onChange={(e) => setDrawingOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                <input type="number" value={Math.round(drawingOpacity * 100)} onChange={(e) => setDrawingOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                            </div>
                                        </div>
                                        <div className="flex items-center">
                                            <input id="grid-toggle" type="checkbox" checked={isGridVisible} onChange={() => setGridVisible(!isGridVisible)} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                            <label htmlFor="grid-toggle" className="ml-2 block text-sm font-medium text-gray-700">グリッド線を表示</label>
                                        </div>
                                        {isGridVisible && (
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">グリッドサイズ: {gridSize}px</label>
                                                <div className="flex items-center space-x-2 mt-1">
                                                    <input type="range" min="1" max="30" step="1" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                    <input type="number" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                            <hr/>
                            <div>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDrawingToolsOpen(!isDrawingToolsOpen)}>
                                    <span>図形描画</span>
                                    <span className={`arrow-icon text-gray-400 ${isDrawingToolsOpen ? 'arrow-icon-open' : 'arrow-icon-closed'}`}>▼</span>
                                </h2>
                                <div className={`accordion-content ${isDrawingToolsOpen ? 'accordion-content-open' : ''}`}>
                                    <div>
                                        <div className="flex bg-gray-200 rounded-lg p-1 mb-4">
                                            <button onClick={() => setEditorMode('continuous-create')} className={`w-full py-1 rounded-md text-sm ${editorMode === 'continuous-create' ? 'bg-white shadow' : ''}`}>連続作成</button>
                                            <button onClick={() => setEditorMode('create')} className={`w-full py-1 rounded-md text-sm ${editorMode === 'create' ? 'bg-white shadow' : ''}`}>作成</button>
                                            <button onClick={() => setEditorMode('edit')} className={`w-full py-1 rounded-md text-sm ${editorMode === 'edit' ? 'bg-white shadow' : ''}`}>編集</button>
                                        </div>

                                        {(editorMode === 'create' || editorMode === 'continuous-create') && (
                                            <>
                                                <div className="grid grid-cols-4 gap-2">
                                                    {['space', 'door', 'window', 'wall', 'fixture', 'stairs', 'compass', 'text'].map(mode => {
                                                        const names = {'space':'空間', 'door':'ドア', 'window':'窓', 'wall':'壁', 'fixture':'設備', 'stairs':'階段', 'compass':'方角', 'text':'文字'};
                                                        return <button key={mode} onClick={() => setDrawingMode(mode)} className={`px-2 py-2 rounded text-sm ${drawingMode === mode ? 'bg-indigo-600 text-white' : 'bg-gray-200'}`}>{names[mode]}</button>
                                                    })}
                                                </div>
                                                {drawingMode === 'space' && (
                                                    <div className="mt-4 space-y-4">
                                                        {/* 四角形/線の切り替えボタンは、空間タイプの上で問題なし */}
                                                        <div className="flex bg-gray-200 rounded-lg p-1">
                                                            <button onClick={() => setSpaceShape('rect')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'rect' ? 'bg-white shadow' : ''}`}>四角形</button>
                                                            <button onClick={() => setSpaceShape('line')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'line' ? 'bg-white shadow' : ''}`}>線</button>
                                                        </div>

                                                        {/* 1. 空間タイプ */}
                                                        <SpaceTypeSelector selectedType={spaceType} onChange={setSpaceType} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />

                                                        {/* 2. 背景 */}
                                                        <BackgroundSelector selected={backgroundPattern} onChange={setBackgroundPattern} />

                                                        {/* 3. 塗りつぶしの色 */}
                                                        <div> {/* 「塗りつぶしの色」全体のコンテナ */}
                                                            <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                            <div className="flex items-center justify-between mt-1">
                                                                <div className="flex items-center">
                                                                    <input id="transparent-toggle" type="checkbox" checked={fillColor === 'none'} onChange={(e) => {
                                                                        if (e.target.checked) {
                                                                            setLastFillColor(fillColor);
                                                                            setFillColor('none');
                                                                        } else {
                                                                            setFillColor(lastFillColor);
                                                                        }
                                                                    }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                                                    <label htmlFor="transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                </div>
                                                            </div>
                                                            <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${fillColor === 'none' ? 'transparent-bg' : ''}`}>
                                                                <input type="color" value={fillColor === 'none' ? '#ffffff' : fillColor} onChange={(e) => setFillColor(e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className={`h-full w-full ${fillColor === 'none' ? 'opacity-0' : ''}`} disabled={fillColor === 'none'}/>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* 線のプロパティグループ (線の種類、太さ、色) */}
                                                        {/* 編集モードではここに <h3 className="text-md font-semibold mb-2">壁のプロパティ</h3> があるが、作成モードでは不要であれば削除 */}
                                                        <div className="mt-4 pt-4 border-t border-gray-300">
                                                            {/* 4. 線の種類 */}
                                                            <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} isRectShape={spaceShape === 'rect'}/>
                                                            {/* 5. 線の太さ */}
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                                <div className="flex items-center space-x-2 mt-1">
                                                                    <input type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                    <input type="number" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                                </div>
                                                            </div>
                                                            {/* 6. 線の色 */}
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>

                                                    </div>
                                                )}
                                                {drawingMode === 'wall' && (
                                                    <div className="mt-4 space-y-4">
                                                        <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'stairs' && (
                                                    <div className="mt-4 space-y-4">
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">階段幅: {stairWidth}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="100" step="1" value={stairWidth} onChange={(e) => setStairWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={stairWidth} onChange={(e) => setStairWidth(parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">方向</label>
                                                           <div className="flex bg-gray-200 rounded-lg p-1 mt-1">
                                                                <button onClick={() => setStairDirection('up')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'up' ? 'bg-white shadow' : ''}`}>UP</button>
                                                                <button onClick={() => setStairDirection('down')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'down' ? 'bg-white shadow' : ''}`}>DN</button>
                                                                <button onClick={() => setStairDirection('none')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'none' ? 'bg-white shadow' : ''}`}>非表示</button>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'door' && <div className="mt-4 space-y-4">
                                                    <DoorTemplateSelector selectedTemplateId={doorTemplateId} onChange={setDoorTemplateId} />
                                                    <div className="flex items-center p-2 bg-gray-100 rounded-md">
                                                        <input 
                                                            id="door-snap-toggle" 
                                                            type="checkbox" 
                                                            checked={isSnapToWall} 
                                                            onChange={() => setSnapToWall(!isSnapToWall)}
                                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                        />
                                                        <label htmlFor="door-snap-toggle" className="ml-2 block text-sm font-medium text-gray-700">壁の上に描画する</label>
                                                    </div>
                                                    {!isSnapToWall && (
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">ドアの厚み: {wallObjectThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range" min="1" max="30" step="1"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value))}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value) || 1)}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>}
                                                {drawingMode === 'window' && <div className="mt-4 space-y-4">
                                                    <WindowTemplateSelector selectedTemplateId={windowTemplateId} onChange={setWindowTemplateId} />
                                                    <div className="flex items-center p-2 bg-gray-100 rounded-md">
                                                        <input 
                                                            id="window-snap-toggle" 
                                                            type="checkbox" 
                                                            checked={isSnapToWall} 
                                                            onChange={() => setSnapToWall(!isSnapToWall)}
                                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                        />
                                                        <label htmlFor="window-snap-toggle" className="ml-2 block text-sm font-medium text-gray-700">壁の上に描画する</label>
                                                    </div>
                                                    {!isSnapToWall && (
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">窓の厚み: {wallObjectThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range" min="1" max="30" step="1"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value))}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value) || 1)}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>}
                                                {drawingMode === 'fixture' && <div className="mt-4 space-y-4">
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700">カテゴリ</label>
                                                        <div className="mt-2 grid grid-cols-4 gap-2">
                                                            {FIXTURE_CATEGORIES.map(cat => (
                                                                <button
                                                                    key={cat.key}
                                                                    onClick={() => setFixtureCategory(cat.key)}
                                                                    className={`px-2 py-2 rounded text-[11px] text-center ${fixtureCategory === cat.key ? 'bg-indigo-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}
                                                                >
                                                                    {cat.name}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    <FixtureTemplateSelector
                                                        selectedTemplateId={fixtureTemplateId}
                                                        onChange={setFixtureTemplateId}
                                                        category={fixtureCategory}
                                                        mode="create"
                                                        isFlipped={fixtureFlip}
                                                        onFlipChange={setFixtureFlip}
                                                    />
                                                    {/* サイズ調整 */}
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700">サイズ: {fixtureSize}px</label>
                                                        <div className="flex items-center space-x-2 mt-1">
                                                            <input
                                                                type="range"
                                                                min="5"
                                                                max="300"
                                                                step="1"
                                                                value={fixtureSize}
                                                                onChange={(e) => setFixtureSize(parseInt(e.target.value))}
                                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                            />
                                                            <input
                                                                type="number"
                                                                value={fixtureSize}
                                                                onChange={(e) => setFixtureSize(parseInt(e.target.value) || 5)}
                                                                className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                            />
                                                        </div>
                                                    </div>

                                                    {/* 回転調整 */}
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700">回転: {fixtureRotation}°</label>
                                                        <div className="flex items-center space-x-2 mt-1">
                                                            <input
                                                                type="range"
                                                                min="-180"
                                                                max="180"
                                                                step="1"
                                                                value={fixtureRotation}
                                                                onChange={(e) => setFixtureRotation(parseInt(e.target.value))}
                                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                            />
                                                            <input
                                                                type="number"
                                                                value={fixtureRotation}
                                                                onChange={(e) => setFixtureRotation(parseInt(e.target.value) || 0)}
                                                                className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                            />
                                                            <button
                                                                onClick={() => setFixtureRotation(prev => {
                                                                let newAngle = prev + 90;
                                                                if (newAngle > 180) {
                                                                    newAngle -= 360;
                                                                }
                                                                return newAngle;
                                                            })}
                                                                className="p-1 bg-gray-200 rounded hover:bg-gray-300 flex-shrink-0" // 少しスタイルを調整
                                                                title="90度回転"
                                                            >
                                                                <img 
                                                                    src="https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/90.jpg" 
                                                                    alt="90度回転" 
                                                                    className="h-9 w-9" // アイコンサイズを少し調整
                                                                />
                                                            </button>
                                                        </div>
                                                    </div>
                                                    {/* プレビューボックス */}
                                                    <div className="w-full h-32 rounded-md flex items-center justify-center overflow-hidden relative">
                                                        {(() => {
                                                            const template = FIXTURE_TEMPLATES[fixtureCategory]?.find(t => t.id === fixtureTemplateId);
                                                            if (!template) return <div className="text-sm text-gray-500">設備を選択</div>;

                                                            // 1. 実際の描画サイズを計算 (既存のロジック)
                                                            const baseSize = BASE_FIXTURE_DEFAULT_SIZE;
                                                            const templateDefaultSize = template.defaultSize || baseSize;
                                                            const scaleRatio = baseSize / templateDefaultSize;
                                                            const actualWidth = fixtureSize * scaleRatio;
                                                            const aspectRatio = template.aspectRatio || 1;
                                                            const actualHeight = actualWidth / aspectRatio;

                                                            // 2. プレビューボックスに収まるように表示用の拡大率を計算
                                                            const boxSize = 128; // h-32 = 8rem = 128px
                                                            const paddingRatio = 0.8; // ボックスの80%の大きさで表示
                                                            const itemMaxDim = Math.max(actualWidth, actualHeight);
                                                            
                                                            // 0除算を避ける
                                                            if (itemMaxDim === 0) return null;

                                                            const displayScale = (boxSize * paddingRatio) / itemMaxDim;
                                                            const displayWidth = actualWidth * displayScale;
                                                            const displayHeight = actualHeight * displayScale;

                                                            // 3. 背景グリッドのサイズも表示スケールに合わせて調整
                                                            const backgroundGridSize = gridSize * displayScale;
                                                            const gridStyle = {
                                                                backgroundImage: `linear-gradient(to right, #e5e7eb 1px, transparent 1px), linear-gradient(to bottom, #e5e7eb 1px, transparent 1px)`,
                                                                backgroundSize: `${backgroundGridSize}px ${backgroundGridSize}px`
                                                            };
                                                            
                                                            // プレビューボックスの親divにスタイルを適用
                                                            const parentDiv = document.querySelector('.w-full.h-32.rounded-md');
                                                            if (parentDiv) {
                                                                Object.assign(parentDiv.style, gridStyle);
                                                            }
                                                            
                                                            if (template.src) {
                                                                return (
                                                                    <div style={{ 
                                                                        transform: `rotate(${fixtureRotation}deg)`, 
                                                                        width: displayWidth, 
                                                                        height: displayHeight,
                                                                        display: 'flex',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center'
                                                                    }}>
                                                                        <img src={template.src} style={{ width: '100%', height: '100%' }} />
                                                                    </div>
                                                                );
                                                            } else {
                                                                const viewBoxSize = Math.max(template.defaultSize, template.defaultSize / (template.aspectRatio || 1)) * 1.1;
                                                                return (
                                                                    <svg
                                                                        width={displayWidth}
                                                                        height={displayHeight}
                                                                        viewBox={`${-viewBoxSize/2} ${-viewBoxSize/2} ${viewBoxSize} ${viewBoxSize}`}
                                                                        style={{ transform: `rotate(${fixtureRotation}deg)`, overflow: 'visible' }}
                                                                    >
                                                                        <g transform={`scale(${displayWidth / template.defaultSize}, ${displayHeight / template.defaultSize})`}>
                                                                            <path
                                                                                d={template.path}
                                                                                fill={template.defaultFill}
                                                                                stroke={template.defaultStroke}
                                                                                strokeWidth={template.defaultStrokeWidth}
                                                                                vectorEffect="non-scaling-stroke"
                                                                            />
                                                                        </g>
                                                                    </svg>
                                                                );
                                                            }
                                                        })()}
                                                    </div>
                                                    {/* プレビューボックス ここまで*/}
                                                </div>}
                                                {drawingMode === 'compass' && <div className="mt-4 space-y-4">
                                                    <CompassTemplateSelector selectedTemplateId={compassTemplateId} onChange={setCompassTemplateId} />
                                                </div>}
                                                {drawingMode === 'text' && <div className="mt-4 space-y-4">
                                                    <p className="text-sm text-gray-600">キャンバスをクリックしてテキストを配置します。</p>
                                                </div>}
                                            </>
                                        )}
                                        
                                        {editorMode === 'edit' && (
                                            <div className="mt-4 space-y-4">
                                                {!selectedElement && <p className="text-sm text-gray-600">編集したいアイテムをクリックしてください。</p>}
                                                {selectedElement?.type === 'space' && (() => {
                                                    const firstWall = svgElements.find(el => el.groupId === selectedElement.id && el.type === 'wall');
                                                    // firstWallが存在しない（空間が壊れている）場合の表示部分
                                                    if (!firstWall) { // Space might be broken, just show basic options
                                                        return (
                                                            <>
                                                                <SpaceTypeSelector selectedType={selectedElement.spaceType} onChange={(newType) => handleSelectedGroupUpdate({ spaceType: newType })} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />
                                                                <BackgroundSelector selected={selectedElement.backgroundPattern || 'none'} onChange={(pattern) => handleSelectedElementUpdate({ backgroundPattern: pattern })} />
                                                                {/* ここから修正 */}
                                                                <div> {/* 「塗りつぶしの色」全体のコンテナ */}
                                                                    {/* labelと透明チェックボックスを横並びにするdiv */}
                                                                    <div className="flex items-center justify-between">
                                                                        <label htmlFor="edit-fill-color-picker" className="block text-sm font-medium text-gray-700">塗りつぶしの色</label> {/* タイトルを変更 */}
                                                                        <div className="flex items-center"> {/* 透明トグルとそのラベル */}
                                                                            <input id="edit-transparent-toggle" type="checkbox" checked={selectedElement.fill === 'none'} onChange={(e) => {
                                                                                if (e.target.checked) {
                                                                                    setEditLastFillColor(selectedElement.fill);
                                                                                    handleSelectedElementUpdate({ fill: 'none' });
                                                                                } else {
                                                                                    handleSelectedElementUpdate({ fill: editLastFillColor });
                                                                                }
                                                                            }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                                                            <label htmlFor="edit-transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                        </div>
                                                                    </div>
                                                                    <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${selectedElement.fill === 'none' ? 'transparent-bg' : ''}`}>
                                                                        <input 
                                                                            type="color" 
                                                                            value={selectedElement.fill === 'none' ? '#ffffff' : selectedElement.fill} 
                                                                            onChange={(e) => handleSelectedElementUpdate({ fill: e.target.value })} 
                                                                            onFocus={() => setIsPickingColor(true)}  // ? この行を追加
                                                                            onBlur={() => setIsPickingColor(false)}   // ? この行を追加
                                                                            className={`h-full w-full ${selectedElement.fill === 'none' ? 'opacity-0' : ''}`} 
                                                                            disabled={selectedElement.fill === 'none'}
                                                                        />
                                                                    </div>
                                                                </div>
                                                                {/* ここまで修正 */}
                                                                <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この空間を削除</button></div>
                                                            </>
                                                        );
                                                    }

                                                    // firstWallが存在する（通常の空間）場合の表示部分
                                                    return (
                                                        <>
                                                            <SpaceTypeSelector selectedType={selectedElement.spaceType} onChange={(newType) => handleSelectedGroupUpdate({ spaceType: newType })} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />
                                                            <BackgroundSelector selected={selectedElement.backgroundPattern || 'none'} onChange={(pattern) => handleSelectedElementUpdate({ backgroundPattern: pattern })} />
                                                            {/* ここから修正 */}
                                                            <div> {/* 「塗りつぶしの色」全体のコンテナ */}
                                                                {/* labelと透明チェックボックスを横並びにするdiv */}
                                                                <div className="flex items-center justify-between">
                                                                    <label htmlFor="edit-fill-color-picker" className="block text-sm font-medium text-gray-700">塗りつぶしの色</label> {/* タイトルを変更 */}
                                                                    <div className="flex items-center"> {/* 透明トグルとそのラベル */}
                                                                        <input id="edit-transparent-toggle" type="checkbox" checked={selectedElement.fill === 'none'} onChange={(e) => {
                                                                            if (e.target.checked) {
                                                                                setEditLastFillColor(selectedElement.fill);
                                                                                handleSelectedElementUpdate({ fill: 'none' });
                                                                            } else {
                                                                                handleSelectedElementUpdate({ fill: editLastFillColor });
                                                                            }
                                                                        }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                                                        <label htmlFor="edit-transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                    </div>
                                                                </div>
                                                                <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${selectedElement.fill === 'none' ? 'transparent-bg' : ''}`}>
                                                                    <input type="color" value={selectedElement.fill === 'none' ? '#ffffff' : selectedElement.fill} onChange={(e) => handleSelectedElementUpdate({ fill: e.target.value })} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className={`h-full w-full ${selectedElement.fill === 'none' ? 'opacity-0' : ''}`} disabled={selectedElement.fill === 'none'}/>
                                                                </div>
                                                            </div>
                                                            {/* ここまで修正 */}
                                                            <div className="mt-4 pt-4 border-t border-gray-300">
                                                                <h3 className="text-md font-semibold mb-2">壁のプロパティ</h3>
                                                                <LineStyleSelector selectedStyle={firstWall.lineStyle} onChange={(v) => handleSelectedWallsUpdate('lineStyle', v)} />
                                                                <div>
                                                                    <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                                    <div className="flex items-center space-x-2 mt-1">
                                                                        <input type="range" min="1" max="20" step="1" value={firstWall.strokeWidth} onChange={(e) => handleSelectedWallsUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                        <input type="number" value={firstWall.strokeWidth} onChange={(e) => handleSelectedWallsUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                                    </div>
                                                                </div>
                                                                <div>
                                                                    <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                    <input type="color" value={firstWall.color} onChange={(e) => handleSelectedWallsUpdate('color', e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                                </div>
                                                            </div>

                                                            <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この空間を削除</button></div>
                                                        </>
                                                    );
                                                })()}
                                                {selectedElement?.type === 'wall' && (
                                                    <>
                                                        <LineStyleSelector selectedStyle={selectedElement.lineStyle} onChange={(v) => handleSelectedElementUpdate({lineStyle: v})} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate({strokeWidth: parseInt(e.target.value)})} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate({strokeWidth: parseInt(e.target.value) || 1})} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate({color: e.target.value})} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                        </div>
                                                        <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この壁を削除</button></div>
                                                    </>
                                                )}
                                                {selectedElement?.type === 'stairs' && (
                                                    <>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">階段幅: {selectedElement.width}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="100" step="1" value={selectedElement.width} onChange={(e) => handleSelectedElementUpdate({width: parseInt(e.target.value)})} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.width} onChange={(e) => handleSelectedElementUpdate({width: parseInt(e.target.value) || 20})} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">方向</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1 mt-1">
                                                                <button onClick={() => handleStairDirectionChange('up')} className="w-full py-1 rounded-md text-sm">UP</button>
                                                                <button onClick={() => handleStairDirectionChange('down')} className="w-full py-1 rounded-md text-sm">DN</button>
                                                                <button onClick={() => handleStairDirectionChange('none')} className="w-full py-1 rounded-md text-sm">非表示</button>
                                                            </div>
                                                        </div>
                                                        <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この階段を削除</button></div>
                                                    </>
                                                )}
                                                {selectedElement?.type === 'door' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中のドアを編集</h3>
                                                        
                                                        <DoorTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                        />

                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">ドアの厚み: {selectedElement.wallThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range" min="1" max="30" step="1"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) || 1 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input
                                                                type="color"
                                                                value={selectedElement.color}
                                                                onChange={(e) => handleSelectedElementUpdate({ color: e.target.value })}
                                                                onFocus={() => setIsPickingColor(true)}
                                                                onBlur={() => setIsPickingColor(false)}
                                                                className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                            />
                                                        </div>

                                                        <div className="flex space-x-2">
                                                            <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button>
                                                            <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button>
                                                        </div>

                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このドアを削除</button>
                                                        </div>
                                                    </div>
                                                )}

                                                {selectedElement?.type === 'window' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中の窓を編集</h3>
                                                        
                                                        <WindowTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                        />

                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">窓の厚み: {selectedElement.wallThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="1"
                                                                    max="30"
                                                                    step="1"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) || 1 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input
                                                                type="color"
                                                                value={selectedElement.color}
                                                                onChange={(e) => handleSelectedElementUpdate({ color: e.target.value })}
                                                                onFocus={() => setIsPickingColor(true)}
                                                                onBlur={() => setIsPickingColor(false)}
                                                                className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                            />
                                                        </div>

                                                        <div className="flex space-x-2">
                                                            <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button>
                                                            <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button>
                                                        </div>

                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この窓を削除</button>
                                                        </div>
                                                    </div>
                                                )}

                                                {selectedElement?.type === 'fixture' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中の設備を編集</h3>

                                                        {/* カテゴリ */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">カテゴリ</label>
                                                            <div className="mt-2 grid grid-cols-4 gap-2">
                                                                {FIXTURE_CATEGORIES.map(cat => (
                                                                    <button
                                                                        key={cat.key}
                                                                        onClick={() => setFixtureCategory(cat.key)}
                                                                        className={`px-2 py-2 rounded text-[11px] text-center ${fixtureCategory === cat.key ? 'bg-indigo-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}
                                                                    >
                                                                        {cat.name}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        </div>

                                                        {/* 設備の種類 */}
                                                        <FixtureTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                            category={fixtureCategory}
                                                            mode="edit"
                                                            isFlipped={selectedElement.isFlipped || false}
                                                            onFlipChange={(isChecked) => handleSelectedElementUpdate({ isFlipped: isChecked })}
                                                        />

                                                        {/* サイズ */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">サイズ (幅): {Math.round(selectedElement.width)}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="10"
                                                                    max="300"
                                                                    step="1"
                                                                    value={selectedElement.width}
                                                                    onChange={(e) => {
                                                                        const newWidth = parseInt(e.target.value);
                                                                        const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === selectedElement.templateId))] || {};
                                                                        const template = templateCategory.find(t => t.id === selectedElement.templateId);
                                                                        const aspectRatio = template?.aspectRatio || 1;
                                                                        const newHeight = newWidth / aspectRatio;
                                                                        handleSelectedElementUpdate({ width: newWidth, height: newHeight });
                                                                    }}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.width)}
                                                                    onChange={(e) => {
                                                                        const newWidth = parseInt(e.target.value) || 10;
                                                                        const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === selectedElement.templateId))] || {};
                                                                        const template = templateCategory.find(t => t.id === selectedElement.templateId);
                                                                        const aspectRatio = template?.aspectRatio || 1;
                                                                        const newHeight = newWidth / aspectRatio;
                                                                        handleSelectedElementUpdate({ width: newWidth, height: newHeight });
                                                                    }}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>

                                                        {/* 回転 */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">回転: {selectedElement.rotation || 0}°</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-180"
                                                                    max="180"
                                                                    step="1"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                                <button
                                                                    onClick={rotateSelectedElement90Degrees}
                                                                    className="p-1 bg-gray-200 rounded hover:bg-gray-300 flex-shrink-0"
                                                                    title="90度回転"
                                                                >
                                                                    <img
                                                                        src="https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/90.jpg"
                                                                        alt="90度回転"
                                                                        className="h-9 w-9"
                                                                    />
                                                                </button>
                                                            </div>
                                                        </div>

                                                        {/* プレビューボックス */}
                                                        <div className="w-full h-32 rounded-md flex items-center justify-center overflow-hidden relative">
                                                            {(() => {
                                                                const template = FIXTURE_TEMPLATES[fixtureCategory]?.find(t => t.id === selectedElement.templateId);
                                                                if (!template) return <div className="text-sm text-gray-500">設備を選択</div>;

                                                                const actualWidth = selectedElement.width;
                                                                const actualHeight = selectedElement.height;

                                                                const boxSize = 128;
                                                                const paddingRatio = 0.8;
                                                                const itemMaxDim = Math.max(actualWidth, actualHeight);
                                                                
                                                                if (itemMaxDim === 0) return null;

                                                                const displayScale = (boxSize * paddingRatio) / itemMaxDim;
                                                                const displayWidth = actualWidth * displayScale;
                                                                const displayHeight = actualHeight * displayScale;

                                                                const backgroundGridSize = gridSize * displayScale;
                                                                const gridStyle = {
                                                                    backgroundImage: `linear-gradient(to right, #e5e7eb 1px, transparent 1px), linear-gradient(to bottom, #e5e7eb 1px, transparent 1px)`,
                                                                    backgroundSize: `${backgroundGridSize}px ${backgroundGridSize}px`
                                                                };
                                                                
                                                                const parentDiv = document.querySelector('.w-full.h-32.rounded-md');
                                                                if (parentDiv) {
                                                                    Object.assign(parentDiv.style, gridStyle);
                                                                }

                                                                if (template.src) {
                                                                    return (
                                                                        <div style={{
                                                                            transform: `rotate(${selectedElement.rotation || 0}deg)`,
                                                                            width: displayWidth,
                                                                            height: displayHeight,
                                                                            display: 'flex',
                                                                            alignItems: 'center',
                                                                            justifyContent: 'center'
                                                                        }}>
                                                                            <img src={template.src} style={{ width: '100%', height: '100%' }} />
                                                                        </div>
                                                                    );
                                                                } else {
                                                                    const viewBoxSize = Math.max(template.defaultSize, template.defaultSize / (template.aspectRatio || 1)) * 1.1;
                                                                    return (
                                                                        <svg
                                                                            width={displayWidth}
                                                                            height={displayHeight}
                                                                            viewBox={`${-viewBoxSize / 2} ${-viewBoxSize / 2} ${viewBoxSize} ${viewBoxSize}`}
                                                                            style={{ transform: `rotate(${selectedElement.rotation || 0}deg)`, overflow: 'visible' }}
                                                                        >
                                                                            <g transform={`scale(${displayWidth / template.defaultSize}, ${displayHeight / template.defaultSize})`}>
                                                                                <path
                                                                                    d={template.path}
                                                                                    fill={template.defaultFill}
                                                                                    stroke={template.defaultStroke}
                                                                                    strokeWidth={template.defaultStrokeWidth}
                                                                                    vectorEffect="non-scaling-stroke"
                                                                                />
                                                                            </g>
                                                                        </svg>
                                                                    );
                                                                }
                                                            })()}
                                                        </div>

                                                        {/* 削除ボタン */}
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この設備を削除</button>
                                                        </div>
                                                    </div>
                                                )}

                                                {selectedElement?.type === 'compass' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中の方角を編集</h3>
                                                        
                                                        <CompassTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                        />
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">サイズ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="20"
                                                                    max="300"
                                                                    step="1"
                                                                    value={selectedElement.size}
                                                                    onChange={(e) => handleSelectedElementUpdate({ size: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.size}
                                                                    onChange={(e) => handleSelectedElementUpdate({ size: parseInt(e.target.value) || 20 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">回転</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-180"
                                                                    max="180"
                                                                    step="1"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.rotation || 0)}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この方角を削除</button>
                                                        </div>
                                                    </div>
                                                )}
                                                
                                                {selectedElement?.type === 'text' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中のテキストを編集</h3>

                                                        {/* テキスト入力 */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">テキスト</label>
                                                            <textarea
                                                                ref={textEditAreaRef}
                                                                value={selectedElement.text}
                                                                onChange={(e) => handleSelectedElementUpdate({ text: e.target.value })}
                                                                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                                                rows="3"
                                                            ></textarea>
                                                        </div>

                                                        {/* フォント */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">フォント</label>
                                                            <select
                                                                value={selectedElement.fontFamily}
                                                                onChange={(e) => handleSelectedElementUpdate({ fontFamily: e.target.value })}
                                                                className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                                                            >
                                                                {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)}
                                                            </select>
                                                        </div>

                                                        {/* フォントサイズ */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">フォントサイズ: {selectedElement.fontSize}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="8"
                                                                    max="72"
                                                                    step="1"
                                                                    value={selectedElement.fontSize}
                                                                    onChange={(e) => handleSelectedElementUpdate({ fontSize: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.fontSize}
                                                                    onChange={(e) => handleSelectedElementUpdate({ fontSize: parseInt(e.target.value) || 8 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>

                                                        {/* 回転 */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">回転</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-180"
                                                                    max="180"
                                                                    step="1"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.rotation || 0)}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>

                                                        {/* 色の設定 */}
                                                        <div className="grid grid-cols-1 gap-y-4">
                                                            {/* 塗りつぶしの色 */}
                                                            <div>
                                                                <div className="flex items-center justify-between">
                                                                    <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                    <div className="flex items-center">
                                                                        <input
                                                                            id="text-bg-transparent-toggle"
                                                                            type="checkbox"
                                                                            checked={selectedElement.backgroundColor === 'none' || !selectedElement.backgroundColor}
                                                                            onChange={(e) => {
                                                                                const newBgColor = e.target.checked ? 'none' : '#ffffff';
                                                                                handleSelectedElementUpdate({ backgroundColor: newBgColor });
                                                                            }}
                                                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                                        />
                                                                        <label htmlFor="text-bg-transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                    </div>
                                                                </div>
                                                                <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${(!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none') ? 'transparent-bg' : ''}`}>
                                                                    <input
                                                                        type="color"
                                                                        value={!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none' ? '#ffffff' : selectedElement.backgroundColor}
                                                                        onChange={(e) => handleSelectedElementUpdate({ backgroundColor: e.target.value })}
                                                                        onFocus={() => setIsPickingColor(true)}
                                                                        onBlur={() => setIsPickingColor(false)}
                                                                        className={`h-full w-full rounded-md ${(!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none') ? 'opacity-0' : ''}`}
                                                                        disabled={!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none'}
                                                                    />
                                                                </div>
                                                            </div>
                                                            {/* 文字色 */}
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">文字色</label>
                                                                <input
                                                                    type="color"
                                                                    value={selectedElement.color}
                                                                    onChange={(e) => handleSelectedElementUpdate({ color: e.target.value })}
                                                                    onFocus={() => setIsPickingColor(true)}
                                                                    onBlur={() => setIsPickingColor(false)}
                                                                    className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                                />
                                                            </div>
                                                        </div>

                                                        {/* 配置 */}
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">配置</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1">
                                                                <button onClick={() => handleSelectedElementUpdate({ textAlign: 'left' })} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button>
                                                                <button onClick={() => handleSelectedElementUpdate({ textAlign: 'center' })} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button>
                                                                <button onClick={() => handleSelectedElementUpdate({ textAlign: 'right' })} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button>
                                                            </div>
                                                        </div>

                                                        {/* 削除ボタン */}
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このテキストを削除</button>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </aside>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<Editor />, document.getElementById('root'));
    </script>
</body>
</html>
