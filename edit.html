<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>間取り図エディタ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
        }
        .editor-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        .scroll-wrapper {
            width: 5000px;
            height: 5000px;
            position: relative;
        }
        .editor-container {
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            transform-origin: center center;
        }
        .editor-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            max-width: 100%;
            max-height: 100%;
            pointer-events: none;
        }
        .editor-canvas, .editor-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .editor-svg {
            pointer-events: all;
        }
        .editor-svg > * {
            pointer-events: all;
        }
        .cursor-crosshair { cursor: crosshair; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-default { cursor: default; }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.4L159.2%2C69.7c-3.1-3.1-8.2-3.1-11.3%2C0L5.4%2C197.4c-3.1%2C3.1-3.1%2C8.2%2C0%2C11.3l11.3%2C11.3c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l115.4-115.4l115.4%2C115.4c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l11.3-11.3C290.1%2C205.6%2C290.1%2C200.5%2C287%2C197.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem 0.8rem;
            padding-right: 2.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
        }
        select:focus {
            border-color: #6366F1;
            box-shadow: 0 0 0 1px #6366F1;
            outline: none;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- 定数とダミーデータ ---
        const DUMMY_OCR_DATA = {
            "Blocks": [
                { "id": "block-1", "type": "LDK", "Text": "LDK 12.5帖", "Geometry": { "BoundingBox": { "Width": 0.25, "Height": 0.05, "Left": 0.4, "Top": 0.5 }}},
                { "id": "block-2", "type": "洋室", "Text": "洋室 6.0帖", "Geometry": { "BoundingBox": { "Width": 0.2, "Height": 0.05, "Left": 0.1, "Top": 0.2 }}},
                { "id": "block-3", "type": "浴室", "Text": "浴室", "Geometry": { "BoundingBox": { "Width": 0.1, "Height": 0.04, "Left": 0.7, "Top": 0.2 }}},
                { "id": "block-4", "type": "収納", "Text": "WIC", "Geometry": { "BoundingBox": { "Width": 0.08, "Height": 0.04, "Left": 0.15, "Top": 0.4 }}}
            ]
        };
        const ROOM_TYPES = ["LDK", "洋室", "和室", "浴室", "トイレ", "洗面所", "収納", "玄関", "その他"];
        const SPACE_TYPES = ["LDK", "DK", "K", "居室", "和室", "収納", "洗面所", "浴室", "トイレ", "玄関", "バルコニー", "柱", "その他"];
        const FONT_FAMILIES = [
            { id: 'sans-serif', name: 'ゴシック体' },
            { id: 'serif', name: '明朝体' },
            { id: 'monospace', name: '等幅フォント' },
            { id: 'cursive', name: '筆記体' }
        ];
        const SNAP_THRESHOLD = 10;
        const DEFAULT_WIDTH = 1200;
        const DEFAULT_HEIGHT = 900;
        const SELECTED_ELEMENT_COLOR = '#3b82f6';
        const DEFAULT_STROKE_COLOR = '#000000';
        const DEFAULT_STROKE_WIDTH = 3;

        const LINE_STYLES = [
            { id: 'solid', name: '実線', dashArray: 'none' },
            { id: 'dashed', name: '破線', dashArray: '10, 5' },
            { id: 'dotted', name: '点線', dashArray: '2, 5' },
            { id: 'chain', name: '一点鎖線', dashArray: '10, 4, 2, 4' },
            { id: 'double-chain', name: '二点鎖線', dashArray: '10, 4, 2, 4, 2, 4' },
            { id: 'wavy', name: '波線', dashArray: null }
        ];

        const DEFAULT_FILL_COLORS = {
            "LDK": "#fef3c7", "DK": "#fef3c7", "K": "#fef3c7",
            "居室": "#f5e5d4",
            "和室": "#dcfce7",
            "収納": "#fef9c3",
            "洗面所": "#dbeafe",
            "浴室": "#dbeafe",
            "トイレ": "#dbeafe",
            "玄関": "#dedede",
            "バルコニー": "#f5f5f5",
            "柱": "#000000",
            "その他": "#fafafa"
        };

        const COMPASS_TEMPLATES = [
            { id: 'dsynbol01', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol01.svg'},
            { id: 'dsynbol02', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol02.svg'},
            { id: 'dsynbol03', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol03.svg'},
            { id: 'dsynbol04', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol04.svg'},
            { id: 'dsynbol05', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol05.svg'},
            { id: 'dsynbol06', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol06.svg'},
            { id: 'dsynbol07', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol07.svg'},
            { id: 'dsynbol08', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol08.svg'},
            { id: 'dsynbol09', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol09.svg'},
            { id: 'dsynbol10', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol10.svg'},
            { id: 'dsynbol11', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol11.svg'}
        ];

        const FIXTURE_TEMPLATES = {
            kitchen: [
                { id: 'kitchen-sink', name: 'シンク', path: 'M-20,-10 H20 V10 H-20 Z M-10,-10 V10 M0,-10 V10', defaultSize: 40, defaultFill: '#cccccc', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'refrigerator', name: '冷蔵庫', path: 'M-10,-20 H10 V20 H-10 Z M-10,0 H10', defaultSize: 40, defaultFill: '#e0e0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'gas-range', name: 'ガスコンロ', path: 'M-15,-15 H15 V15 H-15 Z M-10,-10 L10,10 M-10,10 L10,-10', defaultSize: 35, defaultFill: '#f0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'microwave', name: '電子レンジ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-5 H10 M-10,0 H10', defaultSize: 30, defaultFill: '#f5f5f5', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dishwasher', name: '食洗機', path: 'M-15,-10 H15 V10 H-15 Z M-10,0 V10 M0,0 V10 M10,0 V10', defaultSize: 30, defaultFill: '#e0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'pantry', name: '食器棚', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20 M-10,-10 H10 M-10,0 H10 M-10,10 H10', defaultSize: 45, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bathroom: [
                { id: 'bathtub', name: '浴槽', path: 'M-20,-10 H20 V10 H-20 Z M-15,-5 H15 V5 H-15 Z', defaultSize: 40, defaultFill: '#e0f0ff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'washbasin', name: '洗面台', path: 'M-10,-10 H10 V10 H-10 Z M-5,0 A5,5 0 1,0 5,0', defaultSize: 30, defaultFill: '#ffffff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'washing-machine', name: '洗濯機', path: 'M-15,-15 H15 V15 H-15 Z M0,-15 V15 M-10,-5 H10', defaultSize: 35, defaultFill: '#f0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'shower', name: 'シャワー', path: 'M-15,-15 H15 V15 H-15 Z M-10,-10 L10,10 M-10,10 L10,-10', defaultSize: 30, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bidet', name: 'ビデ', path: 'M-10,-10 H10 V10 H-10 Z M-10,-5 A5,5 0 0,1 -5,-10 H5 A5,5 0 0,1 10,-5', defaultSize: 25, defaultFill: '#ffffff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'towel-rack', name: 'タオル掛け', path: 'M-15,-5 H15 M-10,5 H10', defaultSize: 25, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bedroom: [
                { id: 'bed-single', name: 'シングルベッド', path: 'M-20,-15 H20 V15 H-20 Z M-15,-15 H15 V-5 H-15 Z', defaultSize: 50, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bed-double', name: 'ダブルベッド', path: 'M-30,-20 H30 V20 H-30 Z M-25,-20 H25 V-5 H-25 Z', defaultSize: 60, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'closet', name: 'クローゼット', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20', defaultSize: 40, defaultFill: '#f5deb3', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dresser', name: 'ドレッサー', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'nightstand', name: 'ナイトスタンド', path: 'M-10,-10 H10 V10 H-10 Z', defaultSize: 20, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'wardrobe', name: 'ワードローブ', path: 'M-20,-25 H20 V25 H-20 Z M-15,-25 V25 M15,-25 V25', defaultSize: 50, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            livingDining: [
                { id: 'dining-table-round', name: '円形テーブル', path: 'M0,0 A15,15 0 1,0 0,0.001 Z', defaultSize: 40, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dining-table-rect', name: '長方形テーブル', path: 'M-25,-15 H25 V15 H-25 Z', defaultSize: 50, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-single', name: '一人掛けソファ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 V0 M10,-10 V0', defaultSize: 40, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-double', name: '二人掛けソファ', path: 'M-30,-10 H30 V10 H-30 Z M-25,-10 V0 M25,-10 V0', defaultSize: 60, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'tv-stand', name: 'テレビ台', path: 'M-20,-5 H20 V5 H-20 Z', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bookshelf', name: '本棚', path: 'M-15,-20 H15 V20 H-15 Z M-10,-15 H10 M-10,0 H10 M-10,15 H10', defaultSize: 45, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            other: [
                { id: 'desk', name: 'デスク', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 45, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'stairs', name: '階段', path: 'M-20,-20 H20 V20 H-20 Z M-20,-10 H20 M-20,0 H20 M-20,10 H20', defaultSize: 50, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'fireplace', name: '暖炉', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 L-10,0 L10,0 L10,-10', defaultSize: 30, defaultFill: '#a0a0a0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'piano', name: 'ピアノ', path: 'M-25,-10 H25 V10 H-25 Z M-20,-10 V0 M-15,-10 V0 M-10,-10 V0 M-5,-10 V0 M0,-10 V0 M5,-10 V0 M10,-10 V0 M15,-10 V0 M20,-10 V0', defaultSize: 50, defaultFill: '#303030', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ]
        };

        const DOOR_TEMPLATES = [
            { id: 'swing-right', name: '開き戸 (右)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const sweepFlag = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 M0,0 L0,${isInner ? doorThickness : -doorThickness} M0,0 A${length},${length} 0 0,${sweepFlag} ${length},${isInner ? length : -length}`;
                },
                previewPath: 'M0,0 L40,0 M0,0 L0,10 M0,0 A40,40 0 0,1 40,40'
            },
            { id: 'swing-left', name: '開き戸 (左)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const sweepFlag = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 M${length},0 L${length},${isInner ? doorThickness : -doorThickness} M${length},0 A${length},${length} 0 0,${sweepFlag} 0,${isInner ? length : -length}`;
                },
                previewPath: 'M0,0 L40,0 M40,0 L40,10 M40,0 A40,40 0 0,0 0,40'
            },
            { id: 'sliding-single', name: '引き戸 (片)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorOffset = (wallThickness || 10) / 2;
                    return `M0,0 L${length},0 M0,${doorOffset} L${length},${doorOffset}`;
                },
                previewPath: 'M0,0 L40,0 M0,5 L40,5'
            },
            { id: 'double-swing', name: '両開き戸',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const halfLength = length / 2;
                    const doorThickness = wallThickness || 10;
                    const sweepFlag1 = swingDirection === 'clockwise' ? 1 : 0;
                    const sweepFlag2 = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 ` +
                           `M0,0 L0,${isInner ? doorThickness : -doorThickness} ` +
                           `M${halfLength},0 L${halfLength},${isInner ? doorThickness : -doorThickness} ` +
                           `M0,0 A${halfLength},${halfLength} 0 0,${sweepFlag1} ${halfLength},${isInner ? halfLength : -halfLength} ` +
                           `M${length},0 A${halfLength},${halfLength} 0 0,${sweepFlag2} ${halfLength},${isInner ? halfLength : -halfLength}`;
                },
                previewPath: 'M20,0 L0,0 M20,0 L40,0 M0,0 A20,20 0 0,1 20,20 M40,0 A20,20 0 0,0 20,20'
            },
            { id: 'parent-child-door', name: '親子ドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const parentLength = length * 0.7;
                    const childLength = length * 0.3;
                    const sweepFlagParent = swingDirection === 'clockwise' ? 1 : 0;
                    const sweepFlagChild = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 ` +
                           `M0,0 L0,${isInner ? doorThickness : -doorThickness} ` +
                           `M${parentLength},0 L${parentLength},${isInner ? doorThickness : -doorThickness} ` +
                           `M0,0 A${parentLength},${parentLength} 0 0,${sweepFlagParent} ${parentLength},${isInner ? parentLength : -parentLength} ` +
                           `M${parentLength},0 A${childLength},${childLength} 0 0,${sweepFlagChild} ${length},${isInner ? childLength : -childLength}`;
                },
                previewPath: 'M0,0 L40,0 M0,0 L0,10 M28,0 L28,10 M0,0 A28,28 0 0,1 28,28 M28,0 A12,12 0 0,1 40,12'
            },
            { id: 'bifold', name: '折れ戸',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const segmentLength = length / 4;
                    const offset = isInner ? doorThickness : -doorThickness;
                    return `M0,0 L${length},0 ` +
                           `M0,${offset} L${segmentLength},0 ` +
                           `M${segmentLength},0 L${segmentLength * 2},${offset} ` +
                           `M${segmentLength * 2},${offset} L${segmentLength * 3},0 ` +
                           `M${segmentLength * 3},0 L${length},${offset}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L10,0 M10,0 L20,10 M20,10 L30,0 M30,0 L40,10'
            }
        ];

        const WINDOW_TEMPLATES = [
            { id: 'sliding-window', name: '引き違い窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    const offset = windowThickness / 2;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,${offset} L${length},${offset}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,5 L40,5'
            },
            { id: 'casement-single', name: '片開き窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    const arcSweep = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,0 L0,${windowThickness} M${length},0 A${windowThickness},${windowThickness} 0 0,${arcSweep} ${length - windowThickness},0`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,0 L0,10 M40,0 A10,10 0 0,1 30,0'
            },
            { id: 'casement-double', name: '両開き窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const halfLength = length / 2;
                    const windowThickness = wallThickness || 10;
                    const arcSweep1 = swingDirection === 'clockwise' ? 1 : 0;
                    const arcSweep2 = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M${halfLength},0 L${halfLength},${windowThickness} M0,0 A${windowThickness},${windowThickness} 0 0,${arcSweep1} ${windowThickness},0 M${length},0 A${windowThickness},${windowThickness} 0 0,${arcSweep2} ${length-windowThickness},0`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M20,0 L20,10 M0,0 A10,10 0 0,1 10,0 M40,0 A10,10 0 0,0 30,0'
            },
            { id: 'fixed-window', name: 'FIX窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,0 L0,${windowThickness} M${length},0 L${length},${windowThickness} M0,0 L${length},${windowThickness} M${length},0 L0,${windowThickness}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,0 L0,10 M40,0 L40,10 M0,0 L40,10 M40,0 L0,10'
            }
        ];


        // --- ヘルパー関数 ---
        const generateWavyPathD = (p1, p2) => {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 1) return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
            const dirX = dx / len, dirY = dy / len, perpX = -dirY, perpY = dirX;
            const amplitude = 4, wavelength = 15;
            const numSegments = Math.max(1, Math.floor(len / wavelength));
            const segmentLen = len / numSegments;
            let d = `M ${p1.x} ${p1.y}`;
            for (let i = 0; i < numSegments; i++) {
                const midX = p1.x + (i + 0.5) * segmentLen * dirX;
                const midY = p1.y + (i + 0.5) * segmentLen * dirY;
                const segEndX = p1.x + (i + 1) * segmentLen * dirX;
                const segEndY = p1.y + (i + 1) * segmentLen * dirY;
                const amp = (i % 2 === 0) ? amplitude : -amplitude;
                const controlX = midX + amp * perpX;
                const controlY = midY + amp * perpY;
                d += ` Q ${controlX} ${controlY} ${segEndX} ${segEndY}`;
            }
            return d;
        };

        const getPolygonCentroid = (pts) => {
            let first = pts[0], last = pts[pts.length - 1];
            if (first.x !== last.x || first.y !== last.y) pts.push(first);
            let twicearea = 0, x = 0, y = 0, nPts = pts.length, p1, p2, f;
            for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
                p1 = pts[i]; p2 = pts[j];
                f = p1.x * p2.y - p2.x * p1.y;
                twicearea += f;
                x += (p1.x + p2.x) * f;
                y += (p1.y + p2.y) * f;
            }
            f = twicearea * 3;
            if (Math.abs(f) < 1e-6) { // Avoid division by zero for degenerate polygons
                return pts.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
            }
            return { x: x / f, y: y / f };
        };

        const createSpaceLabel = (spaceType, centroid, dimensions) => {
            const text = ["LDK", "DK", "K", "居室", "和室"].includes(spaceType)
                ? `${spaceType}\n◯.◯帖`
                : spaceType;

            return {
                id: `text-${Date.now()}`,
                type: 'text',
                x: (centroid.x / dimensions.width) * 100,
                y: (centroid.y / dimensions.height) * 100,
                text: text,
                color: '#000000',
                fontSize: 16,
                fontFamily: 'sans-serif',
                textAlign: 'center',
            };
        };

        // --- UIコンポーネント ---
        const LineStyleSelector = ({ selectedStyle, onChange, isRectShape }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">線の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-1">
                    {LINE_STYLES.map(style => (
                        (isRectShape && style.id === 'wavy') ? null : (
                            <button key={style.id} onClick={() => onChange(style.id)} className={`p-2 rounded-md border-2 ${selectedStyle === style.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                                <div className="flex items-center justify-center">
                                    <svg width="40" height="20" viewBox="0 0 60 20" className="flex-shrink-0">
                                        {style.id === 'wavy' ? <path d="M 5 10 C 15 0, 25 20, 35 10 S 55 0, 55 10" stroke="black" strokeWidth="2" fill="none" /> : <line x1="5" y1="10" x2="55" y2="10" stroke="black" strokeWidth="2" strokeDasharray={style.dashArray} strokeLinecap="round" />}
                                    </svg>
                                </div>
                            </button>
                        )
                    ))}
                </div>
            </div>
        );

        const CompassTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">方角の図形</label>
                <div className="mt-2 grid grid-cols-4 gap-1">
                    {COMPASS_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center h-12`}
                        >
                           <img
                                src={template.src}
                                alt={template.id}
                                className="w-8 h-8 object-contain"
                            />
                        </button>
                    ))}
                </div>
            </div>
        );

        const FixtureTemplateSelector = ({ selectedTemplateId, onChange, category }) => {
            const templates = FIXTURE_TEMPLATES[category] || [];
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700">設備の種類</label>
                    <div className="mt-2 grid grid-cols-4 gap-1">
                        {templates.map(template => (
                            <button key={template.id} onClick={() => onChange(template.id)} className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center`}>
                                <svg width="40" height="40" viewBox="-30 -30 60 60" className="flex-shrink-0">
                                    <path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} />
                                </svg>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const DoorTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">ドアの種類</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                    {DOOR_TEMPLATES.map(template => (
                        <button key={template.id} onClick={() => onChange(template.id)} className={`p-2 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center space-x-2">
                                <svg width="60" height="40" viewBox="0 0 60 40" className="flex-shrink-0">
                                    <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" />
                                </svg>
                                <span className="text-sm">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        const WindowTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">窓の種類</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                    {WINDOW_TEMPLATES.map(template => (
                        <button key={template.id} onClick={() => onChange(template.id)} className={`p-2 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center space-x-2">
                                <svg width="60" height="40" viewBox="0 0 60 40" className="flex-shrink-0">
                                    <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" />
                                </svg>
                                <span className="text-sm">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        // --- メインエディタコンポーネント ---
        function Editor() {
            // --- ステート定義 ---
            const [isSidebarOpen, setSidebarOpen] = useState(true);
            const [isDisplaySettingsOpen, setDisplaySettingsOpen] = useState(true);
            const [isDrawingToolsOpen, setDrawingToolsOpen] = useState(true);
            const [imageUrl, setImageUrl] = useState('');
            const [historyState, setHistoryState] = useState({
                past: [],
                present: { ocrData: null, svgElements: [] },
                future: []
            });
            const { ocrData: currentOcrData, svgElements } = historyState.present;

            const [selectedBlockId, setSelectedBlockId] = useState(null);
            const [drawingMode, setDrawingMode] = useState('space');
            const [spaceEditMode, setSpaceEditMode] = useState('create');
            const [spaceShape, setSpaceShape] = useState('rect');
            const [selectedElementId, setSelectedElementId] = useState(null);
            const [dimensions, setDimensions] = useState({ width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT });
            const [drawingStartPoint, setDrawingStartPoint] = useState(null);
            const [linePoints, setLinePoints] = useState([]);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [snapValue, setSnapValue] = useState(10);
            const [endpointSnap, setEndpointSnap] = useState(null);
            const [imageOpacity, setImageOpacity] = useState(0.5);
            const [drawingOpacity, setDrawingOpacity] = useState(0.4);
            const [zoom, setZoom] = useState(0.8);
            const [imageScale, setImageScale] = useState(1);
            const [strokeWidth, setStrokeWidth] = useState(DEFAULT_STROKE_WIDTH);
            const [strokeColor, setStrokeColor] = useState(DEFAULT_STROKE_COLOR);
            const [spaceType, setSpaceType] = useState('LDK');
            const [fillColor, setFillColor] = useState(DEFAULT_FILL_COLORS[spaceType]);
            const [lineStyle, setLineStyle] = useState('solid');
            const [isGridVisible, setGridVisible] = useState(true);
            const [gridSize, setGridSize] = useState(10);
            const [fontSize, setFontSize] = useState(16);
            const [fontFamily, setFontFamily] = useState('sans-serif');
            const [textAlign, setTextAlign] = useState('center'); // ★★★ デフォルトを中央揃えに変更 ★★★
            const [compassTemplateId, setCompassTemplateId] = useState(COMPASS_TEMPLATES[0].id);
            const [fixtureCategory, setFixtureCategory] = useState('kitchen');
            const [fixtureTemplateId, setFixtureTemplateId] = useState(FIXTURE_TEMPLATES.kitchen[0].id);
            const [doorTemplateId, setDoorTemplateId] = useState(DOOR_TEMPLATES[0].id);
            const [windowTemplateId, setWindowTemplateId] = useState(WINDOW_TEMPLATES[0].id);
            
            const [isDragging, setIsDragging] = useState(false);

            // --- Ref定義 ---
            const imageRef = useRef(null);
            const canvasRef = useRef(null);
            const editorAreaRef = useRef(null);
            const svgRef = useRef(null);
            const displaySettingsRef = useRef(null);
            const dragInfo = useRef(null);
            const historyOnActionStart = useRef(null);
            const mouseDownInfo = useRef(null);

            const selectedElement = selectedElementId ? svgElements.find(el => el.id === selectedElementId) : null;

            const handleSelectedElementUpdate = useCallback((key, value) => {
                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.id === selectedElementId) {
                            const newEl = { ...el, [key]: value };
                            if (key === 'spaceType') {
                                newEl.fill = DEFAULT_FILL_COLORS[value] || '#ffffff';
                            }
                            return newEl;
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedElementId]);

            const handleFileChange = async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImageUrl(e.target.result);
                        const newOcrData = DUMMY_OCR_DATA;
                        setHistoryState(prevState => ({
                            past: [...prevState.past, prevState.present],
                            present: { ocrData: newOcrData, svgElements: prevState.present.svgElements },
                            future: []
                        }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const getCanvasCoords = useCallback((event) => {
                const editorArea = editorAreaRef.current;
                const svg = svgRef.current;
                if (!editorArea || !svg) return { x: 0, y: 0 };
                const svgRect = svg.getBoundingClientRect();
                const x = (event.clientX - svgRect.left) / zoom;
                const y = (event.clientY - svgRect.top) / zoom;
                return { x, y };
            }, [zoom]);

            const getGridSnappedPoint = useCallback((point) => {
                return {
                    x: Math.round(point.x / gridSize) * gridSize,
                    y: Math.round(point.y / gridSize) * gridSize
                };
            }, [gridSize]);

            const getAngleSnappedPoint = useCallback((start, current) => {
                const dx = current.x - start.x;
                const dy = current.y - start.y;
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                const snappedAngle = Math.round(angle / snapValue) * snapValue;
                const length = Math.sqrt(dx * dx + dy * dy);
                const newDx = length * Math.cos(snappedAngle * Math.PI / 180);
                const newDy = length * Math.sin(snappedAngle * Math.PI / 180);
                return { x: start.x + newDx, y: start.y + newDy };
            }, [snapValue]);

            const handleCanvasClick = useCallback((e) => {
                const clickPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);
                const isSpaceCreateMode = drawingMode === 'space' && spaceEditMode === 'create';
                const isSpaceEditMode = drawingMode === 'space' && spaceEditMode === 'edit';

                if (isSpaceCreateMode && spaceShape === 'line') {
                    const snappedClickPos = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                    if (linePoints.length > 1) {
                        const firstPoint = linePoints[0];
                        const dist = Math.sqrt((snappedClickPos.x - firstPoint.x)**2 + (snappedClickPos.y - firstPoint.y)**2);
                        if (dist < SNAP_THRESHOLD / zoom) {
                            const newElements = [];
                            for (let i = 0; i < linePoints.length; i++) {
                                const p1 = linePoints[i];
                                const p2 = linePoints[(i + 1) % linePoints.length];
                                newElements.push({ id: `space-line-${Date.now()}-${i}`, type: 'space', shape: 'line', spaceType: spaceType, x1: (p1.x / dimensions.width) * 100, y1: (p1.y / dimensions.height) * 100, x2: (p2.x / dimensions.width) * 100, y2: (p2.y / dimensions.height) * 100, strokeWidth: strokeWidth, color: strokeColor, lineStyle: lineStyle });
                            }
                            const polygonPoints = linePoints.map(p => `${p.x},${p.y}`).join(' ');
                            const fillElement = { id: `space-fill-${Date.now()}`, type: 'space', shape: 'polygon', spaceType: spaceType, points: polygonPoints, fill: fillColor };
                            newElements.push(fillElement);
                            const centroid = getPolygonCentroid(linePoints);
                            const labelElement = createSpaceLabel(spaceType, centroid, dimensions);
                            newElements.push(labelElement);
                            setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                            setLinePoints([]);
                            return;
                        }
                    }
                    setLinePoints(prev => [...prev, snappedClickPos]);
                    return;
                }
                
                if (drawingStartPoint) {
                    const newElements = [];
                    let finalEndPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                    if (drawingMode === 'space' && spaceShape === 'rect') {
                        const rectElement = { id: `space-rect-${Date.now()}`, type: 'space', shape: 'rect', spaceType: spaceType, x: (Math.min(drawingStartPoint.x, finalEndPoint.x) / dimensions.width) * 100, y: (Math.min(drawingStartPoint.y, finalEndPoint.y) / dimensions.height) * 100, width: (Math.abs(drawingStartPoint.x - finalEndPoint.x) / dimensions.width) * 100, height: (Math.abs(drawingStartPoint.y - finalEndPoint.y) / dimensions.height) * 100, fill: fillColor, color: strokeColor, strokeWidth: strokeWidth, lineStyle: 'solid' };
                        newElements.push(rectElement);
                        const centroid = { x: Math.min(drawingStartPoint.x, finalEndPoint.x) + Math.abs(drawingStartPoint.x - finalEndPoint.x) / 2, y: Math.min(drawingStartPoint.y, finalEndPoint.y) + Math.abs(drawingStartPoint.y - finalEndPoint.y) / 2 };
                        newElements.push(createSpaceLabel(spaceType, centroid, dimensions));
                    } else if (drawingMode === 'compass') {
                        finalEndPoint = clickPos;
                        const dx = finalEndPoint.x - drawingStartPoint.x;
                        const dy = finalEndPoint.y - drawingStartPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const size = Math.min(300, Math.max(20, distance));
                        const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                        newElements.push({ id: `compass-${Date.now()}`, type: 'compass', x: (drawingStartPoint.x / dimensions.width) * 100, y: (drawingStartPoint.y / dimensions.height) * 100, size: size, rotation: rotation, templateId: compassTemplateId });
                    } else if (drawingMode === 'door' || drawingMode === 'window') {
                        const dx = finalEndPoint.x - drawingStartPoint.x;
                        const dy = finalEndPoint.y - drawingStartPoint.y;
                        const length = Math.sqrt(dx*dx + dy*dy);
                        const baseAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        newElements.push({ id: `${drawingMode}-${Date.now()}`, type: drawingMode, templateId: drawingMode === 'door' ? doorTemplateId : windowTemplateId, x1: (drawingStartPoint.x / dimensions.width) * 100, y1: (drawingStartPoint.y / dimensions.height) * 100, x2: (finalEndPoint.x / dimensions.width) * 100, y2: (finalEndPoint.y / dimensions.height) * 100, length: length, baseAngle: baseAngle, rotation: 0, isInner: true, swingDirection: 'clockwise', wallThickness: 10, color: DEFAULT_STROKE_COLOR, strokeWidth: DEFAULT_STROKE_WIDTH });
                    }
                    if (newElements.length > 0) {
                        setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                        setSelectedElementId(newElements[0].id);
                    }
                    setDrawingStartPoint(null);
                    return;
                }

                if (targetElement && !isSpaceCreateMode) {
                    setSelectedElementId(targetId);
                    return;
                }

                if (!isSpaceEditMode) {
                    const snappedStartPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                    if (drawingMode === 'text' || drawingMode === 'fixture') {
                        const newElement = drawingMode === 'text' ? { id: `text-${Date.now()}`, type: 'text', x: (snappedStartPoint.x / dimensions.width) * 100, y: (snappedStartPoint.y / dimensions.height) * 100, text: "テキスト", color: strokeColor, fontSize: fontSize, fontFamily: fontFamily, textAlign: textAlign } : { id: `fixture-${Date.now()}`, type: 'fixture', x: (snappedStartPoint.x / dimensions.width) * 100, y: (snappedStartPoint.y / dimensions.height) * 100, templateId: fixtureTemplateId, size: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultSize, fill: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultFill, stroke: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultStroke, strokeWidth: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultStrokeWidth, };
                        setHistoryState(prevState => ({ past: [...prevState.past, prevState.present], present: { ...prevState.present, svgElements: [...prevState.present.svgElements, newElement] }, future: [] }));
                        setSelectedElementId(newElement.id);
                    } else if (! (drawingMode === 'space' && spaceShape === 'line')) {
                        setDrawingStartPoint(snappedStartPoint);
                        setSelectedElementId(null);
                    }
                } else {
                    setSelectedElementId(null);
                }
            }, [getCanvasCoords, svgElements, drawingMode, spaceShape, drawingStartPoint, linePoints, isGridVisible, getGridSnappedPoint, dimensions, strokeColor, fontSize, fontFamily, textAlign, fixtureTemplateId, fixtureCategory, spaceType, fillColor, strokeWidth, lineStyle, compassTemplateId, doorTemplateId, windowTemplateId, zoom, spaceEditMode]);

            const handleMouseDown = useCallback((e) => {
                setDisplaySettingsOpen(false);
                e.stopPropagation();
                mouseDownInfo.current = { x: e.clientX, y: e.clientY };
                const startPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);
                const isSpaceCreateMode = drawingMode === 'space' && spaceEditMode === 'create';

                if (targetElement && !isSpaceCreateMode) {
                    setIsDragging(true);
                    setSelectedElementId(targetId);
                    historyOnActionStart.current = historyState.present;
                    dragInfo.current = { startMouseX: startPos.x, startMouseY: startPos.y, element: targetElement, initialX: targetElement.x !== undefined ? targetElement.x / 100 * dimensions.width : null, initialY: targetElement.y !== undefined ? targetElement.y / 100 * dimensions.height : null, initialX1: targetElement.x1 !== undefined ? targetElement.x1 / 100 * dimensions.width : null, initialY1: targetElement.y1 !== undefined ? targetElement.y1 / 100 * dimensions.height : null, initialX2: targetElement.x2 !== undefined ? targetElement.x2 / 100 * dimensions.width : null, initialY2: targetElement.y2 !== undefined ? targetElement.y2 / 100 * dimensions.height : null, };
                } else {
                    setSelectedElementId(null);
                    if (!(isSpaceCreateMode && spaceShape === 'line')) {
                        setLinePoints([]);
                    }
                }
            }, [getCanvasCoords, svgElements, historyState.present, dimensions, drawingMode, spaceEditMode, spaceShape]);

            const handleMouseMove = useCallback((e) => {
                const currentPos = getCanvasCoords(e);
                setMousePos(currentPos);

                if (isDragging && dragInfo.current) {
                    const dx = currentPos.x - dragInfo.current.startMouseX;
                    const dy = currentPos.y - dragInfo.current.startMouseY;

                    const newElements = historyOnActionStart.current.svgElements.map(el => {
                        if (el.id === selectedElementId) {
                            const newEl = { ...el };
                            if (el.type === 'space' && el.shape === 'rect' || ['fixture', 'text', 'compass'].includes(el.type)) {
                                let newPixelX = dragInfo.current.initialX + dx;
                                let newPixelY = dragInfo.current.initialY + dy;
                                if (isGridVisible) {
                                    const snapped = getGridSnappedPoint({ x: newPixelX, y: newPixelY });
                                    newPixelX = snapped.x;
                                    newPixelY = snapped.y;
                                }
                                newEl.x = (newPixelX / dimensions.width) * 100;
                                newEl.y = (newPixelY / dimensions.height) * 100;
                            } else if (el.type === 'space' && el.shape === 'line' || ['door', 'window'].includes(el.type)) {
                                let newX1 = dragInfo.current.initialX1 + dx;
                                let newY1 = dragInfo.current.initialY1 + dy;
                                let newX2 = dragInfo.current.initialX2 + dx;
                                let newY2 = dragInfo.current.initialY2 + dy;
                                if (isGridVisible) {
                                    const snapped1 = getGridSnappedPoint({ x: newX1, y: newY1 });
                                    const snapped2 = getGridSnappedPoint({ x: newX2, y: newY2 });
                                    newX1 = snapped1.x; newY1 = snapped1.y;
                                    newX2 = snapped2.x; newY2 = snapped2.y;
                                }
                                newEl.x1 = (newX1 / dimensions.width) * 100;
                                newEl.y1 = (newY1 / dimensions.height) * 100;
                                newEl.x2 = (newX2 / dimensions.width) * 100;
                                newEl.y2 = (newY2 / dimensions.height) * 100;
                                
                                if (el.type === 'door' || el.type === 'window') {
                                    const newDx = newX2 - newX1;
                                    const newDy = newY2 - newY1;
                                    newEl.length = Math.sqrt(newDx * newDx + newDy * newDy);
                                    newEl.baseAngle = Math.atan2(newDy, newDx) * 180 / Math.PI;
                                }
                            }
                            return newEl;
                        }
                        return el;
                    });
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                }
                
                if (!isDragging && !isGridVisible) {
                    let snappedToEndpoint = null;
                    const pointsToCheck = [...svgElements.filter(el => el.type === 'space' && el.shape === 'line').flatMap(el => [{x: el.x1, y: el.y1}, {x: el.x2, y: el.y2}]), ...linePoints].map(p => ({x: p.x / 100 * dimensions.width, y: p.y / 100 * dimensions.height}));
                    for (const p of pointsToCheck) {
                        const dist = Math.sqrt(Math.pow(currentPos.x - p.x, 2) + Math.pow(currentPos.y - p.y, 2));
                        if (dist < SNAP_THRESHOLD / zoom) {
                            snappedToEndpoint = p;
                            break;
                        }
                    }
                    setEndpointSnap(snappedToEndpoint);
                }
            }, [isDragging, getCanvasCoords, selectedElementId, isGridVisible, getGridSnappedPoint, dimensions, zoom, SNAP_THRESHOLD, svgElements, linePoints]);

            const handleMouseUp = useCallback((e) => {
                const wasDragging = isDragging;
                if (isDragging) {
                    if (dragInfo.current && JSON.stringify(historyOnActionStart.current.svgElements) !== JSON.stringify(svgElements)) {
                        setHistoryState(prev => ({ ...prev, past: [...prev.past, historyOnActionStart.current], future: [] }));
                    }
                }
                const wasClick = mouseDownInfo.current && (Math.sqrt((e.clientX - mouseDownInfo.current.x)**2 + (e.clientY - mouseDownInfo.current.y)**2) < 5);
                if (wasClick && !wasDragging) {
                    handleCanvasClick(e);
                }
                setIsDragging(false);
                dragInfo.current = null;
                historyOnActionStart.current = null;
                mouseDownInfo.current = null;
            }, [isDragging, svgElements, handleCanvasClick]);

            const deleteSelectedElement = useCallback(() => {
                if (!selectedElementId) return;
                setHistoryState(prevState => {
                    const newSvgElements = prevState.present.svgElements.filter(el => el.id !== selectedElementId);
                    const finalSvgElements = newSvgElements.filter(el => !(el.type === 'fill' && selectedElement && el.spaceType === selectedElement.spaceType));
                    return { past: [...prevState.past, prevState.present], present: { ...prevState.present, svgElements: finalSvgElements }, future: [] };
                });
                setSelectedElementId(null);
            }, [selectedElementId, selectedElement]);

            const handleUndo = useCallback(() => {
                setHistoryState(prevState => {
                    const past = [...prevState.past];
                    const newPresent = past.pop();
                    if (!newPresent) return prevState;
                    return { past: past, present: newPresent, future: [prevState.present, ...prevState.future] };
                });
            }, []);

            const handleRedo = useCallback(() => {
                setHistoryState(prevState => {
                    const future = [...prevState.future];
                    const newPresent = future.shift();
                    if (!newPresent) return prevState;
                    return { past: [...prevState.past, prevState.present], present: newPresent, future: future };
                });
            }, []);

            const rotateSelectedElement90Degrees = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window' || selectedElement.type === 'compass')) {
                    const newRotation = ((selectedElement.rotation || 0) + 90) % 360;
                    handleSelectedElementUpdate('rotation', newRotation);
                }
            }, [selectedElement, handleSelectedElementUpdate]);

            const toggleSelectedElementSwingDirection = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window')) {
                    const newIsInner = !selectedElement.isInner;
                    setHistoryState(prevState => {
                        const updatedElements = prevState.present.svgElements.map(el => {
                            if (el.id === selectedElementId) { return { ...el, isInner: newIsInner }; }
                            return el;
                        });
                        return { past: [...prevState.past, prevState.present], present: { ...prevState.present, svgElements: updatedElements }, future: [] };
                    });
                }
            }, [selectedElement, selectedElementId]);

            const handleSaveImage = () => {
                const storedId = selectedElementId;
                setSelectedElementId(null);

                setTimeout(() => {
                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = dimensions.width;
                    exportCanvas.height = dimensions.height;
                    const ctx = exportCanvas.getContext('2d');
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
                    
                    const svgClone = svgRef.current.cloneNode(true);
                    svgClone.style.opacity = 1;
                    const svgString = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                    const url = URL.createObjectURL(svgBlob);
                    const svgImage = new Image();

                    svgImage.onload = () => {
                        ctx.drawImage(svgImage, 0, 0);
                        URL.revokeObjectURL(url);
                        const link = document.createElement('a');
                        const today = new Date();
                        const yyyy = today.getFullYear();
                        const mm = String(today.getMonth() + 1).padStart(2, '0');
                        const dd = String(today.getDate()).padStart(2, '0');
                        link.download = `floorplan_${yyyy}${mm}${dd}.png`;
                        link.href = exportCanvas.toDataURL('image/png');
                        link.click();
                        setSelectedElementId(storedId);
                    };
                    svgImage.src = url;
                }, 0);
            };

            useEffect(() => {
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [handleMouseMove, handleMouseUp]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (endpointSnap && !isGridVisible) {
                    ctx.beginPath();
                    ctx.arc(endpointSnap.x, endpointSnap.y, SNAP_THRESHOLD / zoom, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.fill();
                }
            }, [endpointSnap, zoom, isGridVisible]);

            useEffect(() => {
                if (editorAreaRef.current) {
                    const area = editorAreaRef.current;
                    const timer = setTimeout(() => {
                        area.scrollTop = (area.scrollHeight - area.clientHeight) / 2;
                        const scrollLeftCenter = (area.scrollWidth - area.clientWidth) / 2;
                        const sidebarWidth = 320;
                        const newScrollLeft = isSidebarOpen ? scrollLeftCenter - (sidebarWidth / 2) : scrollLeftCenter;
                        area.scrollLeft = newScrollLeft;
                    }, 0);
                    return () => clearTimeout(timer);
                }
            }, [imageUrl, isSidebarOpen]);

            useEffect(() => {
                setFillColor(DEFAULT_FILL_COLORS[spaceType] || '#ffffff');
            }, [spaceType]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); handleUndo(); }
                    else if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); handleRedo(); }
                    else if (e.key === 'Delete' && selectedElementId) { e.preventDefault(); deleteSelectedElement(); }
                    else if (e.key === 'Escape') {
                        setDrawingStartPoint(null);
                        setLinePoints([]);
                        setSelectedElementId(null);
                        setSelectedBlockId(null);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleUndo, handleRedo, deleteSelectedElement, selectedElementId]);

            useEffect(() => {
                const editorArea = editorAreaRef.current;
                if (!editorArea) return;
                const handleWheel = (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        setZoom(prevZoom => Math.max(0.2, Math.min(3, prevZoom + delta)));
                    }
                };
                editorArea.addEventListener('wheel', handleWheel, { passive: false });
                return () => editorArea.removeEventListener('wheel', handleWheel);
            }, []);

            useEffect(() => {
                setDrawingStartPoint(null);
                setLinePoints([]);
                setSelectedElementId(null);
                setSelectedBlockId(null);
            }, [drawingMode, spaceEditMode, spaceShape]);

            useEffect(() => {
                if (!isDisplaySettingsOpen) return;
                function handleClickOutside(event) {
                    if (isSidebarOpen && displaySettingsRef.current && !displaySettingsRef.current.contains(event.target) && !editorAreaRef.current.contains(event.target)) {
                        setDisplaySettingsOpen(false);
                    }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [isDisplaySettingsOpen, isSidebarOpen]);

            const getCursorClass = () => {
                if (isDragging) return 'cursor-grabbing';
                if (drawingMode !== 'select' && spaceEditMode !== 'edit') return 'cursor-crosshair';
                return 'cursor-default';
            };

            return (
                <div className="flex flex-col h-screen">
                    <header className="bg-white shadow-md p-2 flex items-center justify-between z-30 flex-shrink-0">
                        <span className="text-xl font-bold text-gray-800 ml-4">間取り図エディタ</span>
                        <div className="flex items-center space-x-4">
                            <button onClick={handleSaveImage} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">PNGで保存</button>
                            <button onClick={handleUndo} disabled={historyState.past.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">戻る</button>
                            <button onClick={handleRedo} disabled={historyState.future.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">進む</button>
                            <div className="flex items-center space-x-2">
                                <button onClick={() => setZoom(z => Math.max(0.2, z - 0.1))} className="px-3 py-1 bg-gray-200 rounded">-</button>
                                <span>{Math.round(zoom * 100)}%</span>
                                <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="px-3 py-1 bg-gray-200 rounded">+</button>
                            </div>
                        </div>
                    </header>

                    <div className="flex-1 relative overflow-hidden">
                        <main ref={editorAreaRef} className="editor-area w-full h-full bg-gray-200">
                            <div className="scroll-wrapper">
                                <div className="editor-container" style={{ width: dimensions.width, height: dimensions.height, transform: `translate(-50%, -50%) scale(${zoom})`, ...(isGridVisible && { backgroundImage: `linear-gradient(to right, #f3f4f6 1px, transparent 1px), linear-gradient(to bottom, #f3f4f6 1px, transparent 1px)`, backgroundSize: `${gridSize}px ${gridSize}px` }) }}>
                                    {imageUrl && <img ref={imageRef} src={imageUrl} alt="間取り図" className="editor-image" style={{ opacity: 1 - imageOpacity, transform: `translate(-50%, -50%) scale(${imageScale})` }} crossOrigin="anonymous"/>}
                                    <canvas ref={canvasRef} className={getCursorClass()} width={dimensions.width} height={dimensions.height} />
                                    <svg ref={svgRef} className="editor-svg" width={dimensions.width} height={dimensions.height} xmlns="http://www.w3.org/2000/svg" style={{ opacity: 1 - drawingOpacity }} onMouseDown={handleMouseDown}>
                                        {svgElements.map(el => {
                                            const isSelected = el.id === selectedElementId;
                                            const stroke = isSelected ? SELECTED_ELEMENT_COLOR : (el.color || DEFAULT_STROKE_COLOR);
                                            const strokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                            const style = LINE_STYLES.find(s => s.id === el.lineStyle);
                                            const pointerEvents = (drawingMode === 'space' && spaceEditMode === 'create') ? 'none' : 'all';

                                            if (el.shape === 'rect' && el.type === 'space') {
                                                return <rect key={el.id} data-id={el.id} x={`${el.x}%`} y={`${el.y}%`} width={`${el.width}%`} height={`${el.height}%`} fill={el.fill} stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} style={{ pointerEvents }} />;
                                            }
                                            if (el.shape === 'line' && el.type === 'space') {
                                                const p1 = { x: el.x1 / 100 * dimensions.width, y: el.y1 / 100 * dimensions.height };
                                                const p2 = { x: el.x2 / 100 * dimensions.width, y: el.y2 / 100 * dimensions.height };
                                                if (el.lineStyle === 'wavy') {
                                                    return <path key={el.id} data-id={el.id} d={generateWavyPathD(p1, p2)} stroke={stroke} strokeWidth={strokeW} fill="none" style={{ pointerEvents }} />;
                                                }
                                                return <line key={el.id} data-id={el.id} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} strokeLinecap="square" style={{ pointerEvents }} />;
                                            }
                                            if (el.shape === 'polygon' && el.type === 'space') {
                                                return <polygon key={el.id} data-id={el.id} points={el.points} fill={el.fill} stroke="none" style={{pointerEvents: 'none'}} />;
                                            }
                                            if (el.type === 'text') {
                                                let textAnchor = 'start';
                                                if (el.textAlign === 'center') textAnchor = 'middle';
                                                else if (el.textAlign === 'right') textAnchor = 'end';
                                                return (
                                                    <text key={el.id} data-id={el.id} x={`${el.x}%`} y={`${el.y}%`} fill={el.color} fontSize={el.fontSize} fontFamily={el.fontFamily} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab', pointerEvents:'all'}} textAnchor={textAnchor}>
                                                        {el.text.split('\n').map((line, i) => (
                                                            <tspan key={i} x={`${el.x}%`} dy={i === 0 ? 0 : '1.2em'}>{line}</tspan>
                                                        ))}
                                                    </text>
                                                );
                                            }
                                            if (el.type === 'compass') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const template = COMPASS_TEMPLATES.find(t => t.id === el.templateId) || COMPASS_TEMPLATES[0];
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <image href={template.src} x={-el.size / 2} y={-el.size / 2} width={el.size} height={el.size} preserveAspectRatio="xMidYMid meet" />
                                                        {isSelected && <rect x={-el.size/2 - 2} y={-el.size/2 - 2} width={el.size + 4} height={el.size + 4} fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2" />}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'fixture') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === el.templateId))] || FIXTURE_TEMPLATES.kitchen;
                                                const template = templateCategory.find(t => t.id === el.templateId) || FIXTURE_TEMPLATES.kitchen[0];
                                                const scaleFactor = el.size / template.defaultSize;
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) scale(${scaleFactor})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <path d={template.path} fill={el.fill} stroke={el.stroke} strokeWidth={el.strokeWidth} />
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'door' || el.type === 'window') {
                                                const p1 = { x: el.x1 / 100 * dimensions.width, y: el.y1 / 100 * dimensions.height };
                                                const template = el.type === 'door' ? (DOOR_TEMPLATES.find(t => t.id === el.templateId) || DOOR_TEMPLATES[0]) : (WINDOW_TEMPLATES.find(t => t.id === el.templateId) || WINDOW_TEMPLATES[0]);
                                                const totalRotation = el.baseAngle + (el.rotation || 0);
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${p1.x}, ${p1.y}) rotate(${totalRotation})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <path d={template.path(el.length, el.swingDirection, el.isInner, el.wallThickness)} fill="none" stroke={stroke} strokeWidth={strokeW} strokeLinecap="square" />
                                                    </g>
                                                );
                                            }
                                            return null;
                                        })}
                                        {/* Preview Rendering */}
                                        {drawingStartPoint && (drawingMode !== 'space' || spaceShape !== 'line') && (() => {
                                            let previewEndPoint = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                            if(drawingMode === 'compass') previewEndPoint = mousePos;
                                            if(drawingMode === 'space' && spaceShape === 'rect') return <rect x={Math.min(drawingStartPoint.x, previewEndPoint.x)} y={Math.min(drawingStartPoint.y, previewEndPoint.y)} width={Math.abs(drawingStartPoint.x - previewEndPoint.x)} height={Math.abs(drawingStartPoint.y - previewEndPoint.y)} fill="transparent" stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="5,5" style={{ pointerEvents: 'none' }} />;
                                            if(drawingMode === 'door' || drawingMode === 'window') return <line x1={drawingStartPoint.x} y1={drawingStartPoint.y} x2={previewEndPoint.x} y2={previewEndPoint.y} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="5,5" style={{ pointerEvents: 'none' }} />;
                                            return null;
                                        })()}
                                        {linePoints.length > 0 && (
                                            <g style={{pointerEvents: 'none'}}>
                                                {linePoints.map((p, i) => {
                                                    if (i === 0) return null;
                                                    const p1 = linePoints[i-1];
                                                    return <line key={i} x1={p1.x} y1={p1.y} x2={p.x} y2={p.y} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray={LINE_STYLES.find(s => s.id === lineStyle)?.dashArray || 'none'} />;
                                                })}
                                                <line x1={linePoints[linePoints.length - 1].x} y1={linePoints[linePoints.length - 1].y} x2={mousePos.x} y2={mousePos.y} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="5,5" />
                                            </g>
                                        )}
                                    </svg>
                                </div>
                            </div>
                        </main>

                        <button onClick={() => setSidebarOpen(!isSidebarOpen)} className={`absolute top-16 z-20 bg-indigo-600 hover:bg-indigo-700 text-white w-6 h-12 flex items-center justify-center rounded-r-lg cursor-pointer transition-all duration-300 ease-in-out focus:outline-none ${isSidebarOpen ? 'left-80' : '-left-0'}`} aria-label={isSidebarOpen ? "サイドバーを閉じる" : "サイドバーを開く"}>
                            {isSidebarOpen ? '◀' : '▶'}
                        </button>

                        <aside className={`absolute top-0 left-0 h-full w-80 bg-gray-50 p-4 space-y-4 z-10 transform transition-transform duration-300 ease-in-out ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`} style={{overflowY: 'auto'}}>
                            <div ref={displaySettingsRef}>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDisplaySettingsOpen(!isDisplaySettingsOpen)}>
                                    <span>表示設定</span>
                                    <span className="text-gray-400">{isDisplaySettingsOpen ? '▼' : '▶'}</span>
                                </h2>
                                {isDisplaySettingsOpen && (
                                    <div className="mt-2 space-y-4">
                                        <div>
                                            <label className="cursor-pointer block w-full text-sm text-center text-blue-700 bg-blue-50 hover:bg-blue-100 font-semibold py-2 px-4 rounded-full">
                                                下絵を選択<input type="file" onChange={handleFileChange} accept="image/*" className="hidden"/>
                                            </label>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">下絵のサイズ: {Math.round(imageScale * 100)}%</label>
                                            <div className="flex items-center space-x-2 mt-1">
                                                <input type="range" min="10" max="300" step="1" value={imageScale * 100} onChange={(e) => setImageScale(parseFloat(e.target.value) / 100)} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                <input type="number" value={Math.round(imageScale * 100)} onChange={(e) => setImageScale(parseInt(e.target.value) / 100 || 0.1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                            </div>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">下絵の透明度: {Math.round(imageOpacity * 100)}%</label>
                                             <div className="flex items-center space-x-2 mt-1">
                                                <input type="range" min="0" max="1" step="0.05" value={imageOpacity} onChange={(e) => setImageOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                <input type="number" value={Math.round(imageOpacity * 100)} onChange={(e) => setImageOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                            </div>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">レイヤーの透明度: {Math.round(drawingOpacity * 100)}%</label>
                                            <div className="flex items-center space-x-2 mt-1">
                                                <input type="range" min="0" max="1" step="0.05" value={drawingOpacity} onChange={(e) => setDrawingOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                <input type="number" value={Math.round(drawingOpacity * 100)} onChange={(e) => setDrawingOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                            </div>
                                        </div>
                                        <div className="flex items-center">
                                            <input id="grid-toggle" type="checkbox" checked={isGridVisible} onChange={() => setGridVisible(!isGridVisible)} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                            <label htmlFor="grid-toggle" className="ml-2 block text-sm font-medium text-gray-700">グリッド線を表示</label>
                                        </div>
                                        {isGridVisible && (
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">グリッドサイズ: {gridSize}px</label>
                                                <div className="flex items-center space-x-2 mt-1">
                                                    <input type="range" min="5" max="50" step="1" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                    <input type="number" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value) || 5)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            <hr/>
                            <div>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDrawingToolsOpen(!isDrawingToolsOpen)}>
                                    <span>図形描画</span>
                                    <span className="text-gray-400">{isDrawingToolsOpen ? '▼' : '▶'}</span>
                                </h2>
                                {isDrawingToolsOpen && (
                                    <div className="mt-2">
                                        <div className="grid grid-cols-3 gap-2">
                                            {['space', 'door', 'window', 'fixture', 'compass', 'text'].map(mode => {
                                                const names = {'space':'空間','door':'ドア','window':'窓','fixture':'設備','compass':'方角','text':'文字'};
                                                return <button key={mode} onClick={() => setDrawingMode(mode)} className={`px-2 py-2 rounded text-sm ${drawingMode === mode ? 'bg-indigo-600 text-white' : 'bg-gray-200'}`}>{names[mode]}</button>
                                            })}
                                        </div>

                                        {drawingMode === 'space' && (
                                            <div className="mt-4">
                                                <div className="flex bg-gray-200 rounded-lg p-1">
                                                    <button onClick={() => setSpaceEditMode('create')} className={`w-full py-1 rounded-md text-sm ${spaceEditMode === 'create' ? 'bg-white shadow' : ''}`}>作成</button>
                                                    <button onClick={() => setSpaceEditMode('edit')} className={`w-full py-1 rounded-md text-sm ${spaceEditMode === 'edit' ? 'bg-white shadow' : ''}`}>編集</button>
                                                </div>
                                                {spaceEditMode === 'create' && (
                                                    <div className="mt-4 space-y-4">
                                                        <div>
                                                            <label htmlFor="space-type-select" className="block text-sm font-medium text-gray-700">空間タイプ</label>
                                                            <select id="space-type-select" value={spaceType} onChange={(e) => setSpaceType(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {SPACE_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                                            </select>
                                                        </div>
                                                        <div className="flex bg-gray-200 rounded-lg p-1">
                                                            <button onClick={() => setSpaceShape('rect')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'rect' ? 'bg-white shadow' : ''}`}>四角形</button>
                                                            <button onClick={() => setSpaceShape('line')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'line' ? 'bg-white shadow' : ''}`}>線</button>
                                                        </div>
                                                        <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} isRectShape={spaceShape === 'rect'}/>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ: {strokeWidth}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label htmlFor="stroke-color-picker" className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input id="stroke-color-picker" type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                            <div>
                                                                <label htmlFor="fill-color-picker" className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                <input type="color" value={fillColor} onChange={(e) => setFillColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                {spaceEditMode === 'edit' && selectedElement && (selectedElement.type === 'space' || (selectedElement.type === 'text' && svgElements.some(s => s.type === 'space'))) && (
                                                    <div className="mt-4 space-y-4">
                                                        <p className="text-sm text-gray-600">編集したい空間を選択してください。</p>
                                                        {selectedElement.type === 'space' &&
                                                            <>
                                                                <div>
                                                                    <label className="block text-sm font-medium text-gray-700">空間タイプ</label>
                                                                    <select value={selectedElement.spaceType} onChange={(e) => handleSelectedElementUpdate('spaceType', e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                        {SPACE_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                                                    </select>
                                                                </div>
                                                                <LineStyleSelector selectedStyle={selectedElement.lineStyle || 'solid'} onChange={(newStyle) => handleSelectedElementUpdate('lineStyle', newStyle)} isRectShape={selectedElement.shape === 'rect'}/>
                                                                <div>
                                                                    <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH}px</label>
                                                                    <div className="flex items-center space-x-2 mt-1">
                                                                        <input type="range" min="1" max="20" step="1" value={selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                        <input type="number" value={selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                                    </div>
                                                                </div>
                                                                <div className="grid grid-cols-2 gap-2">
                                                                    <div>
                                                                        <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                        <input type="color" value={selectedElement.color || DEFAULT_STROKE_COLOR} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                                    </div>
                                                                    <div>
                                                                        <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                        <input type="color" value={selectedElement.fill || '#ffffff'} onChange={(e) => handleSelectedElementUpdate('fill', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                                    </div>
                                                                </div>
                                                                <div className="mt-6">
                                                                    <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この空間を削除 (Delete)</button>
                                                                </div>
                                                            </>
                                                        }
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        {/* Other drawing modes... */}
                                        {['door', 'window', 'fixture', 'compass', 'text'].includes(drawingMode) && (
                                            <div className="mt-4 space-y-4">
                                                {/* The specific UI for each mode will be rendered here */}
                                                {drawingMode === 'door' && ( <div className="mt-4 space-y-4"> <p className="text-sm text-gray-600">キャンバス上を2回クリックしてドアを配置します。</p> {selectedElement && selectedElement.type === 'door' ? ( <div> <h3 className="text-md font-semibold mb-2">選択中のドアを編集</h3> <DoorTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} /> <div> <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="1" max="10" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">線の色</label> <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div className="mt-2 flex space-x-2"> <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button> <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このドアを削除 (Delete)</button> </div> </div> ) : ( <DoorTemplateSelector selectedTemplateId={doorTemplateId} onChange={setDoorTemplateId} /> )} </div> )}
                                                {drawingMode === 'window' && ( <div className="mt-4 space-y-4"> <p className="text-sm text-gray-600">キャンバス上を2回クリックして窓を配置します。</p> {selectedElement && selectedElement.type === 'window' ? ( <div> <h3 className="text-md font-semibold mb-2">選択中の窓を編集</h3> <WindowTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} /> <div> <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="1" max="10" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">線の色</label> <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div className="mt-2 flex space-x-2"> <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button> <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この窓を削除 (Delete)</button> </div> </div> ) : ( <WindowTemplateSelector selectedTemplateId={windowTemplateId} onChange={setWindowTemplateId} /> )} </div> )}
                                                {drawingMode === 'fixture' && ( <div className="mt-4 space-y-4"> <p className="text-sm text-gray-600">キャンバスをクリックして設備を配置します。</p> {selectedElement && selectedElement.type === 'fixture' ? ( <div> <h3 className="text-md font-semibold mb-2">選択中の設備を編集</h3> <div> <label className="block text-sm font-medium text-gray-700">カテゴリ</label> <select value={fixtureCategory} onChange={(e) => setFixtureCategory(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"> {Object.keys(FIXTURE_TEMPLATES).map(cat => ( <option key={cat} value={cat}> {cat === 'kitchen' ? 'キッチン' : cat === 'bathroom' ? '浴室' : cat === 'bedroom' ? '寝室' : cat === 'livingDining' ? 'リビング・ダイニング' : 'その他'} </option> ))} </select> </div> <FixtureTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} category={fixtureCategory} /> <div> <label className="block text-sm font-medium text-gray-700">サイズ: {selectedElement.size}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="10" max="100" step="1" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value) || 10)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label> <input type="color" value={selectedElement.fill} onChange={(e) => handleSelectedElementUpdate('fill', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> <div> <label className="block text-sm font-medium text-gray-700">線の色</label> <input type="color" value={selectedElement.stroke} onChange={(e) => handleSelectedElementUpdate('stroke', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div> <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="1" max="10" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この設備を削除 (Delete)</button> </div> </div> ) : ( <> <div> <label className="block text-sm font-medium text-gray-700">カテゴリ</label> <select value={fixtureCategory} onChange={(e) => setFixtureCategory(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"> {Object.keys(FIXTURE_TEMPLATES).map(cat => ( <option key={cat} value={cat}> {cat === 'kitchen' ? 'キッチン' : cat === 'bathroom' ? '浴室' : cat === 'bedroom' ? '寝室' : cat === 'livingDining' ? 'リビング・ダイニング' : 'その他'} </option> ))} </select> </div> <FixtureTemplateSelector selectedTemplateId={fixtureTemplateId} onChange={setFixtureTemplateId} category={fixtureCategory} /> </> )} </div> )}
                                                {drawingMode === 'compass' && ( <div className="mt-4 space-y-4"> <p className="text-sm text-gray-600">キャンバス上をクリックして始点を決め、もう一度クリックして終点を決めます。</p> {selectedElement && selectedElement.type === 'compass' ? ( <div> <h3 className="text-md font-semibold mb-2">選択中の方角を編集</h3> <CompassTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} /> <div> <label className="block text-sm font-medium text-gray-700 mt-2">サイズ</label> <div className="flex items-center space-x-2 mt-1"> <input type="range" min="20" max="300" step="1" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /> </div> </div> <div> <label className="block text-sm font-medium text-gray-700 mt-2">回転</label> <div className="flex items-center space-x-2 mt-1"> <input type="range" min="-180" max="180" step="1" value={selectedElement.rotation || 0} onChange={(e) => handleSelectedElementUpdate('rotation', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={Math.round(selectedElement.rotation || 0)} onChange={(e) => handleSelectedElementUpdate('rotation', parseInt(e.target.value) || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /> </div> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この方角を削除 (Delete)</button> </div> </div> ) : ( <CompassTemplateSelector selectedTemplateId={compassTemplateId} onChange={setCompassTemplateId} /> )} </div> )}
                                                {drawingMode === 'text' && ( <div className="mt-4 space-y-4"> <p className="text-sm text-gray-600">キャンバスをクリックしてテキストを配置します。</p> { selectedElement && selectedElement.type === 'text' ? ( <div> <h3 className="text-md font-semibold mb-2">選択中のテキストを編集</h3> <div> <label className="block text-sm font-medium text-gray-700">テキスト</label> <textarea value={selectedElement.text} onChange={(e) => handleSelectedElementUpdate('text', e.target.value)} className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" rows="3"></textarea> </div> <div> <label className="block text-sm font-medium text-gray-700">フォント</label> <select value={selectedElement.fontFamily} onChange={(e) => handleSelectedElementUpdate('fontFamily', e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"> {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)} </select> </div> <div> <label className="block text-sm font-medium text-gray-700">フォントサイズ: {selectedElement.fontSize}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="8" max="72" step="1" value={selectedElement.fontSize} onChange={(e) => handleSelectedElementUpdate('fontSize', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.fontSize} onChange={(e) => handleSelectedElementUpdate('fontSize', parseInt(e.target.value) || 8)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">文字色</label> <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div> <label className="block text-sm font-medium text-gray-700">配置</label> <div className="flex bg-gray-200 rounded-lg p-1"> <button onClick={() => handleSelectedElementUpdate('textAlign', 'left')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button> <button onClick={() => handleSelectedElementUpdate('textAlign', 'center')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button> <button onClick={() => handleSelectedElementUpdate('textAlign', 'right')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button> </div> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このテキストを削除 (Delete)</button> </div> </div> ) : ( <> <div> <label htmlFor="font-family-select" className="block text-sm font-medium text-gray-700">フォント</label> <select id="font-family-select" value={fontFamily} onChange={(e) => setFontFamily(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"> {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)} </select> </div> <div> <label htmlFor="font-size-slider" className="block text-sm font-medium text-gray-700">フォントサイズ: {fontSize}px</label> <div className="flex items-center space-x-2 mt-1"><input id="font-size-slider" type="range" min="8" max="72" step="1" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value) || 8)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label htmlFor="text-color-picker" className="block text-sm font-medium text-gray-700">文字色</label> <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div> <label className="block text-sm font-medium text-gray-700">配置</label> <div className="flex bg-gray-200 rounded-lg p-1"> <button onClick={() => setTextAlign('left')} className={`w-full py-1 rounded-md text-sm ${textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button> <button onClick={() => setTextAlign('center')} className={`w-full py-1 rounded-md text-sm ${textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button> <button onClick={() => setTextAlign('right')} className={`w-full py-1 rounded-md text-sm ${textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button> </div> </div> </> )} </div> )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </aside>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<Editor />, document.getElementById('root'));
    </script>
</body>
</html>
