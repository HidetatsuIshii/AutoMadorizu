<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>間取り図エディタ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
        }
        .editor-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        .scroll-wrapper {
            width: 5000px;
            height: 5000px;
            position: relative;
        }
        .editor-container {
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            transform-origin: center center;
        }
        .editor-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            max-width: 100%;
            max-height: 100%;
            pointer-events: none;
        }
        .editor-canvas, .editor-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .editor-svg {
            pointer-events: all;
        }
        .editor-svg > * {
            pointer-events: all;
        }
        .cursor-crosshair { cursor: crosshair; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-default { cursor: default; }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.4L159.2%2C69.7c-3.1-3.1-8.2-3.1-11.3%2C0L5.4%2C197.4c-3.1%2C3.1-3.1%2C8.2%2C0%2C11.3l11.3%2C11.3c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l115.4-115.4l115.4%2C115.4c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l11.3-11.3C290.1%2C205.6%2C290.1%2C200.5%2C287%2C197.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem 0.8rem;
            padding-right: 2.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
        }
        select:focus {
            border-color: #6366F1;
            box-shadow: 0 0 0 1px #6366F1;
            outline: none;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- 定数とダミーデータ ---
        const DUMMY_OCR_DATA = {
            "Blocks": [
                { "id": "block-1", "type": "LDK", "Text": "LDK 12.5帖", "Geometry": { "BoundingBox": { "Width": 0.25, "Height": 0.05, "Left": 0.4, "Top": 0.5 }}},
                { "id": "block-2", "type": "洋室", "Text": "洋室 6.0帖", "Geometry": { "BoundingBox": { "Width": 0.2, "Height": 0.05, "Left": 0.1, "Top": 0.2 }}},
                { "id": "block-3", "type": "浴室", "Text": "浴室", "Geometry": { "BoundingBox": { "Width": 0.1, "Height": 0.04, "Left": 0.7, "Top": 0.2 }}},
                { "id": "block-4", "type": "収納", "Text": "WIC", "Geometry": { "BoundingBox": { "Width": 0.08, "Height": 0.04, "Left": 0.15, "Top": 0.4 }}}
            ]
        };
        const ROOM_TYPES = ["LDK", "洋室", "和室", "浴室", "トイレ", "洗面所", "収納", "玄関", "その他"];
        const SPACE_TYPES = ["LDK", "DK", "K", "居室", "和室", "収納", "洗面所", "浴室", "トイレ", "玄関", "バルコニー", "柱", "その他"];
        const FONT_FAMILIES = [
            { id: 'sans-serif', name: 'ゴシック体' },
            { id: 'serif', name: '明朝体' },
            { id: 'monospace', name: '等幅フォント' },
            { id: 'cursive', name: '筆記体' }
        ];
        const SNAP_THRESHOLD = 10;
        const DEFAULT_WIDTH = 1200;
        const DEFAULT_HEIGHT = 900;
        const SELECTED_ELEMENT_COLOR = '#3b82f6';
        const DEFAULT_STROKE_COLOR = '#000000';
        const DEFAULT_STROKE_WIDTH = 3;

        const LINE_STYLES = [
            { id: 'solid', name: '実線', dashArray: 'none' },
            { id: 'dashed', name: '破線', dashArray: '10, 5' },
            { id: 'dotted', name: '点線', dashArray: '2, 5' },
            { id: 'chain', name: '一点鎖線', dashArray: '10, 4, 2, 4' },
            { id: 'double-chain', name: '二点鎖線', dashArray: '10, 4, 2, 4, 2, 4' },
            { id: 'wavy', name: '波線', dashArray: null }
        ];

        const DEFAULT_FILL_COLORS = {
            "LDK": "#fef3c7", "DK": "#fef3c7", "K": "#fef3c7",
            "居室": "#f5e5d4",
            "和室": "#dcfce7",
            "収納": "#fef9c3",
            "洗面所": "#dbeafe",
            "浴室": "#dbeafe",
            "トイレ": "#dbeafe",
            "玄関": "#dedede",
            "バルコニー": "#f5f5f5",
            "柱": "#000000",
            "その他": "#fafafa"
        };

        const COMPASS_TEMPLATES = [
            { id: 'dsynbol01', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol01.svg'},
            { id: 'dsynbol02', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol02.svg'},
            { id: 'dsynbol03', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol03.svg'},
            { id: 'dsynbol04', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol04.svg'},
            { id: 'dsynbol05', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol05.svg'},
            { id: 'dsynbol06', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol06.svg'},
            { id: 'dsynbol07', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol07.svg'},
            { id: 'dsynbol08', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol08.svg'},
            { id: 'dsynbol09', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol09.svg'},
            { id: 'dsynbol10', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol10.svg'},
            { id: 'dsynbol11', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol11.svg'}
        ];

        const FIXTURE_TEMPLATES = {
            kitchen: [
                { id: 'kitchen-sink', name: 'シンク', path: 'M-20,-10 H20 V10 H-20 Z M-10,-10 V10 M0,-10 V10', defaultSize: 40, defaultFill: '#cccccc', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'refrigerator', name: '冷蔵庫', path: 'M-10,-20 H10 V20 H-10 Z M-10,0 H10', defaultSize: 40, defaultFill: '#e0e0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'gas-range', name: 'ガスコンロ', path: 'M-15,-15 H15 V15 H-15 Z M-10,-10 L10,10 M-10,10 L10,-10', defaultSize: 35, defaultFill: '#f0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'microwave', name: '電子レンジ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-5 H10 M-10,0 H10', defaultSize: 30, defaultFill: '#f5f5f5', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dishwasher', name: '食洗機', path: 'M-15,-10 H15 V10 H-15 Z M-10,0 V10 M0,0 V10 M10,0 V10', defaultSize: 30, defaultFill: '#e0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'pantry', name: '食器棚', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20 M-10,-10 H10 M-10,0 H10 M-10,10 H10', defaultSize: 45, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bathroom: [
                { id: 'bathtub', name: '浴槽', path: 'M-20,-10 H20 V10 H-20 Z M-15,-5 H15 V5 H-15 Z', defaultSize: 40, defaultFill: '#e0f0ff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'washbasin', name: '洗面台', path: 'M-10,-10 H10 V10 H-10 Z M-5,0 A5,5 0 1,0 5,0', defaultSize: 30, defaultFill: '#ffffff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'washing-machine', name: '洗濯機', path: 'M-15,-15 H15 V15 H-15 Z M0,-15 V15 M-10,-5 H10', defaultSize: 35, defaultFill: '#f0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'shower', name: 'シャワー', path: 'M-15,-15 H15 V15 H-15 Z M-10,-10 L10,10 M-10,10 L10,-10', defaultSize: 30, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bidet', name: 'ビデ', path: 'M-10,-10 H10 V10 H-10 Z M-10,-5 A5,5 0 0,1 -5,-10 H5 A5,5 0 0,1 10,-5', defaultSize: 25, defaultFill: '#ffffff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'towel-rack', name: 'タオル掛け', path: 'M-15,-5 H15 M-10,5 H10', defaultSize: 25, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bedroom: [
                { id: 'bed-single', name: 'シングルベッド', path: 'M-20,-15 H20 V15 H-20 Z M-15,-15 H15 V-5 H-15 Z', defaultSize: 50, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bed-double', name: 'ダブルベッド', path: 'M-30,-20 H30 V20 H-30 Z M-25,-20 H25 V-5 H-25 Z', defaultSize: 60, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'closet', name: 'クローゼット', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20', defaultSize: 40, defaultFill: '#f5deb3', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dresser', name: 'ドレッサー', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'nightstand', name: 'ナイトスタンド', path: 'M-10,-10 H10 V10 H-10 Z', defaultSize: 20, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'wardrobe', name: 'ワードローブ', path: 'M-20,-25 H20 V25 H-20 Z M-15,-25 V25 M15,-25 V25', defaultSize: 50, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            livingDining: [
                { id: 'dining-table-round', name: '円形テーブル', path: 'M0,0 A15,15 0 1,0 0,0.001 Z', defaultSize: 40, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dining-table-rect', name: '長方形テーブル', path: 'M-25,-15 H25 V15 H-25 Z', defaultSize: 50, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-single', name: '一人掛けソファ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 V0 M10,-10 V0', defaultSize: 40, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-double', name: '二人掛けソファ', path: 'M-30,-10 H30 V10 H-30 Z M-25,-10 V0 M25,-10 V0', defaultSize: 60, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'tv-stand', name: 'テレビ台', path: 'M-20,-5 H20 V5 H-20 Z', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bookshelf', name: '本棚', path: 'M-15,-20 H15 V20 H-15 Z M-10,-15 H10 M-10,0 H10 M-10,15 H10', defaultSize: 45, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            other: [
                { id: 'desk', name: 'デスク', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 45, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'stairs', name: '階段', path: 'M-20,-20 H20 V20 H-20 Z M-20,-10 H20 M-20,0 H20 M-20,10 H20', defaultSize: 50, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'fireplace', name: '暖炉', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 L-10,0 L10,0 L10,-10', defaultSize: 30, defaultFill: '#a0a0a0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'piano', name: 'ピアノ', path: 'M-25,-10 H25 V10 H-25 Z M-20,-10 V0 M-15,-10 V0 M-10,-10 V0 M-5,-10 V0 M0,-10 V0 M5,-10 V0 M10,-10 V0 M15,-10 V0 M20,-10 V0', defaultSize: 50, defaultFill: '#303030', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ]
        };

        const DOOR_TEMPLATES = [
            { id: 'swing-right', name: '開き戸 (右)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const sweepFlag = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 M0,0 L0,${isInner ? doorThickness : -doorThickness} M0,0 A${length},${length} 0 0,${sweepFlag} ${length},${isInner ? length : -length}`;
                },
                previewPath: 'M0,0 L40,0 M0,0 L0,10 M0,0 A40,40 0 0,1 40,40'
            },
            { id: 'swing-left', name: '開き戸 (左)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const sweepFlag = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 M${length},0 L${length},${isInner ? doorThickness : -doorThickness} M${length},0 A${length},${length} 0 0,${sweepFlag} 0,${isInner ? length : -length}`;
                },
                previewPath: 'M0,0 L40,0 M40,0 L40,10 M40,0 A40,40 0 0,0 0,40'
            },
            { id: 'sliding-single', name: '引き戸 (片)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorOffset = (wallThickness || 10) / 2;
                    return `M0,0 L${length},0 M0,${doorOffset} L${length},${doorOffset}`;
                },
                previewPath: 'M0,0 L40,0 M0,5 L40,5'
            },
            { id: 'double-swing', name: '両開き戸',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const halfLength = length / 2;
                    const doorThickness = wallThickness || 10;
                    const sweepFlag1 = swingDirection === 'clockwise' ? 1 : 0;
                    const sweepFlag2 = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 ` +
                           `M0,0 L0,${isInner ? doorThickness : -doorThickness} ` +
                           `M${halfLength},0 L${halfLength},${isInner ? doorThickness : -doorThickness} ` +
                           `M0,0 A${halfLength},${halfLength} 0 0,${sweepFlag1} ${halfLength},${isInner ? halfLength : -halfLength} ` +
                           `M${length},0 A${halfLength},${halfLength} 0 0,${sweepFlag2} ${halfLength},${isInner ? halfLength : -halfLength}`;
                },
                previewPath: 'M20,0 L0,0 M20,0 L40,0 M0,0 A20,20 0 0,1 20,20 M40,0 A20,20 0 0,0 20,20'
            },
            { id: 'parent-child-door', name: '親子ドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const parentLength = length * 0.7;
                    const childLength = length * 0.3;
                    const sweepFlagParent = swingDirection === 'clockwise' ? 1 : 0;
                    const sweepFlagChild = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 ` +
                           `M0,0 L0,${isInner ? doorThickness : -doorThickness} ` +
                           `M${parentLength},0 L${parentLength},${isInner ? doorThickness : -doorThickness} ` +
                           `M0,0 A${parentLength},${parentLength} 0 0,${sweepFlagParent} ${parentLength},${isInner ? parentLength : -parentLength} ` +
                           `M${parentLength},0 A${childLength},${childLength} 0 0,${sweepFlagChild} ${length},${isInner ? childLength : -childLength}`;
                },
                previewPath: 'M0,0 L40,0 M0,0 L0,10 M28,0 L28,10 M0,0 A28,28 0 0,1 28,28 M28,0 A12,12 0 0,1 40,12'
            },
            { id: 'bifold', name: '折れ戸',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const segmentLength = length / 4;
                    const offset = isInner ? doorThickness : -doorThickness;
                    return `M0,0 L${length},0 ` +
                           `M0,${offset} L${segmentLength},0 ` +
                           `M${segmentLength},0 L${segmentLength * 2},${offset} ` +
                           `M${segmentLength * 2},${offset} L${segmentLength * 3},0 ` +
                           `M${segmentLength * 3},0 L${length},${offset}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L10,0 M10,0 L20,10 M20,10 L30,0 M30,0 L40,10'
            }
        ];

        const WINDOW_TEMPLATES = [
            { id: 'sliding-window', name: '引き違い窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    const offset = windowThickness / 2;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,${offset} L${length},${offset}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,5 L40,5'
            },
            { id: 'casement-single', name: '片開き窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    const arcSweep = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,0 L0,${windowThickness} M${length},0 A${windowThickness},${windowThickness} 0 0,${arcSweep} ${length - windowThickness},0`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,0 L0,10 M40,0 A10,10 0 0,1 30,0'
            },
            { id: 'casement-double', name: '両開き窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const halfLength = length / 2;
                    const windowThickness = wallThickness || 10;
                    const arcSweep1 = swingDirection === 'clockwise' ? 1 : 0;
                    const arcSweep2 = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M${halfLength},0 L${halfLength},${windowThickness} M0,0 A${windowThickness},${windowThickness} 0 0,${arcSweep1} ${windowThickness},0 M${length},0 A${windowThickness},${windowThickness} 0 0,${arcSweep2} ${length-windowThickness},0`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M20,0 L20,10 M0,0 A10,10 0 0,1 10,0 M40,0 A10,10 0 0,0 30,0'
            },
            { id: 'fixed-window', name: 'FIX窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,0 L0,${windowThickness} M${length},0 L${length},${windowThickness} M0,0 L${length},${windowThickness} M${length},0 L0,${windowThickness}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,0 L0,10 M40,0 L40,10 M0,0 L40,10 M40,0 L0,10'
            }
        ];


        // --- ヘルパー関数 ---
        const generateWavyPathD = (p1, p2) => {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 1) return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
            const dirX = dx / len, dirY = dy / len, perpX = -dirY, perpY = dirX;
            const amplitude = 4, wavelength = 15;
            const numSegments = Math.max(1, Math.floor(len / wavelength));
            const segmentLen = len / numSegments;
            let d = `M ${p1.x} ${p1.y}`;
            for (let i = 0; i < numSegments; i++) {
                const midX = p1.x + (i + 0.5) * segmentLen * dirX;
                const midY = p1.y + (i + 0.5) * segmentLen * dirY;
                const segEndX = p1.x + (i + 1) * segmentLen * dirX;
                const segEndY = p1.y + (i + 1) * segmentLen * dirY;
                const amp = (i % 2 === 0) ? amplitude : -amplitude;
                const controlX = midX + amp * perpX;
                const controlY = midY + amp * perpY;
                d += ` Q ${controlX} ${controlY} ${segEndX} ${segEndY}`;
            }
            return d;
        };

        const distToSegment = (p, v, w) => {
            if (!v || !w || typeof v.x !== 'number' || typeof v.y !== 'number' || typeof w.x !== 'number' || typeof w.y !== 'number' ||
                isNaN(v.x) || isNaN(v.y) || isNaN(w.x) || isNaN(w.y)) {
                console.error("Invalid point passed to distToSegment:", p, v, w);
                return Infinity;
            }
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const proj = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return Math.sqrt((p.x - proj.x)**2 + (p.y - proj.y)**2);
        };

        const projectPointOnLine = (p, p1, p2) => {
            const lineVec = { x: p2.x - p1.x, y: p2.y - p1.y };
            const pointVec = { x: p.x - p1.x, y: p.y - p1.y };
            const dotProduct = pointVec.x * lineVec.x + pointVec.y * lineVec.y;
            const lengthSq = lineVec.x * lineVec.x + lineVec.y * lineVec.y;
            let t = 0;
            if (lengthSq !== 0) {
                t = dotProduct / lengthSq;
            }
            t = Math.max(0, Math.min(1, t));
            return {
                x: p1.x + t * lineVec.x,
                y: p1.y + t * lineVec.y
            };
        };

        const getRectangleSegments = (rectElement, dimensions) => {
            const x = (typeof rectElement.x === 'number' && !isNaN(rectElement.x) ? rectElement.x : 0) / 100 * dimensions.width;
            const y = (typeof rectElement.y === 'number' && !isNaN(rectElement.y) ? rectElement.y : 0) / 100 * dimensions.height;
            const width = (typeof rectElement.width === 'number' && !isNaN(rectElement.width) ? rectElement.width : 0) / 100 * dimensions.width;
            const height = (typeof rectElement.height === 'number' && !isNaN(rectElement.height) ? rectElement.height : 0) / 100 * dimensions.height;
            const p1 = { x: x, y: y };
            const p2 = { x: x + width, y: y };
            const p3 = { x: x + width, y: y + height };
            const p4 = { x: x, y: y + height };
            return [
                { p1: p1, p2: p2 }, { p1: p2, p2: p3 }, { p1: p3, p2: p4 }, { p1: p4, p2: p1 }
            ];
        };

        // --- UIコンポーネント ---
        const LineStyleSelector = ({ selectedStyle, onChange, isRectShape }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">線の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-1">
                    {LINE_STYLES.map(style => (
                        (isRectShape && style.id === 'wavy') ? null : (
                            <button key={style.id} onClick={() => onChange(style.id)} className={`p-2 rounded-md border-2 ${selectedStyle === style.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                                <div className="flex items-center justify-center">
                                    <svg width="40" height="20" viewBox="0 0 60 20" className="flex-shrink-0">
                                        {style.id === 'wavy' ? <path d="M 5 10 C 15 0, 25 20, 35 10 S 55 0, 55 10" stroke="black" strokeWidth="2" fill="none" /> : <line x1="5" y1="10" x2="55" y2="10" stroke="black" strokeWidth="2" strokeDasharray={style.dashArray} strokeLinecap="round" />}
                                    </svg>
                                </div>
                            </button>
                        )
                    ))}
                </div>
            </div>
        );

        const CompassTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">方角の図形</label>
                <div className="mt-2 grid grid-cols-4 gap-1">
                    {COMPASS_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center h-12`}
                        >
                           <img
                                src={template.src}
                                alt={template.id}
                                className="w-8 h-8 object-contain"
                            />
                        </button>
                    ))}
                </div>
            </div>
        );

        const FixtureTemplateSelector = ({ selectedTemplateId, onChange, category }) => {
            const templates = FIXTURE_TEMPLATES[category] || [];
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700">設備の種類</label>
                    <div className="mt-2 grid grid-cols-4 gap-1">
                        {templates.map(template => (
                            <button key={template.id} onClick={() => onChange(template.id)} className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center`}>
                                <svg width="40" height="40" viewBox="-30 -30 60 60" className="flex-shrink-0">
                                    <path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} />
                                </svg>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const DoorTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">ドアの種類</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                    {DOOR_TEMPLATES.map(template => (
                        <button key={template.id} onClick={() => onChange(template.id)} className={`p-2 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center space-x-2">
                                <svg width="60" height="40" viewBox="0 0 60 40" className="flex-shrink-0">
                                    <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" />
                                </svg>
                                <span className="text-sm">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        const WindowTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">窓の種類</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                    {WINDOW_TEMPLATES.map(template => (
                        <button key={template.id} onClick={() => onChange(template.id)} className={`p-2 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center space-x-2">
                                <svg width="60" height="40" viewBox="0 0 60 40" className="flex-shrink-0">
                                    <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" />
                                </svg>
                                <span className="text-sm">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        // --- メインエディタコンポーネント ---
        function Editor() {
            // --- ステート定義 ---
            const [isSidebarOpen, setSidebarOpen] = useState(true);
            const [isDisplaySettingsOpen, setDisplaySettingsOpen] = useState(true);
            const [isDrawingToolsOpen, setDrawingToolsOpen] = useState(true);
            const [imageUrl, setImageUrl] = useState('');
            const [historyState, setHistoryState] = useState({
                past: [],
                present: { ocrData: null, svgElements: [] },
                future: []
            });
            const { ocrData: currentOcrData, svgElements } = historyState.present;

            const [selectedBlockId, setSelectedBlockId] = useState(null);
            const [drawingMode, setDrawingMode] = useState('space');
            const [spaceEditMode, setSpaceEditMode] = useState('create');
            const [spaceShape, setSpaceShape] = useState('rect');
            const [selectedElementId, setSelectedElementId] = useState(null);
            const [dimensions, setDimensions] = useState({ width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT });
            const [startPoint, setStartPoint] = useState(null);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [snapValue, setSnapValue] = useState(10);
            const [endpointSnap, setEndpointSnap] = useState(null);
            const [imageOpacity, setImageOpacity] = useState(0.5);
            const [drawingOpacity, setDrawingOpacity] = useState(0.6);
            const [zoom, setZoom] = useState(0.8);
            const [imageScale, setImageScale] = useState(1);
            const [strokeWidth, setStrokeWidth] = useState(DEFAULT_STROKE_WIDTH);
            const [strokeColor, setStrokeColor] = useState(DEFAULT_STROKE_COLOR);
            const [spaceType, setSpaceType] = useState('LDK');
            const [fillColor, setFillColor] = useState(DEFAULT_FILL_COLORS[spaceType]);
            const [lineStyle, setLineStyle] = useState('solid');
            const [isGridVisible, setGridVisible] = useState(true);
            const [gridSize, setGridSize] = useState(10);
            const [fontSize, setFontSize] = useState(16);
            const [fontFamily, setFontFamily] = useState('sans-serif');
            const [textAlign, setTextAlign] = useState('left');
            const [compassTemplateId, setCompassTemplateId] = useState(COMPASS_TEMPLATES[0].id);
            const [fixtureCategory, setFixtureCategory] = useState('kitchen');
            const [fixtureTemplateId, setFixtureTemplateId] = useState(FIXTURE_TEMPLATES.kitchen[0].id);
            const [doorTemplateId, setDoorTemplateId] = useState(DOOR_TEMPLATES[0].id);
            const [windowTemplateId, setWindowTemplateId] = useState(WINDOW_TEMPLATES[0].id);
            
            const [isDragging, setIsDragging] = useState(false);

            // --- Ref定義 ---
            const imageRef = useRef(null);
            const canvasRef = useRef(null);
            const editorAreaRef = useRef(null);
            const svgRef = useRef(null);
            const displaySettingsRef = useRef(null);
            const dragInfo = useRef(null);
            const historyOnActionStart = useRef(null);
            const mouseDownInfo = useRef(null);


            // プロパティ編集のためにsvgElementsから現在選択されている要素を見つける
            const selectedElement = selectedElementId ? svgElements.find(el => el.id === selectedElementId) : null;

            // 選択された要素のプロパティを更新し、履歴を記録する関数
            const handleSelectedElementUpdate = useCallback((key, value) => {
                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.id === selectedElementId) {
                            const newEl = { ...el, [key]: value };
                            if (key === 'spaceType') {
                                newEl.fill = DEFAULT_FILL_COLORS[value] || '#ffffff';
                            }
                            return newEl;
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedElementId]);

            // 背景画像をロードするためのファイル入力の変更を処理する
            const handleFileChange = async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImageUrl(e.target.result);
                        const newOcrData = DUMMY_OCR_DATA;
                        setHistoryState(prevState => ({
                            past: [...prevState.past, prevState.present],
                            present: { ocrData: newOcrData, svgElements: prevState.present.svgElements },
                            future: []
                        }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            // ヘルパー関数: マウスイベントからキャンバス座標を取得し、ズームを考慮する
            const getCanvasCoords = useCallback((event) => {
                const editorArea = editorAreaRef.current;
                const svg = svgRef.current;
                if (!editorArea || !svg) return { x: 0, y: 0 };

                const svgRect = svg.getBoundingClientRect();
                const x = (event.clientX - svgRect.left) / zoom;
                const y = (event.clientY - svgRect.top) / zoom;

                return { x, y };
            }, [zoom]);

            // ヘルパー関数: グリッドにスナップされた座標を取得する
            const getGridSnappedPoint = useCallback((point) => {
                return {
                    x: Math.round(point.x / gridSize) * gridSize,
                    y: Math.round(point.y / gridSize) * gridSize
                };
            }, [gridSize]);

            // ヘルパー関数: 線の角度にスナップされた座標を取得する
            const getAngleSnappedPoint = useCallback((start, current) => {
                const dx = current.x - start.x;
                const dy = current.y - start.y;
                let angle = Math.atan2(dy, dx) * 180 / Math.PI;

                const snappedAngle = Math.round(angle / snapValue) * snapValue;

                const length = Math.sqrt(dx * dx + dy * dy);
                const newDx = length * Math.cos(snappedAngle * Math.PI / 180);
                const newDy = length * Math.sin(snappedAngle * Math.PI / 180);

                return { x: start.x + newDx, y: start.y + newDy };
            }, [snapValue]);

            // 線の閉じたループを見つけて塗りつぶしポリゴンを作成する関数
            const findAndCreateFill = useCallback((dimensionsArg, newLine, allElements, fill) => {
                const { width, height } = dimensionsArg;

                const adj = new Map();
                const addEdge = (p1, p2) => {
                    const p1Str = `${p1.x},${p1.y}`;
                    const p2Str = `${p2.x},${p2.y}`;
                    if (!adj.has(p1Str)) adj.set(p1Str, []);
                    if (!adj.has(p2Str)) adj.set(p2Str, []);
                    adj.get(p1Str).push(p2Str);
                    adj.get(p2Str).push(p1Str);
                };

                allElements.filter(el =>
                    el.type === 'space' &&
                    el.shape === 'line' &&
                    el.spaceType === newLine.spaceType
                ).forEach(line => {
                    const x1_val = typeof line.x1 === 'number' && !isNaN(line.x1) ? line.x1 : null;
                    const y1_val = typeof line.y1 === 'number' && !isNaN(line.y1) ? line.y1 : null;
                    const x2_val = typeof line.x2 === 'number' && !isNaN(line.x2) ? line.x2 : null;
                    const y2_val = typeof line.y2 === 'number' && !isNaN(line.y2) ? line.y2 : null;

                    if (x1_val !== null && y1_val !== null && x2_val !== null && y2_val !== null) {
                        const p1 = { x: x1_val / 100 * width, y: y1_val / 100 * height };
                        const p2 = { x: x2_val / 100 * width, y: y2_val / 100 * height };
                        addEdge(p1, p2);
                    }
                });

                const newLineP1 = { x: newLine.x1 / 100 * width, y: newLine.y1 / 100 * height };
                const newLineP2 = { x: newLine.x2 / 100 * width, y: newLine.y2 / 100 * height };
                addEdge(newLineP1, newLineP2);

                const cycles = [];
                const findCycles = (currentNode, path, visitedEdges) => {
                    if (path.length > 1 && currentNode === path[0]) {
                        const cycle = [...path];
                        const minNode = cycle.reduce((min, node) => node < min ? node : min, cycle[0]);
                        const startIndex = cycle.indexOf(minNode);
                        const normalizedCycle = [...cycle.slice(startIndex), ...cycle.slice(0, startIndex)].join('-');
                        if (!cycles.some(c => c.normalized === normalizedCycle)) {
                            cycles.push({ path: cycle, normalized: normalizedCycle });
                        }
                        return;
                    }

                    const neighbors = adj.get(currentNode) || [];
                    for (const neighbor of neighbors) {
                        const edgeKey = [currentNode, neighbor].sort().join('-');
                        if (!visitedEdges.has(edgeKey)) {
                            visitedEdges.add(edgeKey);
                            findCycles(neighbor, [...path, neighbor], visitedEdges);
                            visitedEdges.delete(edgeKey);
                        }
                    }
                };

                for (const node of adj.keys()) {
                    findCycles(node, [node], new Set());
                }

                let bestCycle = null;
                let minArea = Infinity;

                for (const cycle of cycles) {
                    const pathNodes = cycle.path.map(pStr => {
                        const [x, y] = pStr.split(',').map(Number);
                        return { x, y };
                    });

                    const isNewLineInCycle = pathNodes.some((p, i) => {
                        const nextP = pathNodes[(i + 1) % pathNodes.length];
                        const isMatch1 = (p.x === newLineP1.x && p.y === newLineP1.y && nextP.x === newLineP2.x && nextP.y === newLineP2.y);
                        const isMatch2 = (p.x === newLineP2.x && p.y === newLineP2.y && nextP.x === newLineP1.x && nextP.y === newLineP1.y);
                        return isMatch1 || isMatch2;
                    });

                    if (isNewLineInCycle && pathNodes.length >= 3) {
                        let area = 0;
                        for (let i = 0; i < pathNodes.length; i++) {
                            const p1 = pathNodes[i];
                            const p2 = pathNodes[(i + 1) % pathNodes.length];
                            area += (p1.x * p2.y - p2.x * p1.y);
                        }
                        area = Math.abs(area / 2);

                        if (area < minArea && area > 0) {
                            minArea = area;
                            bestCycle = pathNodes;
                        }
                    }
                }

                if (bestCycle) {
                    const newFill = {
                        id: `fill-${Date.now()}`,
                        type: 'fill',
                        shape: 'polygon',
                        spaceType: newLine.spaceType,
                        points: bestCycle.map(p => `${p.x},${p.y}`).join(' '),
                        fill: fill
                    };
                    return newFill;
                }
                return null;
            }, []);

            const handleCanvasClick = useCallback((e) => {
                const clickPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);

                // Case 1: 描画の2クリック目
                if (startPoint) {
                    let newElement = null;

                    if (drawingMode === 'space') {
                        let finalEndPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                        if (!isGridVisible && spaceShape === 'line') {
                            finalEndPoint = endpointSnap ? endpointSnap : getAngleSnappedPoint(startPoint, finalEndPoint);
                        }
                        
                        const currentStrokeColor = (spaceType === '柱') ? '#000000' : strokeColor;
                        const currentFillColor = (spaceType === '柱') ? '#000000' : fillColor;
                        const currentStrokeWidth = (spaceType === '柱') ? 1 : strokeWidth;
                        const currentLineStyle = (spaceType === 'その他' || spaceShape === 'rect') ? 'solid' : lineStyle;

                        if (spaceShape === 'rect') {
                            newElement = { id: `space-${Date.now()}`, type: 'space', shape: 'rect', spaceType: spaceType, x: (Math.min(startPoint.x, finalEndPoint.x) / dimensions.width) * 100, y: (Math.min(startPoint.y, finalEndPoint.y) / dimensions.height) * 100, width: (Math.abs(startPoint.x - finalEndPoint.x) / dimensions.width) * 100, height: (Math.abs(startPoint.y - finalEndPoint.y) / dimensions.height) * 100, fill: currentFillColor, color: currentStrokeColor, strokeWidth: currentStrokeWidth, lineStyle: currentLineStyle };
                        } else if (spaceShape === 'line') {
                            newElement = { id: `space-${Date.now()}`, type: 'space', shape: 'line', spaceType: spaceType, x1: (startPoint.x / dimensions.width) * 100, y1: (startPoint.y / dimensions.height) * 100, x2: (finalEndPoint.x / dimensions.width) * 100, y2: (finalEndPoint.y / dimensions.height) * 100, strokeWidth: currentStrokeWidth, color: currentStrokeColor, lineStyle: currentLineStyle };
                        }
                    } else if (drawingMode === 'compass') {
                        const finalEndPoint = clickPos; 
                        const dx = finalEndPoint.x - startPoint.x;
                        const dy = finalEndPoint.y - startPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const size = Math.min(300, Math.max(20, distance));
                        const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                        newElement = { id: `compass-${Date.now()}`, type: 'compass', x: (startPoint.x / dimensions.width) * 100, y: (startPoint.y / dimensions.height) * 100, size: size, rotation: rotation, templateId: compassTemplateId };
                    } else if (drawingMode === 'door' || drawingMode === 'window') {
                        const finalEndPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                        const dx = finalEndPoint.x - startPoint.x;
                        const dy = finalEndPoint.y - startPoint.y;
                        const length = Math.sqrt(dx*dx + dy*dy);
                        const baseAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                        newElement = {
                            id: `${drawingMode}-${Date.now()}`,
                            type: drawingMode,
                            templateId: drawingMode === 'door' ? doorTemplateId : windowTemplateId,
                            x1: (startPoint.x / dimensions.width) * 100,
                            y1: (startPoint.y / dimensions.height) * 100,
                            x2: (finalEndPoint.x / dimensions.width) * 100,
                            y2: (finalEndPoint.y / dimensions.height) * 100,
                            length: length,
                            baseAngle: baseAngle,
                            rotation: 0,
                            isInner: true,
                            swingDirection: 'clockwise',
                            wallThickness: 10, 
                            color: DEFAULT_STROKE_COLOR,
                            strokeWidth: DEFAULT_STROKE_WIDTH,
                        };
                    }

                    if (newElement) {
                        setHistoryState(prevState => {
                            let tempElements = [...prevState.present.svgElements, newElement];
                            if (newElement.shape === 'line') {
                                const newFill = findAndCreateFill(dimensions, newElement, tempElements, newElement.fill);
                                if (newFill) { tempElements.push(newFill); }
                            }
                            return { past: [...prevState.past, prevState.present], present: { ...prevState.present, svgElements: tempElements }, future: [] };
                        });
                        setSelectedElementId(newElement.id);
                    }
                    setStartPoint(null);
                    return;
                }

                // Case 2: 描画の1クリック目 or 選択
                if (targetElement) {
                    setSelectedElementId(targetId);
                    return;
                }

                // Case 3: 背景クリック or 描画モードで空間上をクリック
                const snappedStartPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                if (drawingMode === 'text' || drawingMode === 'fixture') {
                    const newElement = drawingMode === 'text' ? {
                        id: `text-${Date.now()}`, type: 'text',
                        x: (snappedStartPoint.x / dimensions.width) * 100, y: (snappedStartPoint.y / dimensions.height) * 100,
                        text: "テキスト", color: strokeColor, fontSize: fontSize, fontFamily: fontFamily, textAlign: textAlign,
                    } : {
                        id: `fixture-${Date.now()}`, type: 'fixture',
                        x: (snappedStartPoint.x / dimensions.width) * 100, y: (snappedStartPoint.y / dimensions.height) * 100,
                        templateId: fixtureTemplateId,
                        size: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultSize,
                        fill: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultFill,
                        stroke: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultStroke,
                        strokeWidth: (FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {}).defaultStrokeWidth,
                    };
                    setHistoryState(prevState => ({
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: [...prevState.present.svgElements, newElement] },
                        future: []
                    }));
                    setSelectedElementId(newElement.id);
                } else {
                    setStartPoint(snappedStartPoint);
                    setSelectedElementId(null);
                }
            }, [getCanvasCoords, svgElements, drawingMode, startPoint, isGridVisible, getGridSnappedPoint, dimensions, strokeColor, fontSize, fontFamily, textAlign, fixtureTemplateId, fixtureCategory, spaceType, fillColor, strokeWidth, lineStyle, compassTemplateId, doorTemplateId, windowTemplateId, findAndCreateFill, endpointSnap, getAngleSnappedPoint, spaceShape]);

            // SVG上でのマウスダウン処理
            const handleMouseDown = useCallback((e) => {
                e.stopPropagation();
                mouseDownInfo.current = { x: e.clientX, y: e.clientY };

                const startPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);

                if (targetElement) {
                    setIsDragging(true);
                    setSelectedElementId(targetId);
                    historyOnActionStart.current = historyState.present;
                    dragInfo.current = {
                        startMouseX: startPos.x,
                        startMouseY: startPos.y,
                        element: targetElement,
                        initialX: targetElement.x !== undefined ? targetElement.x / 100 * dimensions.width : null,
                        initialY: targetElement.y !== undefined ? targetElement.y / 100 * dimensions.height : null,
                        initialX1: targetElement.x1 !== undefined ? targetElement.x1 / 100 * dimensions.width : null,
                        initialY1: targetElement.y1 !== undefined ? targetElement.y1 / 100 * dimensions.height : null,
                        initialX2: targetElement.x2 !== undefined ? targetElement.x2 / 100 * dimensions.width : null,
                        initialY2: targetElement.y2 !== undefined ? targetElement.y2 / 100 * dimensions.height : null,
                    };
                } else {
                    setSelectedElementId(null);
                }
            }, [getCanvasCoords, svgElements, historyState.present, dimensions]);

            // ドキュメント全体でのマウス移動処理
            // ★★★【変更箇所】D&Dのロジックを更新 ★★★
            const handleMouseMove = useCallback((e) => {
                const currentPos = getCanvasCoords(e);
                setMousePos(currentPos);

                if (isDragging && dragInfo.current) {
                    const dx = currentPos.x - dragInfo.current.startMouseX;
                    const dy = currentPos.y - dragInfo.current.startMouseY;

                    const newElements = historyOnActionStart.current.svgElements.map(el => {
                        if (el.id === selectedElementId) {
                            const newEl = { ...el };
                            if (el.type === 'space' && el.shape === 'rect' || el.type === 'fixture' || el.type === 'text' || el.type === 'compass') {
                                let newPixelX = dragInfo.current.initialX + dx;
                                let newPixelY = dragInfo.current.initialY + dy;
                                if (isGridVisible) {
                                    const snapped = getGridSnappedPoint({ x: newPixelX, y: newPixelY });
                                    newPixelX = snapped.x;
                                    newPixelY = snapped.y;
                                }
                                newEl.x = (newPixelX / dimensions.width) * 100;
                                newEl.y = (newPixelY / dimensions.height) * 100;
                            } else if (el.type === 'space' && el.shape === 'line' || el.type === 'door' || el.type === 'window') {
                                let newX1 = dragInfo.current.initialX1 + dx;
                                let newY1 = dragInfo.current.initialY1 + dy;
                                let newX2 = dragInfo.current.initialX2 + dx;
                                let newY2 = dragInfo.current.initialY2 + dy;
                                if (isGridVisible) {
                                    const snapped1 = getGridSnappedPoint({ x: newX1, y: newY1 });
                                    const snapped2 = getGridSnappedPoint({ x: newX2, y: newY2 });
                                    newX1 = snapped1.x; newY1 = snapped1.y;
                                    newX2 = snapped2.x; newY2 = snapped2.y;
                                }
                                newEl.x1 = (newX1 / dimensions.width) * 100;
                                newEl.y1 = (newY1 / dimensions.height) * 100;
                                newEl.x2 = (newX2 / dimensions.width) * 100;
                                newEl.y2 = (newY2 / dimensions.height) * 100;
                                
                                // ドアと窓の移動時に長さと角度を再計算
                                if (el.type === 'door' || el.type === 'window') {
                                    const newDx = newX2 - newX1;
                                    const newDy = newY2 - newY1;
                                    newEl.length = Math.sqrt(newDx * newDx + newDy * newDy);
                                    newEl.baseAngle = Math.atan2(newDy, newDx) * 180 / Math.PI;
                                }
                            }
                            return newEl;
                        }
                        return el;
                    });
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                }
                
                if (!isDragging && !isGridVisible) {
                    let snappedToEndpoint = null;
                    for (const el of svgElements) {
                         if (el.type === 'space' && el.shape === 'line') {
                            const p1 = { x: el.x1 / 100 * dimensions.width, y: el.y1 / 100 * dimensions.height };
                            const p2 = { x: el.x2 / 100 * dimensions.width, y: el.y2 / 100 * dimensions.height };
                            const dist1 = Math.sqrt(Math.pow(currentPos.x - p1.x, 2) + Math.pow(currentPos.y - p1.y, 2));
                            const dist2 = Math.sqrt(Math.pow(currentPos.x - p2.x, 2) + Math.pow(currentPos.y - p2.y, 2));
                            if (dist1 < SNAP_THRESHOLD / zoom) { snappedToEndpoint = p1; break; }
                            if (dist2 < SNAP_THRESHOLD / zoom) { snappedToEndpoint = p2; break; }
                        }
                    }
                    setEndpointSnap(snappedToEndpoint);
                }
            }, [isDragging, getCanvasCoords, selectedElementId, isGridVisible, getGridSnappedPoint, dimensions, zoom, SNAP_THRESHOLD, svgElements]);

            // ドキュメント全体でのマウスアップ処理
            const handleMouseUp = useCallback((e) => {
                const wasDragging = isDragging;

                if (isDragging) {
                    if (dragInfo.current && JSON.stringify(historyOnActionStart.current.svgElements) !== JSON.stringify(svgElements)) {
                        setHistoryState(prev => ({
                            ...prev,
                            past: [...prev.past, historyOnActionStart.current],
                            future: []
                        }));
                    }
                }

                const wasClick = mouseDownInfo.current && (Math.sqrt((e.clientX - mouseDownInfo.current.x)**2 + (e.clientY - mouseDownInfo.current.y)**2) < 5);

                if (wasClick && !wasDragging) {
                    handleCanvasClick(e);
                }
                
                setIsDragging(false);
                dragInfo.current = null;
                historyOnActionStart.current = null;
                mouseDownInfo.current = null;
            }, [isDragging, svgElements, handleCanvasClick]);

            // 現在選択されているSVG要素を削除する
            const deleteSelectedElement = useCallback(() => {
                if (!selectedElementId) return;
                setHistoryState(prevState => {
                    const newSvgElements = prevState.present.svgElements.filter(el => el.id !== selectedElementId);
                    const finalSvgElements = newSvgElements.filter(el => !(el.type === 'fill' && selectedElement && el.spaceType === selectedElement.spaceType));
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: finalSvgElements },
                        future: []
                    };
                });
                setSelectedElementId(null);
            }, [selectedElementId, selectedElement]);

            // 元に戻す機能
            const handleUndo = useCallback(() => {
                setHistoryState(prevState => {
                    const past = [...prevState.past];
                    const newPresent = past.pop();
                    if (!newPresent) return prevState;
                    return {
                        past: past,
                        present: newPresent,
                        future: [prevState.present, ...prevState.future]
                    };
                });
            }, []);

            // やり直す機能
            const handleRedo = useCallback(() => {
                setHistoryState(prevState => {
                    const future = [...prevState.future];
                    const newPresent = future.shift();
                    if (!newPresent) return prevState;
                    return {
                        past: [...prevState.past, prevState.present],
                        present: newPresent,
                        future: future
                    };
                });
            }, []);

            // 選択された要素を90度回転させる
            const rotateSelectedElement90Degrees = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window' || selectedElement.type === 'compass')) {
                    const newRotation = ((selectedElement.rotation || 0) + 90) % 360;
                    handleSelectedElementUpdate('rotation', newRotation);
                }
            }, [selectedElement, handleSelectedElementUpdate]);

            // 選択されたドア/窓の開閉方向を切り替える
            const toggleSelectedElementSwingDirection = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window')) {
                    const newIsInner = !selectedElement.isInner;

                    setHistoryState(prevState => {
                        const updatedElements = prevState.present.svgElements.map(el => {
                            if (el.id === selectedElementId) {
                                return { ...el, isInner: newIsInner };
                            }
                            return el;
                        });
                        return {
                            past: [...prevState.past, prevState.present],
                            present: { ...prevState.present, svgElements: updatedElements },
                            future: []
                        };
                    });
                }
            }, [selectedElement, selectedElementId]);

            // 現在の描画を画像として保存する
            const handleSaveImage = (format) => {
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = dimensions.width;
                exportCanvas.height = dimensions.height;
                const ctx = exportCanvas.getContext('2d');

                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                const svgString = new XMLSerializer().serializeToString(svgRef.current);
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                const svgImage = new Image();

                svgImage.onload = () => {
                    ctx.drawImage(svgImage, 0, 0);
                    URL.revokeObjectURL(url);

                    const link = document.createElement('a');
                    const today = new Date();
                    const yyyy = today.getFullYear();
                    const mm = String(today.getMonth() + 1).padStart(2, '0');
                    const dd = String(today.getDate()).padStart(2, '0');
                    const filename = `floorplan_${yyyy}${mm}${dd}.${format}`;

                    link.download = filename;
                    if (format === 'png') {
                        link.href = exportCanvas.toDataURL('image/png');
                        link.click();
                    } else if (format === 'pdf') {
                        console.warn("PDF保存機能は現在開発中です。PNGで保存します。");
                        link.href = exportCanvas.toDataURL('image/png');
                        link.click();
                    }
                };
                svgImage.src = url;
            };

            // --- useEffectフック ---
            
            useEffect(() => {
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [handleMouseMove, handleMouseUp]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (currentOcrData?.Blocks) {
                    currentOcrData.Blocks.forEach(block => {
                        const geo = block.Geometry.BoundingBox;
                        const rectX = geo.Left * dimensions.width, rectY = geo.Top * dimensions.height;
                        const rectWidth = geo.Width * dimensions.width, rectHeight = geo.Height * dimensions.height;
                        const isSelected = block.id === selectedBlockId;

                        ctx.fillStyle = isSelected ? "blue" : "red";
                        ctx.font = "16px Arial";
                        ctx.fillText(block.Text, rectX, rectY - 5);
                        ctx.strokeStyle = isSelected ? "rgba(0, 0, 255, 0.9)" : "rgba(255, 0, 0, 0.7)";
                        ctx.lineWidth = isSelected ? 3 : 2;
                        ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
                    });
                }
                if (endpointSnap && !isGridVisible) {
                    ctx.beginPath();
                    ctx.arc(endpointSnap.x, endpointSnap.y, SNAP_THRESHOLD / zoom, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.fill();
                }
            }, [currentOcrData, selectedBlockId, dimensions, endpointSnap, zoom, isGridVisible]);

            useEffect(() => {
                if (editorAreaRef.current) {
                    const area = editorAreaRef.current;
                    const timer = setTimeout(() => {
                        area.scrollTop = (area.scrollHeight - area.clientHeight) / 2;
                        const scrollLeftCenter = (area.scrollWidth - area.clientWidth) / 2;
                        const sidebarWidth = 320;
                        const newScrollLeft = isSidebarOpen ? scrollLeftCenter - (sidebarWidth / 2) : scrollLeftCenter;
                        area.scrollLeft = newScrollLeft;
                    }, 0);
                    return () => clearTimeout(timer);
                }
            }, [imageUrl, isSidebarOpen]);

            useEffect(() => {
                setFillColor(DEFAULT_FILL_COLORS[spaceType] || '#ffffff');
            }, [spaceType]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); handleUndo(); }
                    else if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); handleRedo(); }
                    else if (e.key === 'Delete' && selectedElementId) { e.preventDefault(); deleteSelectedElement(); }
                    else if (e.key === 'Escape') {
                        setStartPoint(null);
                        setSelectedElementId(null);
                        setSelectedBlockId(null);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleUndo, handleRedo, deleteSelectedElement, selectedElementId]);

            useEffect(() => {
                const editorArea = editorAreaRef.current;
                if (!editorArea) return;
                const handleWheel = (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        setZoom(prevZoom => Math.max(0.2, Math.min(3, prevZoom + delta)));
                    }
                };
                editorArea.addEventListener('wheel', handleWheel, { passive: false });
                return () => editorArea.removeEventListener('wheel', handleWheel);
            }, []);

            useEffect(() => {
                setStartPoint(null);
                setSelectedElementId(null);
                setSelectedBlockId(null);
            }, [drawingMode, spaceEditMode, spaceShape]);

            useEffect(() => {
                if (!isDisplaySettingsOpen) return;
                function handleClickOutside(event) {
                    if (isSidebarOpen && displaySettingsRef.current && !displaySettingsRef.current.contains(event.target)) {
                        setDisplaySettingsOpen(false);
                    }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [isDisplaySettingsOpen, isSidebarOpen]);

            const getCursorClass = () => {
                if (isDragging) return 'cursor-grabbing';
                if (drawingMode !== 'select' && spaceEditMode !== 'edit') return 'cursor-crosshair';
                return 'cursor-default';
            };

            // --- レンダリング ---
            return (
                <div className="flex flex-col h-screen">
                    {/* ヘッダーセクション */}
                    <header className="bg-white shadow-md p-2 flex items-center justify-between z-30 flex-shrink-0">
                        <span className="text-xl font-bold text-gray-800 ml-4">間取り図エディタ</span>
                        <div className="flex items-center space-x-4">
                            <button onClick={() => handleSaveImage('png')} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">PNGで保存</button>
                            <button onClick={() => handleSaveImage('pdf')} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">PDFで保存</button>
                            <button onClick={handleUndo} disabled={historyState.past.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">戻る</button>
                            <button onClick={handleRedo} disabled={historyState.future.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">進む</button>
                            <div className="flex items-center space-x-2">
                                <button onClick={() => setZoom(z => Math.max(0.2, z - 0.1))} className="px-3 py-1 bg-gray-200 rounded">-</button>
                                <span>{Math.round(zoom * 100)}%</span>
                                <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="px-3 py-1 bg-gray-200 rounded">+</button>
                            </div>
                        </div>
                    </header>

                    {/* メインコンテンツエリア（エディタ＋サイドバー） */}
                    <div className="flex-1 relative overflow-hidden">
                        <main ref={editorAreaRef} className="editor-area w-full h-full bg-gray-200">
                            <div className="scroll-wrapper">
                                <div className="editor-container" style={{ width: dimensions.width, height: dimensions.height, transform: `translate(-50%, -50%) scale(${zoom})`, ...(isGridVisible && { backgroundImage: `linear-gradient(to right, #f3f4f6 1px, transparent 1px), linear-gradient(to bottom, #f3f4f6 1px, transparent 1px)`, backgroundSize: `${gridSize}px ${gridSize}px` }) }}>
                                    {imageUrl && <img ref={imageRef} src={imageUrl} alt="間取り図" className="editor-image" style={{ opacity: imageOpacity, transform: `translate(-50%, -50%) scale(${imageScale})` }} crossOrigin="anonymous"/>}
                                    <canvas ref={canvasRef} className={getCursorClass()} width={dimensions.width} height={dimensions.height} />
                                    <svg ref={svgRef} className="editor-svg" width={dimensions.width} height={dimensions.height} xmlns="http://www.w3.org/2000/svg" style={{ opacity: drawingOpacity }} onMouseDown={handleMouseDown}>
                                        {/* ★★★【変更箇所】すべてのSVG要素のD&Dを有効化 ★★★ */}
                                        {svgElements.map(el => {
                                            const isSelected = el.id === selectedElementId;
                                            const stroke = isSelected ? SELECTED_ELEMENT_COLOR : (el.color || DEFAULT_STROKE_COLOR);
                                            const strokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                            const style = LINE_STYLES.find(s => s.id === el.lineStyle);
                                            
                                            const pointerEvents = (drawingMode !== 'space' && el.type === 'space') ? 'none' : 'all';

                                            if (el.shape === 'rect' && el.type === 'space') {
                                                return <rect key={el.id} data-id={el.id} x={`${el.x}%`} y={`${el.y}%`} width={`${el.width}%`} height={`${el.height}%`} fill={el.fill} stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} style={{ pointerEvents }} />;
                                            }
                                            if (el.shape === 'line' && el.type === 'space') {
                                                const p1 = { x: el.x1 / 100 * dimensions.width, y: el.y1 / 100 * dimensions.height };
                                                const p2 = { x: el.x2 / 100 * dimensions.width, y: el.y2 / 100 * dimensions.height };
                                                if (el.lineStyle === 'wavy') {
                                                    return <path key={el.id} data-id={el.id} d={generateWavyPathD(p1, p2)} stroke={stroke} strokeWidth={strokeW} fill="none" style={{ pointerEvents }} />;
                                                }
                                                return <line key={el.id} data-id={el.id} x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} strokeLinecap="square" style={{ pointerEvents }} />;
                                            }
                                            if (el.type === 'fill') {
                                                return <polygon key={el.id} data-id={el.id} points={el.points} fill={el.fill} stroke="none" style={{pointerEvents: 'none'}} />;
                                            }
                                            if (el.type === 'text') {
                                                let textAnchor = 'start';
                                                if (el.textAlign === 'center') textAnchor = 'middle';
                                                else if (el.textAlign === 'right') textAnchor = 'end';
                                                return (
                                                    <text key={el.id} data-id={el.id} x={`${el.x}%`} y={`${el.y}%`} fill={el.color} fontSize={el.fontSize} fontFamily={el.fontFamily} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}} textAnchor={textAnchor}>
                                                        {el.text.split('\n').map((line, i) => (
                                                            <tspan key={i} x={`${el.x}%`} dy={i === 0 ? 0 : '1.2em'}>{line}</tspan>
                                                        ))}
                                                    </text>
                                                );
                                            }
                                            if (el.type === 'compass') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const template = COMPASS_TEMPLATES.find(t => t.id === el.templateId) || COMPASS_TEMPLATES[0];
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <image href={template.src} x={-el.size / 2} y={-el.size / 2} width={el.size} height={el.size} preserveAspectRatio="xMidYMid meet" />
                                                        {isSelected && <rect x={-el.size/2 - 2} y={-el.size/2 - 2} width={el.size + 4} height={el.size + 4} fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2" />}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'fixture') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === el.templateId))] || FIXTURE_TEMPLATES.kitchen;
                                                const template = templateCategory.find(t => t.id === el.templateId) || FIXTURE_TEMPLATES.kitchen[0];
                                                const scaleFactor = el.size / template.defaultSize;
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) scale(${scaleFactor})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <path d={template.path} fill={el.fill} stroke={el.stroke} strokeWidth={el.strokeWidth} />
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'door' || el.type === 'window') {
                                                const p1 = { x: el.x1 / 100 * dimensions.width, y: el.y1 / 100 * dimensions.height };
                                                const template = el.type === 'door' ? (DOOR_TEMPLATES.find(t => t.id === el.templateId) || DOOR_TEMPLATES[0]) : (WINDOW_TEMPLATES.find(t => t.id === el.templateId) || WINDOW_TEMPLATES[0]);
                                                const totalRotation = el.baseAngle + (el.rotation || 0);
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${p1.x}, ${p1.y}) rotate(${totalRotation})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <path d={template.path(el.length, el.swingDirection, el.isInner, el.wallThickness)} fill="none" stroke={stroke} strokeWidth={strokeW} strokeLinecap="square" />
                                                    </g>
                                                );
                                            }
                                            return null;
                                        })}
                                        {startPoint && (
                                            <>
                                                {drawingMode === 'space' && spaceShape === 'rect' && (() => {
                                                    const previewEndPoint = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                                    return <rect x={Math.min(startPoint.x, previewEndPoint.x)} y={Math.min(startPoint.y, previewEndPoint.y)} width={Math.abs(startPoint.x - previewEndPoint.x)} height={Math.abs(startPoint.y - previewEndPoint.y)} fill="transparent" stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="5,5" style={{ pointerEvents: 'none' }} />;
                                                })()}
                                                {drawingMode === 'space' && spaceShape === 'line' && (() => {
                                                    let previewEndPoint = mousePos;
                                                    if (isGridVisible) {
                                                        previewEndPoint = getGridSnappedPoint(mousePos);
                                                    } else {
                                                        previewEndPoint = endpointSnap || getAngleSnappedPoint(startPoint, mousePos);
                                                    }
                                                    return <line x1={startPoint.x} y1={startPoint.y} x2={previewEndPoint.x} y2={previewEndPoint.y} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray={LINE_STYLES.find(s => s.id === lineStyle)?.dashArray || 'none'} style={{ pointerEvents: 'none' }} />;
                                                })()}
                                                {drawingMode === 'compass' && (() => {
                                                    const template = COMPASS_TEMPLATES.find(t => t.id === compassTemplateId) || COMPASS_TEMPLATES[0];
                                                    const dx = mousePos.x - startPoint.x;
                                                    const dy = mousePos.y - startPoint.y;
                                                    const distance = Math.sqrt(dx*dx + dy*dy);
                                                    const size = Math.min(300, Math.max(20, distance));
                                                    const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                                                    return (
                                                        <g transform={`translate(${startPoint.x}, ${startPoint.y}) rotate(${rotation})`} style={{ pointerEvents: 'none' }}>
                                                            <image href={template.src} x={-size / 2} y={-size / 2} width={size} height={size} preserveAspectRatio="xMidYMid meet" opacity="0.7"/>
                                                        </g>
                                                    );
                                                })()}
                                                {(drawingMode === 'door' || drawingMode === 'window') && (() => {
                                                    const previewEndPoint = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                                    return <line x1={startPoint.x} y1={startPoint.y} x2={previewEndPoint.x} y2={previewEndPoint.y} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="5,5" style={{ pointerEvents: 'none' }} />;
                                                })()}
                                            </>
                                        )}
                                    </svg>
                                </div>
                            </div>
                        </main>

                        {/* サイドバートグルボタン */}
                        <button onClick={() => setSidebarOpen(!isSidebarOpen)} className={`absolute top-16 z-20 bg-indigo-600 hover:bg-indigo-700 text-white w-6 h-12 flex items-center justify-center rounded-r-lg cursor-pointer transition-all duration-300 ease-in-out focus:outline-none ${isSidebarOpen ? 'left-80' : 'left-0'}`} aria-label={isSidebarOpen ? "サイドバーを閉じる" : "サイドバーを開く"}>
                            {isSidebarOpen ? '◀' : '▶'}
                        </button>

                        {/* サイドバーコンテンツ */}
                        <aside className={`absolute top-0 left-0 h-full w-80 bg-gray-50 p-4 space-y-4 z-10 transform transition-transform duration-300 ease-in-out ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`} style={{overflowY: 'auto'}}>
                            {/* ...サイドバーの中身は変更なし... */}
                            <div ref={displaySettingsRef}>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDisplaySettingsOpen(!isDisplaySettingsOpen)}>
                                    <span>表示設定</span>
                                    <span className="text-gray-400">{isDisplaySettingsOpen ? '▼' : '▶'}</span>
                                </h2>
                                {isDisplaySettingsOpen && (
                                    <div className="mt-2 space-y-4">
                                        <div>
                                            <label className="cursor-pointer block w-full text-sm text-center text-blue-700 bg-blue-50 hover:bg-blue-100 font-semibold py-2 px-4 rounded-full">
                                                下絵を選択<input type="file" onChange={handleFileChange} accept="image/*" className="hidden"/>
                                            </label>
                                        </div>
                                        <div>
                                            <label htmlFor="image-scale-slider" className="block text-sm font-medium text-gray-700">下絵のサイズ: {Math.round(imageScale * 100)}%</label>
                                            <input id="image-scale-slider" type="range" min="0.1" max="3" step="0.1" value={imageScale} onChange={(e) => setImageScale(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                        </div>
                                        <div>
                                            <label htmlFor="opacity-slider" className="block text-sm font-medium text-gray-700">下絵の透明度: {Math.round(imageOpacity * 100)}%</label>
                                            <input id="opacity-slider" type="range" min="0" max="1" step="0.05" value={imageOpacity} onChange={(e) => setImageOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                        </div>
                                        <div>
                                            <label htmlFor="drawing-opacity-slider" className="block text-sm font-medium text-gray-700">レイヤーの透明度: {Math.round(drawingOpacity * 100)}%</label>
                                            <input id="drawing-opacity-slider" type="range" min="0" max="1" step="0.05" value={drawingOpacity} onChange={(e) => setDrawingOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                        </div>
                                        <div className="flex items-center">
                                            <input id="grid-toggle" type="checkbox" checked={isGridVisible} onChange={() => setGridVisible(!isGridVisible)} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                            <label htmlFor="grid-toggle" className="ml-2 block text-sm font-medium text-gray-700">グリッド線を表示</label>
                                        </div>
                                        {isGridVisible && (
                                            <div>
                                                <label htmlFor="grid-size-slider" className="block text-sm font-medium text-gray-700">グリッドサイズ: {gridSize}px</label>
                                                <input id="grid-size-slider" type="range" min="5" max="50" step="1" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            <hr/>
                            <div>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDrawingToolsOpen(!isDrawingToolsOpen)}>
                                    <span>図形描画</span>
                                    <span className="text-gray-400">{isDrawingToolsOpen ? '▼' : '▶'}</span>
                                </h2>
                                {isDrawingToolsOpen && (
                                    <div className="mt-2">
                                        <div className="grid grid-cols-3 gap-2">
                                            {['space', 'door', 'window', 'fixture', 'compass', 'text'].map(mode => {
                                                const names = {'space':'空間','door':'ドア','window':'窓','fixture':'設備','compass':'方角','text':'文字'};
                                                const isDisabled = false;
                                                return <button key={mode} onClick={() => setDrawingMode(mode)} disabled={isDisabled} className={`px-2 py-2 rounded text-sm ${drawingMode === mode ? 'bg-indigo-600 text-white' : 'bg-gray-200'} ${isDisabled ? 'text-gray-400 cursor-not-allowed' : ''}`}>{names[mode]}</button>
                                            })}
                                        </div>

                                        {drawingMode === 'space' && (
                                            <div className="mt-4">
                                                <div className="flex bg-gray-200 rounded-lg p-1">
                                                    <button onClick={() => setSpaceEditMode('create')} className={`w-full py-1 rounded-md text-sm ${spaceEditMode === 'create' ? 'bg-white shadow' : ''}`}>作成</button>
                                                    <button onClick={() => setSpaceEditMode('edit')} className={`w-full py-1 rounded-md text-sm ${spaceEditMode === 'edit' ? 'bg-white shadow' : ''}`}>編集</button>
                                                </div>

                                                {spaceEditMode === 'create' && (
                                                    <div className="mt-4 space-y-4">
                                                        <div>
                                                            <label htmlFor="space-type-select" className="block text-sm font-medium text-gray-700">空間タイプ</label>
                                                            <select id="space-type-select" value={spaceType} onChange={(e) => setSpaceType(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {SPACE_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                                            </select>
                                                        </div>
                                                        <div className="flex bg-gray-200 rounded-lg p-1">
                                                            <button onClick={() => setSpaceShape('rect')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'rect' ? 'bg-white shadow' : ''}`}>四角形</button>
                                                            <button onClick={() => setSpaceShape('line')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'line' ? 'bg-white shadow' : ''}`}>線</button>
                                                        </div>
                                                        <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} isRectShape={spaceShape === 'rect'}/>
                                                        <div>
                                                            <label htmlFor="stroke-width-slider" className="block text-sm font-medium text-gray-700">線の太さ: {strokeWidth}px</label>
                                                            <input id="stroke-width-slider" type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label htmlFor="stroke-color-picker" className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input id="stroke-color-picker" type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                            <div>
                                                                <label htmlFor="fill-color-picker" className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                <input type="color" value={fillColor} onChange={(e) => setFillColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}

                                                {spaceEditMode === 'edit' && selectedElement && (selectedElement.type === 'space') && (
                                                    <div className="mt-4 space-y-4">
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">空間タイプ</label>
                                                            <select value={selectedElement.spaceType} onChange={(e) => handleSelectedElementUpdate('spaceType', e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {SPACE_TYPES.map(type => <option key={type} value={type}>{type}</option>)}
                                                            </select>
                                                        </div>
                                                        <LineStyleSelector selectedStyle={selectedElement.lineStyle || 'solid'} onChange={(newStyle) => handleSelectedElementUpdate('lineStyle', newStyle)} isRectShape={selectedElement.shape === 'rect'}/>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH}px</label>
                                                            <input type="range" min="1" max="20" step="1" value={selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input type="color" value={selectedElement.color || DEFAULT_STROKE_COLOR} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                <input type="color" value={selectedElement.fill || '#ffffff'} onChange={(e) => handleSelectedElementUpdate('fill', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                        <div className="mt-6">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この空間を削除 (Delete)</button>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        {drawingMode === 'text' && (
                                            <div className="mt-4 space-y-4">
                                                <p className="text-sm text-gray-600">キャンバスをクリックしてテキストを配置します。</p>
                                                { selectedElement && selectedElement.type === 'text' ? (
                                                    <div>
                                                        <h3 className="text-md font-semibold mb-2">選択中のテキストを編集</h3>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">テキスト</label>
                                                            <textarea value={selectedElement.text} onChange={(e) => handleSelectedElementUpdate('text', e.target.value)} className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" rows="3"></textarea>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">フォント</label>
                                                            <select value={selectedElement.fontFamily} onChange={(e) => handleSelectedElementUpdate('fontFamily', e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)}
                                                            </select>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">フォントサイズ: {selectedElement.fontSize}px</label>
                                                            <input type="range" min="8" max="72" step="1" value={selectedElement.fontSize} onChange={(e) => handleSelectedElementUpdate('fontSize', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">文字色</label>
                                                                <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">配置</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1">
                                                                <button onClick={() => handleSelectedElementUpdate('textAlign', 'left')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button>
                                                                <button onClick={() => handleSelectedElementUpdate('textAlign', 'center')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button>
                                                                <button onClick={() => handleSelectedElementUpdate('textAlign', 'right')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button>
                                                            </div>
                                                        </div>
                                                        <div className="mt-6">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このテキストを削除 (Delete)</button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <>
                                                        <div>
                                                            <label htmlFor="font-family-select" className="block text-sm font-medium text-gray-700">フォント</label>
                                                            <select id="font-family-select" value={fontFamily} onChange={(e) => setFontFamily(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)}
                                                            </select>
                                                        </div>
                                                        <div>
                                                            <label htmlFor="font-size-slider" className="block text-sm font-medium text-gray-700">フォントサイズ: {fontSize}px</label>
                                                            <input id="font-size-slider" type="range" min="8" max="72" step="1" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label htmlFor="text-color-picker" className="block text-sm font-medium text-gray-700">文字色</label>
                                                                <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">配置</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1">
                                                                <button onClick={() => setTextAlign('left')} className={`w-full py-1 rounded-md text-sm ${textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button>
                                                                <button onClick={() => setTextAlign('center')} className={`w-full py-1 rounded-md text-sm ${textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button>
                                                                <button onClick={() => setTextAlign('right')} className={`w-full py-1 rounded-md text-sm ${textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button>
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        )}
                                        {drawingMode === 'compass' && (
                                            <div className="mt-4 space-y-4">
                                                <p className="text-sm text-gray-600">キャンバス上をクリックして始点を決め、もう一度クリックして終点を決めます。</p>
                                                {selectedElement && selectedElement.type === 'compass' ? (
                                                    <div>
                                                        <h3 className="text-md font-semibold mb-2">選択中の方角を編集</h3>
                                                        <CompassTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} />
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700 mt-2">サイズ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="300" step="1" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>

                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700 mt-2">回転</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="-180" max="180" step="1" value={selectedElement.rotation || 0} onChange={(e) => handleSelectedElementUpdate('rotation', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={Math.round(selectedElement.rotation || 0)} onChange={(e) => handleSelectedElementUpdate('rotation', parseInt(e.target.value) || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        
                                                        <div className="mt-6">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この方角を削除 (Delete)</button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <CompassTemplateSelector selectedTemplateId={compassTemplateId} onChange={setCompassTemplateId} />
                                                )}
                                            </div>
                                        )}
                                        {drawingMode === 'fixture' && (
                                            <div className="mt-4 space-y-4">
                                                <p className="text-sm text-gray-600">キャンバスをクリックして設備を配置します。</p>
                                                {selectedElement && selectedElement.type === 'fixture' ? (
                                                    <div>
                                                        <h3 className="text-md font-semibold mb-2">選択中の設備を編集</h3>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">カテゴリ</label>
                                                            <select value={fixtureCategory} onChange={(e) => setFixtureCategory(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {Object.keys(FIXTURE_TEMPLATES).map(cat => (
                                                                    <option key={cat} value={cat}>
                                                                        {cat === 'kitchen' ? 'キッチン' : cat === 'bathroom' ? '浴室' : cat === 'bedroom' ? '寝室' : cat === 'livingDining' ? 'リビング・ダイニング' : 'その他'}
                                                                    </option>
                                                                ))}
                                                            </select>
                                                        </div>
                                                        <FixtureTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} category={fixtureCategory} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">サイズ: {selectedElement.size}px</label>
                                                            <input type="range" min="10" max="100" step="5" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                <input type="color" value={selectedElement.fill} onChange={(e) => handleSelectedElementUpdate('fill', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input type="color" value={selectedElement.stroke} onChange={(e) => handleSelectedElementUpdate('stroke', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth}px</label>
                                                            <input type="range" min="1" max="10" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="mt-6">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この設備を削除 (Delete)</button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">カテゴリ</label>
                                                            <select value={fixtureCategory} onChange={(e) => setFixtureCategory(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                                                {Object.keys(FIXTURE_TEMPLATES).map(cat => (
                                                                    <option key={cat} value={cat}>
                                                                        {cat === 'kitchen' ? 'キッチン' : cat === 'bathroom' ? '浴室' : cat === 'bedroom' ? '寝室' : cat === 'livingDining' ? 'リビング・ダイニング' : 'その他'}
                                                                    </option>
                                                                ))}
                                                            </select>
                                                        </div>
                                                        <FixtureTemplateSelector selectedTemplateId={fixtureTemplateId} onChange={setFixtureTemplateId} category={fixtureCategory} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">デフォルトサイズ: {FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId)?.defaultSize || FIXTURE_TEMPLATES[fixtureCategory][0].defaultSize}px</label>
                                                            <input type="range" min="10" max="100" step="5" value={FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId)?.defaultSize || FIXTURE_TEMPLATES[fixtureCategory][0].defaultSize} disabled className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">デフォルト塗りつぶし色</label>
                                                                <input type="color" value={FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId)?.defaultFill || FIXTURE_TEMPLATES[fixtureCategory][0].defaultFill} disabled className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">デフォルト線の色</label>
                                                                <input type="color" value={FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId)?.defaultStroke || FIXTURE_TEMPLATES[fixtureCategory][0].defaultStroke} disabled className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        )}
                                        {drawingMode === 'door' && (
                                            <div className="mt-4 space-y-4">
                                                <p className="text-sm text-gray-600">キャンバス上を2回クリックしてドアを配置します。</p>
                                                {selectedElement && selectedElement.type === 'door' ? (
                                                    <div>
                                                        <h3 className="text-md font-semibold mb-2">選択中のドアを編集</h3>
                                                        <DoorTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth}px</label>
                                                            <input type="range" min="1" max="10" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                        <div className="mt-2 flex space-x-2">
                                                            <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button>
                                                            <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button>
                                                        </div>
                                                        <div className="mt-6">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このドアを削除 (Delete)</button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <DoorTemplateSelector selectedTemplateId={doorTemplateId} onChange={setDoorTemplateId} />
                                                )}
                                            </div>
                                        )}
                                        {drawingMode === 'window' && (
                                            <div className="mt-4 space-y-4">
                                                <p className="text-sm text-gray-600">キャンバス上を2回クリックして窓を配置します。</p>
                                                {selectedElement && selectedElement.type === 'window' ? (
                                                    <div>
                                                        <h3 className="text-md font-semibold mb-2">選択中の窓を編集</h3>
                                                        <WindowTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ: {selectedElement.strokeWidth}px</label>
                                                            <input type="range" min="1" max="10" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>
                                                        <div className="mt-2 flex space-x-2">
                                                            <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button>
                                                            <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button>
                                                        </div>
                                                        <div className="mt-6">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この窓を削除 (Delete)</button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <WindowTemplateSelector selectedTemplateId={windowTemplateId} onChange={setWindowTemplateId} />
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </aside>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<Editor />, document.getElementById('root'));
    </script>
</body>
</html>
