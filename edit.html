<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto間取り図</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1588.0.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
        }
        .accordion-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.7s ease-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-out;
            margin-top: 0 !important; /* 閉じている時はmarginをなくす */
        }
        .accordion-content-open {
            max-height: 1500px; /* 内容が十分収まる高さを指定 */
            opacity: 1;
            margin-top: 1rem !important; /* 開いている時はmarginを適用(mt-4相当) */
        }
        .arrow-icon {
            transition: transform 0.3s ease-in-out;
        }
        .arrow-icon-open {
            transform: rotate(0deg);
        }
        .arrow-icon-closed {
            transform: rotate(-90deg);
        }
        .editor-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        .scroll-wrapper {
            width: 5000px;
            height: 5000px;
            position: relative;
        }
        .editor-container {
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .editor-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            max-width: 100%;
            max-height: 100%;
        }
        .editor-canvas, .editor-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .editor-svg {
            pointer-events: all;
            user-select: none;          /* 標準のブラウザ */
            -webkit-user-select: none;  /* Chrome, Safari */
            -moz-user-select: none;     /* Firefox */
            -ms-user-select: none;      /* Internet Explorer/Edge */
        }
        .editor-svg > * {
            pointer-events: all;
        }
        .cursor-crosshair { cursor: crosshair; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-default { cursor: default; }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.4L159.2%2C69.7c-3.1-3.1-8.2-3.1-11.3%2C0L5.4%2C197.4c-3.1%2C3.1-3.1%2C8.2%2C0%2C11.3l11.3%2C11.3c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l115.4-115.4l115.4%2C115.4c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l11.3-11.3C290.1%2C205.6%2C290.1%2C200.5%2C287%2C197.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem 0.8rem;
            padding-right: 2.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
        }
        select:focus {
            border-color: #6366F1;
            box-shadow: 0 0 0 1px #6366F1;
            outline: none;
        }
        .transparent-bg {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useLayoutEffect } = React;

        // --- 定数とダミーデータ ---
        const DUMMY_OCR_DATA = {
            "Blocks": [
                { "id": "block-1", "type": "LDK", "Text": "LDK 12.5帖", "Geometry": { "BoundingBox": { "Width": 0.25, "Height": 0.05, "Left": 0.4, "Top": 0.5 }}},
                { "id": "block-2", "type": "洋室", "Text": "洋室 6.0帖", "Geometry": { "BoundingBox": { "Width": 0.2, "Height": 0.05, "Left": 0.1, "Top": 0.2 }}},
                { "id": "block-3", "type": "浴室", "Text": "浴室", "Geometry": { "BoundingBox": { "Width": 0.1, "Height": 0.04, "Left": 0.7, "Top": 0.2 }}},
                { "id": "block-4", "type": "収納", "Text": "WIC", "Geometry": { "BoundingBox": { "Width": 0.08, "Height": 0.04, "Left": 0.15, "Top": 0.4 }}}
            ]
        };
        const SPACE_TYPES = {
            main: ["LDK", "DK", "K", "居室", "和室", "収納", "洗面所", "浴室", "トイレ", "廊下", "玄関", "バルコニー"],
            sub: ["柱", "吹抜", "グルニエ", "折上天井", "床下収納", "カウンター", "棚", "下足入", "冷蔵庫", "洗濯機", "PS", "MB"]
        };
        const SPACE_STYLE_PRESETS = {
            // --- 主要な空間 ---
            "LDK":        { fill: "#fef3c7", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "DK":         { fill: "#fef3c7", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "K":          { fill: "#fef3c7", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "居室":       { fill: "#f5e5d4", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "和室":       { fill: "#dcfce7", background: 'grid-large',      lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "収納":       { fill: "#fef9c3", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "洗面所":     { fill: "#dbeafe", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "浴室":       { fill: "#dbeafe", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "トイレ":     { fill: "#dbeafe", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "廊下":       { fill: "rgb(245, 229, 212)", background: 'none', lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "玄関":       { fill: "#dedede", background: 'grid-small',      lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' },
            "バルコニー": { fill: "#f5f5f5", background: 'none',            lineStyle: 'double', strokeWidth: 6, strokeColor: '#808080' },
            // --- サブの空間 ---
            "柱":         { fill: "#000000", background: 'none',            lineStyle: 'solid',  strokeWidth: 1, strokeColor: '#000000' },
            "吹抜":       { fill: "none",    background: 'dotted-x',      lineStyle: 'dotted', strokeWidth: 6, strokeColor: '#000000' },
            "グルニエ":   { fill: "none",    background: 'dotted-x',      lineStyle: 'dotted', strokeWidth: 6, strokeColor: '#000000' },
            "折上天井":   { fill: "none",    background: 'dotted-x',      lineStyle: 'dotted', strokeWidth: 6, strokeColor: '#000000' },
            "床下収納":   { fill: "none",    background: 'dotted-x',      lineStyle: 'dotted', strokeWidth: 6, strokeColor: '#000000' },
            "カウンター": { fill: "#CD924C", background: 'none',            lineStyle: 'solid',  strokeWidth: 1, strokeColor: '#000000' },
            "棚":         { fill: "#CD924C", background: 'none',            lineStyle: 'solid',  strokeWidth: 1, strokeColor: '#000000' },
            "下足入":     { fill: "#CD924C", background: 'none',            lineStyle: 'solid',  strokeWidth: 1, strokeColor: '#000000' },
            "冷蔵庫":     { fill: "none",    background: 'none',            lineStyle: 'dotted', strokeWidth: 1, strokeColor: '#808080' },
            "洗濯機":     { fill: "none",    background: 'none',            lineStyle: 'dotted', strokeWidth: 1, strokeColor: '#808080' },
            "PS":         { fill: "#ffffff", background: 'none',         lineStyle: 'solid',  strokeWidth: 1, strokeColor: '#000000' },
            "MB":         { fill: "#ffffff", background: 'none',         lineStyle: 'solid',  strokeWidth: 1, strokeColor: '#000000' },
            // --- デフォルト設定 ---
            "default":    { fill: "#fafafa", background: 'none',            lineStyle: 'solid',  strokeWidth: 6, strokeColor: '#000000' }
        };
        const FONT_FAMILIES = [
            { id: 'sans-serif', name: 'ゴシック体' },
            { id: 'serif', name: '明朝体' },
            { id: 'monospace', name: '等幅フォント' },
            { id: 'cursive', name: '筆記体' }
        ];
        const SNAP_THRESHOLD = 10;
        const DEFAULT_WIDTH = 1200;
        const DEFAULT_HEIGHT = 900;
        const SELECTED_ELEMENT_COLOR = '#3b82f6';
        const DEFAULT_STROKE_COLOR = '#000000';
        const DEFAULT_STROKE_WIDTH = 6;
        const DEFAULT_STAIR_WIDTH = 50;
        const BASE_FIXTURE_DEFAULT_SIZE = 50; // 設備の基準サイズ

        const LINE_STYLES = [
            { id: 'solid', name: '実線', dashArray: 'none' },
            { id: 'dashed', name: '破線', dashArray: '10, 5' },
            { id: 'dotted', name: '点線', dashArray: '2, 5' },
            { id: 'chain', name: '一点鎖線', dashArray: '10, 4, 2, 4' },
            { id: 'double-chain', name: '二点鎖線', dashArray: '10, 4, 2, 4, 2, 4' },
            { id: 'double', name: '二重線', dashArray: null }
        ];
        
        const BACKGROUND_PATTERNS = [
            { id: 'none', name: 'なし' },
            { id: 'vertical-lines', name: '縦線' },
            { id: 'horizontal-lines', name: '横線' },
            { id: 'grid-small', name: '格子小' },
            { id: 'grid-large', name: '格子大' },
            { id: 'dotted-x', name: '点線バツ印' },
            { id: 'solid-x', name: '実線バツ印' },
            { id: 'dotted-triangle', name: '点線三角' },
            { id: 'solid-triangle', name: '実線三角' }
        ];

        const DEFAULT_FILL_COLORS = {
            "LDK": "#fef3c7", "DK": "#fef3c7", "K": "#fef3c7",
            "居室": "#f5e5d4",
            "和室": "#dcfce7",
            "収納": "#fef9c3",
            "洗面所": "#dbeafe",
            "浴室": "#dbeafe",
            "トイレ": "#dbeafe",
            "廊下": "rgb(245, 229, 212)",
            "玄関": "#dedede",
            "バルコニー": "#f5f5f5",
            "柱": "#000000",
            "吹抜": "none",
            "グルニエ": "none",
            "折上天井": "none",
            "床下収納": "none",
            "カウンター": "#CD924C",
            "棚": "#CD924C",
            "下足入": "#CD924C",
            "冷蔵庫": "none",
            "洗濯機": "none",
            "PS": "#ffffff",
            "MB": "#ffffff",
            "その他": "#fafafa"
        };
        
        const SUB_TYPE_PROPERTIES = {
            "吹抜": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "グルニエ": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "折上天井": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "冷蔵庫": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "洗濯機": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "床下収納": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "カウンター": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "棚": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "下足入": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "PS": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#ffffff' },
            "MB": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#ffffff' },
            "柱": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#000000' }
        };

        const COMPASS_TEMPLATES = [
            { id: 'dsynbol01', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol01.svg'},
            { id: 'dsynbol02', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol02.svg'},
            { id: 'dsynbol03', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol03.svg'},
            { id: 'dsynbol04', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol04.svg'},
            { id: 'dsynbol05', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol05.svg'},
            { id: 'dsynbol06', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol06.svg'},
            { id: 'dsynbol07', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol07.svg'},
            { id: 'dsynbol08', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol08.svg'},
            { id: 'dsynbol09', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol09.svg'},
            { id: 'dsynbol10', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol10.svg'},
            { id: 'dsynbol11', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol11.svg'}
        ];

        const FIXTURE_TEMPLATES = {
            kitchen: [
                { id: 'kitchen01-from-svg', name: 'キッチン01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen01.svg', defaultSize: 20, aspectRatio: 128 / 49, },
                { id: 'kitchen02-from-svg', name: 'キッチン02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen02.svg', defaultSize: 20, aspectRatio: 128 / 48, },
                { id: 'kitchen03-from-svg', name: 'キッチン03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen03.svg', defaultSize: 20, aspectRatio: 128 / 58, },
                { id: 'kitchen04-from-svg', name: 'キッチン04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen04.svg', defaultSize: 15, aspectRatio: 175 / 49, },
                { id: 'kitchen05-from-svg', name: 'キッチン05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen05.svg', defaultSize: 15, aspectRatio: 175 / 58, },
                { id: 'kitchen06-from-svg', name: 'キッチン06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen06.svg', defaultSize: 24, aspectRatio: 102 / 114, },
                { id: 'kitchen07-from-svg', name: 'キッチン07', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen07.svg', defaultSize: 21, aspectRatio: 124 / 114, },
                { id: 'kitchen08-from-svg', name: 'キッチン08', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen08.svg', defaultSize: 15, aspectRatio: 175 / 114, },
                { id: 'kitchen09-from-svg', name: 'キッチン09', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen09.svg', defaultSize: 15, aspectRatio: 174 / 85, },
                { id: 'kitchen10-from-svg', name: 'キッチン10', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen10.svg', defaultSize: 58, aspectRatio: 38 / 34, },
                { id: 'kitchen11-from-svg', name: 'キッチン11', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen11.svg', defaultSize: 36, aspectRatio: 61 / 34, },
                { id: 'kitchen12-from-svg', name: 'キッチン12', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen12.svg', defaultSize: 20, aspectRatio: 129 / 40, },
                { id: 'kitchen13-from-svg', name: 'キッチン13', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen13.svg', defaultSize: 21, aspectRatio: 128 / 115, },
                { id: 'kitchen14-from-svg', name: 'キッチン14', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen14.svg', defaultSize: 15, aspectRatio: 174 / 85, },
                { id: 'kitchen15-from-svg', name: 'キッチン15', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen15.svg', defaultSize: 55, aspectRatio: 50 / 31, },
                { id: 'kitchen16-from-svg', name: 'キッチン16', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen16.svg', defaultSize: 55, aspectRatio: 44 / 35, },
                { id: 'kitchen17-from-svg', name: 'キッチン17', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen17.svg', defaultSize: 55, aspectRatio: 48 / 32, },
                { id: 'kitchen18-from-svg', name: 'キッチン18', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/kitchen18.svg', defaultSize: 55, aspectRatio: 42 / 44, }
            ],
            washroom: [
                { id: 'washroom01-from-svg', name: '洗面01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen01.svg', defaultSize: 50, aspectRatio: 139 / 84, },
                { id: 'washroom02-from-svg', name: '洗面02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen02.svg', defaultSize: 50, aspectRatio: 126 / 85, },
                { id: 'washroom03-from-svg', name: '洗面03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen03.svg', defaultSize: 50, aspectRatio: 122 / 62, },
                { id: 'washroom04-from-svg', name: '洗面04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen04.svg', defaultSize: 50, aspectRatio: 121 / 102, },
                { id: 'washroom05-from-svg', name: '洗面05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen05.svg', defaultSize: 50, aspectRatio: 115 / 52, },
                { id: 'washroom06-from-svg', name: '洗面06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/senmen06.svg', defaultSize: 50, aspectRatio: 121 / 96, }
            
            ],
            bathroom: [
                { id: 'bathtub01-from-svg', name: 'お風呂01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo01.svg', defaultSize: 30, aspectRatio: 173 / 107, },
                { id: 'bathtub02-from-svg', name: 'お風呂02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo02.svg', defaultSize: 30, aspectRatio: 173 / 97, },
                { id: 'bathtub03-from-svg', name: 'お風呂03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo03.svg', defaultSize: 30, aspectRatio: 202 / 108, },
                { id: 'bathtub04-from-svg', name: 'お風呂04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo04.svg', defaultSize: 30, aspectRatio: 194 / 96, },
                { id: 'bathtub05-from-svg', name: 'お風呂05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo05.svg', defaultSize: 30, aspectRatio: 195 / 106, },
                { id: 'bathtub06-from-svg', name: 'お風呂06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo06.svg', defaultSize: 30, aspectRatio: 189 / 97, },
                { id: 'bathtub07-from-svg', name: 'お風呂07', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo07.svg', defaultSize: 30, aspectRatio: 185 / 95, },
                { id: 'bathtub08-from-svg', name: 'お風呂08', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo08.svg', defaultSize: 30, aspectRatio: 183 / 107, },
                { id: 'bathtub09-from-svg', name: 'お風呂09', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo09.svg', defaultSize: 80, aspectRatio: 78 / 62, },
                { id: 'bathtub10-from-svg', name: 'お風呂10', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/furo10.svg', defaultSize: 80, aspectRatio: 91 / 57, }
            ],
            toilet: [
                { id: 'toilet01-from-svg', name: 'トイレ01', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet01.svg', defaultSize: 100, aspectRatio: 76 / 140, },
                { id: 'toilet02-from-svg', name: 'トイレ02', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet02.svg', defaultSize: 80, aspectRatio: 87 / 122, },
                { id: 'toilet03-from-svg', name: 'トイレ03', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet03.svg', defaultSize: 80, aspectRatio: 82 / 121, },
                { id: 'toilet04-from-svg', name: 'トイレ04', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet04.svg', defaultSize: 100, aspectRatio: 78 / 136, },
                { id: 'toilet05-from-svg', name: 'トイレ05', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet05.svg', defaultSize: 100, aspectRatio: 74 / 121, },
                { id: 'toilet06-from-svg', name: 'トイレ06', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet06.svg', defaultSize: 100, aspectRatio: 76 / 121, },
                { id: 'toilet07-from-svg', name: 'トイレ07', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet07.svg', defaultSize: 100, aspectRatio: 75 / 131, },
                { id: 'toilet08-from-svg', name: 'トイレ08', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet08.svg', defaultSize: 100, aspectRatio: 66 / 116, },
                { id: 'toilet09-from-svg', name: 'トイレ09', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet09.svg', defaultSize: 100, aspectRatio: 80 / 122, },
                { id: 'toilet10-from-svg', name: 'トイレ10', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet10.svg', defaultSize: 70, aspectRatio: 126 / 61, },
                { id: 'toilet11-from-svg', name: 'トイレ11', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet11.svg', defaultSize: 100, aspectRatio: 69 / 75, },
                { id: 'toilet12-from-svg', name: 'トイレ12', src: 'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/toilet12.svg', defaultSize: 200, aspectRatio: 41 / 36, }
            
            ],
            livingDining: [
                { id: 'dining-table-round', name: '円形テーブル', path: 'M0,0 A15,15 0 1,0 0,0.001 Z', defaultSize: 40, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dining-table-rect', name: '長方形テーブル', path: 'M-25,-15 H25 V15 H-25 Z', defaultSize: 50, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-single', name: '一人掛けソファ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 V0 M10,-10 V0', defaultSize: 40, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-double', name: '二人掛けソファ', path: 'M-30,-10 H30 V10 H-30 Z M-25,-10 V0 M25,-10 V0', defaultSize: 60, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'tv-stand', name: 'テレビ台', path: 'M-20,-5 H20 V5 H-20 Z', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bookshelf', name: '本棚', path: 'M-15,-20 H15 V20 H-15 Z M-10,-15 H10 M-10,0 H10 M-10,15 H10', defaultSize: 45, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bedroom: [
                { id: 'bed-single', name: 'シングルベッド', path: 'M-20,-15 H20 V15 H-20 Z M-15,-15 H15 V-5 H-15 Z', defaultSize: 50, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bed-double', name: 'ダブルベッド', path: 'M-30,-20 H30 V20 H-30 Z M-25,-20 H25 V-5 H-25 Z', defaultSize: 60, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'closet', name: 'クローゼット', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20', defaultSize: 40, defaultFill: '#f5deb3', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dresser', name: 'ドレッサー', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'nightstand', name: 'ナイトスタンド', path: 'M-10,-10 H10 V10 H-10 Z', defaultSize: 20, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'wardrobe', name: 'ワードローブ', path: 'M-20,-25 H20 V25 H-20 Z M-15,-25 V25 M15,-25 V25', defaultSize: 50, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            other: [
                { id: 'desk', name: 'デスク', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 45, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'fireplace', name: '暖炉', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 L-10,0 L10,0 L10,-10', defaultSize: 30, defaultFill: '#a0a0a0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'piano', name: 'ピアノ', path: 'M-25,-10 H25 V10 H-25 Z M-20,-10 V0 M-15,-10 V0 M-10,-10 V0 M-5,-10 V0 M0,-10 V0 M5,-10 V0 M10,-10 V0 M15,-10 V0 M20,-10 V0', defaultSize: 50, defaultFill: '#303030', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ]
        };

        const FIXTURE_CATEGORIES = [
            { key: 'kitchen', name: 'キッチン' },
            { key: 'washroom', name: '洗面' },
            { key: 'bathroom', name: '浴室' },
            { key: 'toilet', name: 'トイレ' },
            { key: 'livingDining', name: 'リビング' },
            { key: 'bedroom', name: '寝室' },
            { key: 'other', name: 'その他' }
        ];

        const WINDOW_TEMPLATES = [
            // 1. シンプル1
            { 
                id: 'simple-1', 
                name: 'シンプル1',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z'
            },
            // 2. シンプル2
            { 
                id: 'simple-2', 
                name: 'シンプル2',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const overhang = 3; // はみ出し量
                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8'
            },
            // 3. スライド2枚
            {
                id: 'double-sliding',
                name: 'スライド2枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length / 2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M${length / 2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M0,${y_third_2} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${length / 2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M0,-1.7 H23 M17,1.7 H40'
            },
            // 4. スライド3枚
            {
                id: 'triple-sliding',
                name: 'スライド3枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_third_1 = length / 3;
                    const x_third_2 = length * 2 / 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_1} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_2} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M13.3,-8 V8 M26.7,-8 V8 M0,-1.7 H16.3 M10.3,1.7 H29.7 M23.7,-1.7 H40'
            },
            // 5. スライド4枚
            {
                id: 'quadruple-sliding',
                name: 'スライド4枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_quarter_1 = length / 4;
                    const x_quarter_2 = length / 2;
                    const x_quarter_3 = length * 3 / 4;

                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_3},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_1} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_2} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M10,-8 V8 M20,-8 V8 M30,-8 V8 M0,-1.7 H13 M7,1.7 H33 M27,-1.7 H40'
            },
            // 6. FIX窓
            { 
                id: 'fix', 
                name: 'FIX窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    return [
                        // 背景と外枠 (シンプル1と同じ)
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        
                        // 追加：中央の横線
                        { d: `M0,0 H${length}`, stroke: 'currentColor', strokeWidth: frameWidth }
                    ];
                },
                // プレビューも修正
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 H40'
            },
            // 7. 縦滑り出し窓
            {
                id: 'vertical-slide-out',
                name: '縦滑り出し窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;

                    // ▼▼▼【修正】isInnerに応じて角度と円弧の向きを変える ▼▼▼
                    const angle = (isInner ? 30 : -30) * Math.PI / 180; // 内開きか外開きか
                    const sweepFlag = isInner ? 1 : 0; // 円弧の描画方向

                    const new_x = length * Math.cos(angle);
                    const new_y = length * Math.sin(angle);

                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M0,0 H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M0,0 L${new_x},${new_y}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length},0 A${length},${length} 0 0 ${sweepFlag} ${new_x},${new_y}`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth, strokeDasharray: '4, 2' }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 H40 M0,0 L34.64,-20 M40,0 A40,40 0 0 0 34.64,-20'
            },
            // 8. 突き出し窓
            {
                id: 'awning-window',
                name: '突き出し窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const edge_inset = length / 8;
                    
                    // ▼▼▼【修正】isInnerに応じて開く方向を変える ▼▼▼
                    const open_dist = isInner ? length / 4 : -length / 4;

                    return [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M0,0 H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${edge_inset},0 L${length/2},${open_dist} L${length - edge_inset},0`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth, strokeDasharray: '4, 2' }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 H40 M5,0 L20,-10 L35,0'
            },
        ];

        const DOOR_TEMPLATES = [
            // 1. 片開きドア
            {
                id: 'single-swing',
                name: '片開きドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const y_center = 0;
                    
                    // isInnerフラグで開く方向（上/下）を制御
                    const openDoorY = isInner ? y_center + length : y_center - length;
                    
                    // ▼▼▼【修正点】ここのフラグを逆にしました▼▼▼
                    const sweepFlag = isInner ? 0 : 1; 
                    
                    return [
                        // 1. 壁に埋め込まれたドア枠
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'currentColor', strokeWidth: 1 },
                        // 2. 90度開いたドア本体（直線）
                        { d: `M${length},${y_center} L${length},${openDoorY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        // 3. 開閉軌跡を示す円弧
                        { d: `M0,${y_center} A${length},${length} 0 0 ${sweepFlag} ${length},${openDoorY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパスは変更なし
                previewPath: 'M0,-5 H40 V5 H0 Z M40,0 L40,-40 M0,0 A40,40 0 0 1 40,-40'
            },

            // 2. 両開きドア
            {
                id: 'double-swing',
                name: '両開きドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const y_center = 0;
                    const halfL = length / 2;

                    // isInnerフラグで開く方向を制御
                    const openDoorY = isInner ? y_center + halfL : y_center - halfL;
                    // 左右のドアで円弧の向きを逆にする
                    const sweepFlagLeft = isInner ? 1 : 0;
                    const sweepFlagRight = isInner ? 0 : 1;

                    return [
                        // 1. 壁に埋め込まれた共通のドア枠
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'currentColor', strokeWidth: 1 },
                        
                        // 2. 左側のドア本体と軌跡
                        { d: `M0,${y_center} L0,${openDoorY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${halfL},${y_center} A${halfL},${halfL} 0 0 ${sweepFlagLeft} 0,${openDoorY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' },

                        // 3. 右側のドア本体と軌跡
                        { d: `M${length},${y_center} L${length},${openDoorY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${halfL},${y_center} A${halfL},${halfL} 0 0 ${sweepFlagRight} ${length},${openDoorY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパス
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 L0,-20 M20,0 A20,20 0 0 0 0,-20 M40,0 L40,-20 M20,0 A20,20 0 0 1 40,-20'
            },

            // 3. 親子ドア
            {
                id: 'uneven-double-swing',
                name: '親子ドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const y_center = 0;
                    
                    // 全体を2:1の比率に分割
                    const parentL = length * 2 / 3;
                    const childL = length * 1 / 3;
                    const pivotX = parentL; // 親ドアと子ドアの境界

                    // isInnerフラグで開く方向を制御
                    const openParentY = isInner ? y_center + parentL : y_center - parentL;
                    const openChildY = isInner ? y_center + childL : y_center - childL;

                    // 左右のドアで円弧の向きを逆にする
                    const sweepFlagParent = isInner ? 1 : 0;
                    const sweepFlagChild = isInner ? 0 : 1;

                    return [
                        // 1. 壁に埋め込まれた共通のドア枠
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'currentColor', strokeWidth: 1 },
                        
                        // 2. 親ドア（大きい方）の本体と軌跡
                        { d: `M0,${y_center} L0,${openParentY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${pivotX},${y_center} A${parentL},${parentL} 0 0 ${sweepFlagParent} 0,${openParentY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' },

                        // 3. 子ドア（小さい方）の本体と軌跡
                        { d: `M${length},${y_center} L${length},${openChildY}`, stroke: 'currentColor', strokeWidth: 1.5 },
                        { d: `M${pivotX},${y_center} A${childL},${childL} 0 0 ${sweepFlagChild} ${length},${openChildY}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパス (幅40を 27:13 に分割)
                previewPath: 'M0,-5 H40 V5 H0 Z M0,0 L0,-27 M27,0 A27,27 0 0 0 0,-27 M40,0 L40,-13 M27,0 A13,13 0 0 1 40,-13'
            },

            // 4. スライド1枚 (白抜き範囲を修正)
            {
                id: 'single-sliding',
                name: 'スライド1枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const frameWidth = 1;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const overhang = 3; 
                    const lineY = y_bottom;

                    const doorStartX = isInner ? 0 : length / 2;
                    const doorEndX = doorStartX + length / 2;
                    let doorPath;
                    if (isInner) {
                        doorPath = `M${doorStartX},${y_bottom} V${y_top} H${doorEndX}`;
                    } else {
                        doorPath = `M${doorEndX},${y_bottom} H${doorStartX} V${y_top}`;
                    }

                    let extensionStartX, extensionEndX;
                    if (isInner) { 
                        extensionStartX = length;
                        extensionEndX = length * 2;
                    } else { 
                        extensionStartX = 0;
                        extensionEndX = -length;
                    }
                    
                    const dashes = [];
                    const dashLength = 5;
                    const gapLength = 5;
                    const patternLength = dashLength + gapLength;
                    for (let i = 0; i < length; i += patternLength) {
                        let startX, endX;
                        if (isInner) {
                            startX = extensionStartX + i;
                            endX = Math.min(startX + dashLength, extensionEndX);
                        } else {
                            startX = extensionStartX - i;
                            endX = Math.max(startX - dashLength, extensionEndX);
                        }
                        dashes.push({
                            d: `M${startX},${lineY} H${endX}`,
                            stroke: 'currentColor',
                            strokeWidth: 1.5
                        });
                    }

                    return [
                        // 1. 最下層：ドア枠の背景
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        
                        // ▼▼▼【ここから修正】「太い白線」を「白い長方形」に変更 ▼▼▼
                        // 2. 白抜き用の背景長方形 (ドアの中心線から下枠まで)
                        { 
                            d: `M${extensionStartX},0 H${extensionEndX} V${y_bottom} H${extensionStartX} Z`,
                            fill: 'white',
                            stroke: 'none'
                        },
                        // ▲▲▲【ここまで修正】▲▲▲

                        // 3. 中間層：ドア枠の線と、ドア本体の線
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: doorPath, fill: 'none', stroke: 'currentColor', strokeWidth: 1.5 },
                        
                        // 4. 最上層：中央の縦線と、黒い点線
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ...dashes
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M40,5 H80'
            },
            
            // 5. スライド2枚 (横線の位置を修正)
            {
                id: 'double-sliding',
                name: 'スライド2枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${length / 2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M${length / 2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M0,${y_third_2} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${length / 2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${length / 2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth }
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M0,-1.7 H23 M17,1.7 H40'
            },

            // 6. スライド3枚 (横線の位置を修正)
            {
                id: 'triple-sliding',
                name: 'スライド3枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_third_1 = length / 3;
                    const x_third_2 = length * 2 / 3;
                    
                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_third_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_1} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_third_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_1 - h_overhang},${y_third_2} H${x_third_2 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_third_2 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M13.3,-8 V8 M26.7,-8 V8 M0,-1.7 H16.3 M10.3,1.7 H29.7 M23.7,-1.7 H40'
            },

            // 7. スライド4枚 (横線の位置を修正)
            {
                id: 'quadruple-sliding',
                name: 'スライド4枚',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const inset = 0.5;
                    const effective_wt = Math.max(0, wt - inset);
                    const frameWidth = 1;
                    const y_top = -effective_wt / 2;
                    const y_bottom = effective_wt / 2;
                    const v_overhang = 3;
                    const h_overhang = 3;
                    const x_quarter_1 = length / 4;
                    const x_quarter_2 = length / 2;
                    const x_quarter_3 = length * 3 / 4;

                    // ▼▼▼【修正点】Y座標を均等に3等分する位置に変更 ▼▼▼
                    const y_third_1 = y_top + effective_wt / 3;
                    const y_third_2 = y_bottom - effective_wt / 3;

                    const basePaths = [
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_1},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_2},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        { d: `M${x_quarter_3},${y_top - v_overhang} V${y_bottom + v_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                    ];
                    
                    if (isInner) {
                        return [ ...basePaths,
                            { d: `M0,${y_third_2} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_1} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_2} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    } else {
                        return [ ...basePaths,
                            { d: `M0,${y_third_1} H${x_quarter_1 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_1 - h_overhang},${y_third_2} H${x_quarter_3 + h_overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                            { d: `M${x_quarter_3 - h_overhang},${y_third_1} H${length}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        ];
                    }
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M10,-8 V8 M20,-8 V8 M30,-8 V8 M0,-1.7 H13 M7,1.7 H33 M27,-1.7 H40'
            },

            // 8. 片折れ扉
            {
                id: 'single-bifold',
                name: '片折れ扉',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const frameWidth = 1;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const overhang = 3; 

                    // isInnerフラグで三角形の基準辺（底辺）と頂点の位置を動的に変更
                    const triangleBaseY = isInner ? y_bottom : y_top;
                    const triangleTipY = isInner ? triangleBaseY + length / 4 : triangleBaseY - length / 4;

                    return [
                        // 1. ドア枠の背景（白色）
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        // 2. ドア枠の線
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        // 3. 枠の中央にある縦線
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        
                        // 4. 右半分に描画する三角形 (d属性のY座標を修正)
                        { 
                            d: `M${length * 3 / 4},${triangleBaseY} L${length * 7 / 8},${triangleTipY} L${length},${triangleBaseY}`, 
                            fill: 'none', 
                            stroke: 'currentColor', 
                            strokeWidth: 1.5 
                        }
                    ];
                },
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M30,-5 L35,-15 L40,-5'
            },

            // 9. 両折れ扉
            {
                id: 'double-bifold',
                name: '両折れ扉',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const frameWidth = 1;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const overhang = 3; 

                    // isInnerフラグで三角形の向きと基準辺（底辺）を決定
                    const triangleBaseY = isInner ? y_bottom : y_top;
                    const triangleTipY = isInner ? triangleBaseY + length / 4 : triangleBaseY - length / 4;

                    return [
                        // 1. ドア枠の背景（白色）
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'white', stroke: 'none' },
                        // 2. ドア枠の線
                        { d: `M0,${y_top} H${length} V${y_bottom} H0 Z`, fill: 'none', stroke: 'currentColor', strokeWidth: frameWidth },
                        // 3. 枠の中央にある縦線
                        { d: `M${length / 2},${y_top - overhang} V${y_bottom + overhang}`, stroke: 'currentColor', strokeWidth: frameWidth },
                        
                        // 4. 右半分に描画する三角形
                        { 
                            d: `M${length * 3 / 4},${triangleBaseY} L${length * 7 / 8},${triangleTipY} L${length},${triangleBaseY}`, 
                            fill: 'none', 
                            stroke: 'currentColor', 
                            strokeWidth: 1.5 
                        },
                        // ▼▼▼【追加】左半分に描画する三角形 ▼▼▼
                        { 
                            d: `M0,${triangleBaseY} L${length / 8},${triangleTipY} L${length / 4},${triangleBaseY}`, 
                            fill: 'none', 
                            stroke: 'currentColor', 
                            strokeWidth: 1.5 
                        }
                    ];
                },
                // プレビュー用のSVGパスも更新
                previewPath: 'M0,-5 H40 V5 H0 Z M20,-8 V8 M30,-5 L35,-15 L40,-5 M0,-5 L5,-15 L10,-5'
            },

            // 10. 開口 (左右の線を白枠の高さに合わせる)
            {
                id: 'opening',
                name: '開口',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const wt = wallThickness || 10;
                    const y_top = -wt / 2;
                    const y_bottom = wt / 2;
                    const padding = 1; // 白抜きを上下に1pxずつ拡大

                    return [
                        // 1. 白抜きの背景 (上下に少し拡大)
                        { d: `M0,${y_top - padding} H${length} V${y_bottom + padding} H0 Z`, fill: 'white', stroke: 'none' },
                        
                        // ▼▼▼【修正点】左右の縦線のY座標にもpaddingを適用 ▼▼▼
                        // 2. 左右の縦線 (白枠と同じ高さにする)
                        { d: `M0,${y_top - padding} V${y_bottom + padding}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' },
                        { d: `M${length},${y_top - padding} V${y_bottom + padding}`, fill: 'none', stroke: 'currentColor', strokeWidth: 1, strokeDasharray: '4, 2' }
                    ];
                },
                // プレビュー用のSVGパスは変更なし
                previewPath: 'M0,-5 V5 M40,-5 V5'
            },
        ];


        // --- ヘルパー関数 ---
        const isPointOnSegment = (point, lineStart, lineEnd, tolerance = 1) => {
            const dxL = lineEnd.x - lineStart.x;
            const dyL = lineEnd.y - lineStart.y;
            const dxP = point.x - lineStart.x;
            const dyP = point.y - lineStart.y;

            const crossProduct = dxP * dyL - dyP * dxL;
            if (Math.abs(crossProduct) > tolerance) return false;

            const dotProduct = dxP * dxL + dyP * dyL;
            if (dotProduct < 0) return false;

            const squaredLength = dxL * dxL + dyL * dyL;
            if (dotProduct > squaredLength) return false;

            return true;
        };

        const getIntersectionWithAllWalls = (lineStart, lineEnd, walls) => {
            let closestIntersection = null;
            let minDistanceSq = Infinity;
        
            const p1 = lineStart;
            const p2 = lineEnd;
        
            for (const wall of walls) {
                const p3 = wall.p1;
                const p4 = wall.p2;
        
                const intersection = getLineIntersection(p1, p2, p3, p4);
        
                if (intersection) {
                    // 交点が壁の線「分」上にあるかチェック
                    const isIntersectOnWallSegment = isPointOnSegment(intersection, p3, p4, 0.1);
                    // 交点が描画中の線の延長線上にあるかチェック（始点から見て同じ方向か）
                    const dx_line = p2.x - p1.x;
                    const dy_line = p2.y - p1.y;
                    const dx_intersect = intersection.x - p1.x;
                    const dy_intersect = intersection.y - p1.y;
                    const isSameDirection = (Math.sign(dx_line) === Math.sign(dx_intersect) || dx_line === 0) && 
                                            (Math.sign(dy_line) === Math.sign(dy_intersect) || dy_line === 0);
        
                    if (isIntersectOnWallSegment && isSameDirection) {
                        const distSq = (intersection.x - p2.x)**2 + (intersection.y - p2.y)**2;
                        if (distSq < minDistanceSq) {
                            minDistanceSq = distSq;
                            closestIntersection = { point: intersection, wall: wall };
                        }
                    }
                }
            }
            return { intersection: closestIntersection, distanceSq: minDistanceSq };
        };
        
        const getLineIntersection = (p1, p2, p3, p4) => {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            // 平行な線の判定閾値を少し調整して安定性を向上
            if (Math.abs(d) < 1e-8) {
                return null;
            }
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y),
            };
        };

        const getLineIntersectionWithCheck = (p1, p2, p3, p4) => {
            const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(d) < 1e-8) return null;
        
            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
        
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
            }
            return null;
        };

        const getCenterPointForElement = (el, dimensions) => {
                    switch (el.type) {
                        case 'text':
                        case 'fixture':
                        case 'compass':
                            // x, y はパーセンテージで中心座標
                            return {
                                x: el.x / 100 * dimensions.width,
                                y: el.y / 100 * dimensions.height
                            };
                        case 'door':
                        case 'window':
                            // x1,y1,x2,y2 はパーセンテージで始点と終点
                            const x1_px_dw = el.x1 / 100 * dimensions.width;
                            const y1_px_dw = el.y1 / 100 * dimensions.height;
                            const x2_px_dw = el.x2 / 100 * dimensions.width;
                            const y2_px_dw = el.y2 / 100 * dimensions.height;
                            return {
                                x: (x1_px_dw + x2_px_dw) / 2,
                                y: (y1_px_dw + y2_px_dw) / 2
                            };
                        case 'wall':
                            // x1,y1,x2,y2 はピクセルで始点と終点
                            return {
                                x: (el.x1 + el.x2) / 2,
                                y: (el.y1 + el.y2) / 2
                            };
                        case 'space':
                        case 'stairs':
                            // points はピクセル座標
                            const points = el.points.split(' ').map(p_str => ({x: parseFloat(p_str.split(',')[0]), y: parseFloat(p_str.split(',')[1])}));
                            return getPolygonCentroid(points);
                        default:
                            if (el.x !== undefined) { // フォールバック for testRect
                                return { x: el.x + el.width / 2, y: el.y + el.height / 2 };
                            } else if (el.x1 !== undefined) { // フォールバック for testLine
                                return { x: (el.x1 + el.x2) / 2, y: (el.y1 + el.y2) / 2 };
                            }
                            return { x: 0, y: 0 };
                    }
                };

        const getPolygonCentroid = (pts) => {
            if (!pts || pts.length === 0) return { x: 0, y: 0 };
            let first = pts[0], last = pts[pts.length - 1];
            if (first.x !== last.x || first.y !== last.y) pts.push(first);
            let twicearea = 0, x = 0, y = 0, nPts = pts.length, p1, p2, f;
            for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
                p1 = pts[i]; p2 = pts[j];
                f = p1.x * p2.y - p2.x * p1.y;
                twicearea += f;
                x += (p1.x + p2.x) * f;
                y += (p1.y + p2.y) * f;
            }
            f = twicearea * 3;
            if (pts.length > 0 && pts[pts.length - 1] === first) pts.pop();
            if (Math.abs(f) < 1e-6) { // Avoid division by zero for degenerate polygons
                return pts.reduce((acc, p) => ({ x: acc.x + p.x / pts.length, y: acc.y + p.y / pts.length }), { x: 0, y: 0 });
            }
            return { x: x / f, y: y / f };
        };

        const createSpaceLabel = (spaceType, centroid, dimensions) => {
            if (["柱", "その他"].includes(spaceType)) {
                return null;
            }
            
            const text = ["LDK", "DK", "K", "居室", "和室"].includes(spaceType)
                ? `${spaceType}\n約◯.◯帖`
                : spaceType;

            const smallFontTypes = ["バルコニー", "トイレ", "浴室", "洗面所", "玄関", "収納", "廊下", ...SPACE_TYPES.sub];
            const fontSize = smallFontTypes.includes(spaceType) ? 10 : 16;

            return {
                id: `text-${Date.now()}`,
                type: 'text',
                x: (centroid.x / dimensions.width) * 100,
                y: (centroid.y / dimensions.height) * 100,
                text: text,
                color: '#000000',
                backgroundColor: 'none',
                fontSize: fontSize,
                fontFamily: 'sans-serif',
                textAlign: 'center',
                writingMode: 'horizontal',
            };
        };

        const getClosestPointOnWalls = (p, walls) => {
            let closestPoint = null;
            let minDistanceSq = Infinity;

            for (const wall of walls) {
                const p1 = { x: wall.x1, y: wall.y1 };
                const p2 = { x: wall.x2, y: wall.y2 };
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;

                if (dx === 0 && dy === 0) continue;

                const t = ((p.x - p1.x) * dx + (p.y - p1.y) * dy) / (dx * dx + dy * dy);
                const clampedT = Math.max(0, Math.min(1, t));

                const pointOnLine = {
                    x: p1.x + clampedT * dx,
                    y: p1.y + clampedT * dy
                };

                const distSq = (p.x - pointOnLine.x) ** 2 + (p.y - pointOnLine.y) ** 2;

                if (distSq < minDistanceSq) {
                    minDistanceSq = distSq;
                    closestPoint = pointOnLine;
                }
            }
            return closestPoint;
        };

        // --- UIコンポーネント ---
        const LineStyleSelector = ({ selectedStyle, onChange, isRectShape }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">線の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-1">
                    {LINE_STYLES.map(style => (
                        <button key={style.id} onClick={() => onChange(style.id)} className={`p-2 rounded-md border-2 ${selectedStyle === style.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center justify-center">
                                <svg width="40" height="20" viewBox="0 0 60 20" className="flex-shrink-0">
                                    {style.id === 'double' ? (
                                        <g stroke="black" strokeWidth="1.5">
                                            <line x1="5" y1="7" x2="55" y2="7" />
                                            <line x1="5" y1="13" x2="55" y2="13" />
                                        </g>
                                    ) : (
                                        <line x1="5" y1="10" x2="55" y2="10" stroke="black" strokeWidth="2" strokeDasharray={style.dashArray} strokeLinecap="round" />
                                    )}
                                </svg>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );
        
        const SpaceTypeSelector = ({ selectedType, onChange, spaceTypeTab, setSpaceTypeTab }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">空間タイプ</label>
                <div className="flex bg-gray-200 rounded-lg p-1 mt-2">
                    <button onClick={() => setSpaceTypeTab('main')} className={`w-full py-1 rounded-md text-sm ${spaceTypeTab === 'main' ? 'bg-white shadow' : ''}`}>メイン</button>
                    <button onClick={() => setSpaceTypeTab('sub')} className={`w-full py-1 rounded-md text-sm ${spaceTypeTab === 'sub' ? 'bg-white shadow' : ''}`}>サブ</button>
                </div>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {SPACE_TYPES[spaceTypeTab].map(type => {
                        const isSelected = selectedType === type;
                        const isPillar = type === '柱';
                        const isTransparent = DEFAULT_FILL_COLORS[type] === 'none';
                        const style = {
                            backgroundColor: isTransparent ? 'transparent' : DEFAULT_FILL_COLORS[type],
                            color: isPillar ? 'white' : 'black',
                            border: `1px solid ${isTransparent || DEFAULT_FILL_COLORS[type] === '#ffffff' ? '#ccc' : 'transparent'}`
                        };
                        return (
                            <button
                                key={type}
                                onClick={() => onChange(type)}
                                style={style}
                                className={`p-1 rounded-md text-xs text-center transition-all ${isSelected ? 'ring-2 ring-offset-1 ring-indigo-500' : ''} ${isTransparent ? 'transparent-bg' : ''}`}
                            >
                                {type}
                            </button>
                        );
                    })}
                </div>
            </div>
        );

        const BackgroundSelector = ({ selected, onChange }) => {
            const getPreview = (patternId) => {
                const baseRect = <rect width="40" height="20" fill="#f0f0f0" />;
                switch(patternId) {
                    case 'none': return baseRect;
                    case 'vertical-lines': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M10 0 V20 M20 0 V20 M30 0 V20" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'horizontal-lines': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 5 H40 M0 10 H40 M0 15 H40" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'grid-small': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M10 0 V20 M20 0 V20 M30 0 V20 M0 10 H40" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'grid-large': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M20 0 V20" stroke="#000000" strokeWidth="1" /></>;
                    case 'solid-x': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 20 M0 20 L40 0" stroke="#000000" strokeWidth="1" /></>;
                    case 'dotted-x': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 20 M0 20 L40 0" stroke="#000000" strokeWidth="1" strokeDasharray="2 2" /></>;
                    case 'solid-triangle': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 10 L0 20 Z" stroke="#000000" strokeWidth="1" fill="none" /></>;
                    case 'dotted-triangle': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 10 L0 20 Z" stroke="#000000" strokeWidth="1" fill="none" strokeDasharray="2 2" /></>;
                    default: return baseRect;
                }
            };
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700">背景</label>
                    <div className="mt-2 grid grid-cols-3 gap-2">
                        {BACKGROUND_PATTERNS.map(pattern => (
                            <button
                                key={pattern.id}
                                onClick={() => onChange(pattern.id)}
                                className={`p-2 rounded-md border-2 text-xs ${selected === pattern.id ? 'border-indigo-500 bg-indigo-50' : 'bg-white border-gray-200'} hover:bg-gray-50 flex flex-col items-center justify-center`}
                            >
                                <svg width="40" height="20" className="border border-gray-300 mb-1">
                                    {getPreview(pattern.id)}
                                </svg>
                                {pattern.name}
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const CompassTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">方角の図形</label>
                <div className="mt-2 grid grid-cols-4 gap-1">
                    {COMPASS_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center h-12`}
                        >
                           <img
                                src={template.src}
                                alt={template.id}
                                className="w-8 h-8 object-contain"
                            />
                        </button>
                    ))}
                </div>
            </div>
        );

        const FixtureTemplateSelector = ({
            selectedTemplateId,
            onChange, // テンプレート変更時の関数
            category,
            isFlipped, // 反転しているか (true/false)
            onFlipChange, // 反転状態を変更する関数
            mode // 'create' or 'edit'
        }) => {
            const templates = FIXTURE_TEMPLATES[category] || [];
            return (
                <div>
                    <div className="flex justify-between items-center">
                        <label className="block text-sm font-medium text-gray-700">設備の種類</label>
                        <div className="flex items-center">
                            <input
                                id={`fixture-flip-${mode}`}
                                type="checkbox"
                                checked={isFlipped}
                                onChange={(e) => onFlipChange(e.target.checked)}
                                className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                            />
                            <label htmlFor={`fixture-flip-${mode}`} className="ml-2 text-sm text-gray-700">反転</label>
                        </div>
                    </div>
                    <div className="mt-2 grid grid-cols-4 gap-1">
                        {templates.map(template => (
                            <button key={template.id} onClick={() => onChange(template.id)} className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center`}>
                                <svg width="40" height="40" viewBox="-30 -30 60 60" className="flex-shrink-0">
                                    {template.path ? (
                                        <path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} />
                                    ) : (
                                        <image href={template.src} width="60" height="60" x="-30" y="-30" />
                                    )}
                                </svg>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const DoorTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-xs font-medium text-gray-700">ドアの種類</label>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {DOOR_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-2 rounded border w-full ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}
                        >
                            <div className="flex flex-col items-center space-y-2">
                                <svg width="100" height="80" viewBox="0 0 100 80" className="flex-shrink-0">
                                    <g transform="translate(50, 60)">
                                        <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" transform="translate(-20, -15)" />
                                    </g>
                                </svg>
                                <span className="text-xs text-center">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        const WindowTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-xs font-medium text-gray-700">窓の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {WINDOW_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-2 rounded border w-full ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}
                        >
                            <div className="flex flex-col items-center space-y-2">
                                <svg width="100" height="80" viewBox="0 0 100 80" className="flex-shrink-0">
                                    <g transform="translate(50, 60)">
                                        <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" transform="translate(-20, -15)" />
                                    </g>
                                </svg>
                                <span className="text-xs text-center">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        const processDoubleLineIntersections = (walls) => {
            const doubleLines = walls.filter(w => w.lineStyle === 'double' && !w.groupId);
            const otherElements = walls.filter(w => w.lineStyle !== 'double' || w.groupId);
            const processedLines = [];
        
            // 各二重線について交点を計算
            doubleLines.forEach((line, i) => {
                const intersections = [];
                for (let j = 0; j < doubleLines.length; j++) {
                    if (i === j) continue;
        
                    const otherLine = doubleLines[j];
                    const p1 = { x: line.x1, y: line.y1 };
                    const p2 = { x: line.x2, y: line.y2 };
                    const p3 = { x: otherLine.x1, y: otherLine.y1 };
                    const p4 = { x: otherLine.x2, y: otherLine.y2 };
        
                    const intersectPoint = getLineIntersectionWithCheck(p1, p2, p3, p4);
                    if (intersectPoint) {
                        // 交点と、交差相手の線の幅を保存
                        intersections.push({ point: intersectPoint, partnerWidth: otherLine.strokeWidth });
                    }
                }
                
                // 交点がなければ元の線を追加
                if (intersections.length === 0) {
                    processedLines.push(line);
                    return;
                }
        
                // 交点を始点からの距離でソート
                intersections.sort((a, b) => {
                    const distA = (a.point.x - line.x1) ** 2 + (a.point.y - line.y1) ** 2;
                    const distB = (b.point.x - line.x1) ** 2 + (b.point.y - line.y1) ** 2;
                    return distA - distB;
                });
        
                // 線分を分割
                let currentPoint = { x: line.x1, y: line.y1 };
                intersections.forEach(intersect => {
                    const segmentVec = { x: intersect.point.x - currentPoint.x, y: intersect.point.y - currentPoint.y };
                    const segmentLen = Math.sqrt(segmentVec.x ** 2 + segmentVec.y ** 2);
                    
                    // 交差点の中心にできる隙間の半径（相手の線の太さの半分）
                    const gapRadius = intersect.partnerWidth / 2;
        
                    if (segmentLen > gapRadius) {
                        const ratio = (segmentLen - gapRadius) / segmentLen;
                        const endPoint = {
                            x: currentPoint.x + segmentVec.x * ratio,
                            y: currentPoint.y + segmentVec.y * ratio,
                        };
                        processedLines.push({ ...line, id: `${line.id}-seg-${processedLines.length}`, x1: currentPoint.x, y1: currentPoint.y, x2: endPoint.x, y2: endPoint.y });
                    }
                    
                    // 次の線分の始点を更新（交差点の隙間の分だけ進める）
                    const startRatio = (segmentLen + gapRadius) / segmentLen;
                     currentPoint = {
                        x: currentPoint.x + segmentVec.x * startRatio,
                        y: currentPoint.y + segmentVec.y * startRatio,
                    };
                });
        
                // 最後の交点から元の終点までの線分を追加
                const lastSegmentVec = { x: line.x2 - currentPoint.x, y: line.y2 - currentPoint.y };
                if (Math.sqrt(lastSegmentVec.x ** 2 + lastSegmentVec.y ** 2) > 1) {
                    processedLines.push({ ...line, id: `${line.id}-seg-last`, x1: currentPoint.x, y1: currentPoint.y, x2: line.x2, y2: line.y2 });
                }
            });
        
            return [...processedLines, ...otherElements];
        };

        const CustomLineRenderer = ({ id, x1, y1, x2, y2, stroke, strokeWidth, lineStyle, onContextMenu }) => {
            const style = LINE_STYLES.find(s => s.id === lineStyle);
        
            // 実線または二重線の場合は、このコンポーネントでは何も描画しない（元のロジックに任せる）
            if (!style || !style.dashArray || style.dashArray === 'none' || style.id === 'double') {
                return null;
            }
        
            // dashArrayが '2, 5' のような文字列なので、数値の配列に変換
            const pattern = style.dashArray.split(/[\s,]+/).map(Number);
            if (pattern.length === 0) return null;
        
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
            if (length === 0) return null;
        
            const dashes = [];
            let currentPosition = 0;
            let patternIndex = 0;
        
            while (currentPosition < length) {
                const dashLength = pattern[patternIndex % pattern.length];
        
                // パターンの奇数番目（0から数える）が線分、偶数番目が空白
                if (patternIndex % 2 === 0) {
                    // 描画する線分の実際の長さを計算（線の終端を超えないように）
                    const actualDashLength = Math.min(dashLength, length - currentPosition);
                    
                    // 線分の開始位置を計算
                    const startX = x1 + (currentPosition / length) * dx;
                    const startY = y1 + (currentPosition / length) * dy;
        
                    dashes.push(
                        <rect
                            key={`${id}-dash-${dashes.length}`}
                            x="0"
                            y={-strokeWidth / 2} // 中心に配置
                            width={actualDashLength}
                            height={strokeWidth}
                            fill={stroke}
                            transform={`translate(${startX} ${startY}) rotate(${angle})`}
                        />
                    );
                }
        
                currentPosition += dashLength;
                patternIndex++;
            }
        
            return (
                <g data-id={id} onContextMenu={onContextMenu} style={{ cursor: 'pointer' }}>
                    {/* 描画されるダッシュ */}
                    <g style={{ pointerEvents: 'none' }}>
                        {dashes}
                    </g>
                    {/* クリック判定用の透明な線 */}
                    <line
                        x1={x1} y1={y1} x2={x2} y2={y2}
                        stroke="transparent"
                        strokeWidth={Math.max(strokeWidth, 10)}
                    />
                </g>
            );
        };

        // --- メインエディタコンポーネント ---
        const UploadModal = ({ isOpen, onClose, onSubmit, isLoading, loadingMessage, modalRef }) => {
            if (!isOpen) return null;
        
            const [localPreview, setLocalPreview] = useState(null);
            const [localUseAi, setLocalUseAi] = useState(false);
            const fileInputRef = useRef(null);
        
            const handleFileChange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setLocalPreview(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
        
            const handleSubmit = () => {
                if (localPreview) {
                    onSubmit(localPreview, localUseAi);
                }
            };
        
            const handleClose = () => {
                onClose();
                setLocalPreview(null);
                setLocalUseAi(true);
            };
        
            return (
                <div ref={modalRef} className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
                        <h3 className="text-lg font-medium leading-6 text-gray-900 mb-4">下絵のアップロード</h3>
                        {isLoading ? (
                            <div className="flex flex-col items-center justify-center h-64">
                                <svg className="animate-spin -ml-1 mr-3 h-10 w-10 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <p className="mt-4 text-gray-600">{loadingMessage}</p>
                            </div>
                        ) : (
                            <>
                                <div className="space-y-4">
                                    <button
                                        type="button"
                                        onClick={() => fileInputRef.current.click()}
                                        className="w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                    >
                                        ファイルを選択
                                        <input
                                            type="file"
                                            ref={fileInputRef}
                                            onChange={handleFileChange}
                                            accept="image/*"
                                            className="hidden"
                                        />
                                    </button>
        
                                    <div className="w-full h-48 bg-gray-100 border-2 border-dashed border-gray-300 rounded-md flex items-center justify-center">
                                        {localPreview ? (
                                            <img src={localPreview} alt="プレビュー" className="max-h-full max-w-full object-contain" />
                                        ) : (
                                            <span className="text-gray-500">プレビュー</span>
                                        )}
                                    </div>
        
                                    <div className="flex items-center opacity-50 cursor-not-allowed">
                                        <input
                                            id="ai-checkbox"
                                            type="checkbox"
                                            checked={localUseAi}
                                            onChange={(e) => setLocalUseAi(e.target.checked)}
                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                        />
                                        <label htmlFor="ai-checkbox" className="ml-2 block text-sm text-gray-900">
                                            AIで読み取る (開発中)
                                        </label>
                                    </div>
                                </div>
        
                                <div className="mt-6 flex justify-end space-x-3">
                                    <button
                                        type="button"
                                        onClick={handleClose}
                                        className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                                    >
                                        キャンセル
                                    </button>
                                    <button
                                        type="button"
                                        onClick={handleSubmit}
                                        disabled={!localPreview}
                                        className="inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    >
                                        決定
                                    </button>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const DebugPanel = ({ isDebugOpen, setIsDebugOpen, debugData }) => {
            if (!isDebugOpen) {
                return (
                    <div className="fixed bottom-4 left-4 z-40">
                        <button 
                            onClick={() => setIsDebugOpen(true)}
                            className="bg-indigo-600 text-white font-bold py-2 px-4 rounded-full shadow-lg hover:bg-indigo-700"
                        >
                            デバッグ
                        </button>
                    </div>
                );
            }
        
            return (
                <div className="fixed bottom-4 left-4 z-40 bg-white/90 backdrop-blur-sm p-4 rounded-lg shadow-lg w-full max-w-md max-h-[40vh] flex flex-col">
                    <div className="flex justify-between items-center mb-2">
                        <h3 className="text-lg font-bold">デバッグ情報</h3>
                        <button onClick={() => setIsDebugOpen(false)} className="text-gray-500 hover:text-gray-800 font-bold">✕</button>
                    </div>
                    <div className="overflow-auto space-y-4 text-xs">
                        <div>
                            <h4 className="font-semibold text-gray-800 sticky top-0 bg-white/90 py-1">1. AIからの生レスポンス (JSON)</h4>
                            <pre className="bg-gray-100 p-2 rounded mt-1 overflow-auto">
                                {JSON.stringify(debugData.rawAiResponse, null, 2)}
                            </pre>
                        </div>
                        <div>
                            <h4 className="font-semibold text-gray-800 sticky top-0 bg-white/90 py-1">2. 補正・整形後のポリゴン座標</h4>
                            <pre className="bg-gray-100 p-2 rounded mt-1 overflow-auto">
                                {JSON.stringify(debugData.processedPolygons, null, 2)}
                            </pre>
                        </div>
                        <div>
                            <h4 className="font-semibold text-gray-800 sticky top-0 bg-white/90 py-1">3. 最終的なSVG要素データ</h4>
                            <pre className="bg-gray-100 p-2 rounded mt-1 overflow-auto">
                                {JSON.stringify(debugData.finalElements, null, 2)}
                            </pre>
                        </div>
                    </div>
                </div>
            );
        };
        
        function Editor() {
            // --- ステート定義 ---
            const [isSidebarOpen, setSidebarOpen] = useState(true);
            const [isDisplaySettingsOpen, setDisplaySettingsOpen] = useState(true);
            const [isDrawingToolsOpen, setDrawingToolsOpen] = useState(true);
            const [imageUrl, setImageUrl] = useState('');
            const [historyState, setHistoryState] = useState({ past: [], present: { ocrData: null, svgElements: [] }, future: [] });
            const { ocrData: currentOcrData, svgElements } = historyState.present;
            const [editorMode, setEditorMode] = useState('continuous-create'); // 'continuous-create', 'create', 'edit'
            const [drawingMode, setDrawingMode] = useState(null);
            const [spaceShape, setSpaceShape] = useState('rect');
            const [selectedId, setSelectedId] = useState(null);
            const [dimensions, setDimensions] = useState({ width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT });
            const [drawingStartPoint, setDrawingStartPoint] = useState(null);
            const [linePoints, setLinePoints] = useState([]);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [imageOpacity, setImageOpacity] = useState(0.5);
            const [drawingOpacity, setDrawingOpacity] = useState(0.4);
            const [zoom, setZoom] = useState(0.8);
            const [imageScale, setImageScale] = useState(1);
            const [strokeColor, setStrokeColor] = useState(DEFAULT_STROKE_COLOR);
            const [strokeWidth, setStrokeWidth] = useState(DEFAULT_STROKE_WIDTH);
            const [spaceType, setSpaceType] = useState('LDK');
            const [fillColor, setFillColor] = useState(DEFAULT_FILL_COLORS[spaceType]);
            const [lineStyle, setLineStyle] = useState('solid');
            const [backgroundPattern, setBackgroundPattern] = useState('none');
            const [isGridVisible, setGridVisible] = useState(true);
            const [gridSize, setGridSize] = useState(5);
            const [fontSize, setFontSize] = useState(12);
            const [fontFamily, setFontFamily] = useState('sans-serif');
            const [textAlign, setTextAlign] = useState('center');
            const [compassTemplateId, setCompassTemplateId] = useState(COMPASS_TEMPLATES[0].id);
            const [fixtureCategory, setFixtureCategory] = useState('kitchen');
            const [fixtureTemplateId, setFixtureTemplateId] = useState(FIXTURE_TEMPLATES.kitchen[0].id);
            const [fixtureSize, setFixtureSize] = useState(50); // 作成する設備のデフォルトサイズ
            const [fixtureRotation, setFixtureRotation] = useState(0); // 作成する設備のデフォルト回転角度
            const [fixtureFlip, setFixtureFlip] = useState(false);
            const [pendingFixture, setPendingFixture] = useState(null);
            const [guideLines, setGuideLines] = useState([]);
            const [doorTemplateId, setDoorTemplateId] = useState(DOOR_TEMPLATES[0].id);
            const [windowTemplateId, setWindowTemplateId] = useState(WINDOW_TEMPLATES[0].id);
            const [stairWidth, setStairWidth] = useState(DEFAULT_STAIR_WIDTH);
            const [stairDirection, setStairDirection] = useState('up');
            const [spaceTypeTab, setSpaceTypeTab] = useState('main');
            const [lastFillColor, setLastFillColor] = useState('#ffffff');
            const [editLastFillColor, setEditLastFillColor] = useState('#ffffff');
            const [isPickingColor, setIsPickingColor] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const [resizingHandleInfo, setResizingHandleInfo] = useState(null); // { id, handleIndex, type: 'wall' | 'spaceCorner' | 'spaceEdge' }
            const [isSnappingToStart, setIsSnappingToStart] = useState(false);
            const [isSnapToWall, setSnapToWall] = useState(true);
            const activeSnapWallRef = useRef(null);
            const [wallObjectThickness, setWallObjectThickness] = useState(5);
            const [pendingWindow, setPendingWindow] = useState(null);
            const [imagePosition, setImagePosition] = useState({ x: 0, y: 0 });
            const [snappedInfo, setSnappedInfo] = useState(null);
            const [tooltip, setTooltip] = useState({ visible: false, fading: false, x: 0, y: 0, message: '' });
            const [isModifierKeyDown, setIsModifierKeyDown] = useState(false);
            const [saveStatus, setSaveStatus] = useState('保存済み'); // '保存済み', '未保存', '保存中...', 'エラー'
            const [madorizuName, setMadorizuName] = useState('読み込み中...');
            const [isEditingName, setIsEditingName] = useState(false);
            const isInitialNameLoad = useRef(true);
            const [isUploadModalOpen, setUploadModalOpen] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [originalImageDimensions, setOriginalImageDimensions] = useState(null);
            const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, targetId: null, targetElement: null });
            const [clipboard, setClipboard] = useState(null);
            const [stairSnapPreview, setStairSnapPreview] = useState(null);
            const [previewMode, setPreviewMode] = useState(null);
            const [isDebugOpen, setIsDebugOpen] = useState(true); // デバッグパネルの開閉
            const [debugData, setDebugData] = useState({ rawAiResponse: null, processedPolygons: [], finalElements: null, });

            // --- Ref定義 ---
            const contextMenuRef = useRef(null);
            const imageRef = useRef(null);
            const modalRef = useRef(null);
            const tooltipTimers = useRef([]);
            const sidebarRef = useRef(null);
            const imageDragInfo = useRef(null);
            const canvasRef = useRef(null);
            const editorAreaRef = useRef(null);
            const editorContainerRef = useRef(null);
            const svgRef = useRef(null);
            const displaySettingsRef = useRef(null);
            const dragInfo = useRef(null);
            const historyOnActionStart = useRef(null);
            const mouseDownInfo = useRef(null);
            const dragTarget = useRef(null); // Ref to store the potential drag target
            const textEditAreaRef = useRef(null);
            const prevSelectedIdRef = useRef(null);
            const isGridSnapStart = useRef(false);
            
            const selectedElement = svgElements.find(el => el.id === selectedId);

            const handleSpaceTypeChange = (newType) => {
                // 1. 空間タイプそのものを更新
                setSpaceType(newType);
                // 2. 新しいタイプに対応するプリセットを探す（なければデフォルトを使用）
                const preset = SPACE_STYLE_PRESETS[newType] || SPACE_STYLE_PRESETS['default'];
                // 3. プリセットに基づいて各スタイルを一括で更新
                setFillColor(preset.fill);
                setBackgroundPattern(preset.background);
                setLineStyle(preset.lineStyle);
                setStrokeWidth(preset.strokeWidth);
                setStrokeColor(preset.strokeColor);
            };

            const handleSelectedElementUpdate = useCallback((updates) => {
                if (!selectedId) return;
                 setHistoryState(prevState => {
                    const currentElement = prevState.present.svgElements.find(el => el.id === selectedId);
                    const newElement = { ...currentElement, ...updates };
                    
                    if (JSON.stringify(currentElement) === JSON.stringify(newElement)) {
                        return prevState;
                    }

                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.id === selectedId) {
                            return newElement;
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedId]);
            
            const handleSelectedWallsUpdate = useCallback((key, value) => {
                const groupId = selectedElement?.id;
                if (!groupId || selectedElement?.type !== 'space') return;

                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.groupId === groupId && el.type === 'wall') {
                            return { ...el, [key]: value };
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedElement]);


            const handleSelectedGroupUpdate = useCallback((updates) => {
                const activeGroupId = selectedElement?.groupId || (selectedElement?.type === 'space' ? selectedElement.id : null);
                if (!activeGroupId) return;
            
                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.groupId !== activeGroupId) {
                            return el;
                        }
            
                        let newEl = { ...el };
            
                        // ▼▼▼【ここからが新しいロジックです】▼▼▼
            
                        // 1. 壁のスタイルに関する更新 (線の種類、太さ、色)
                        // これらはグループ内の 'space' と 'wall' の両方に適用する必要がある
                        if (updates.lineStyle !== undefined || updates.strokeWidth !== undefined || updates.stroke !== undefined) {
                            if (el.type === 'space' || el.type === 'wall') {
                                // 渡された更新内容（updates）を現在の要素（newEl）に統合する
                                newEl = { ...newEl, ...updates };
                            }
                        }
            
                        // 2. 空間固有の更新 (塗りつぶし、背景、空間タイプ)
                        if (updates.fill !== undefined || updates.backgroundPattern !== undefined || updates.spaceType !== undefined) {
                            // これらの更新は 'space' 要素にのみ適用
                            if (el.type === 'space') {
                                newEl = { ...newEl, ...updates };
                            }
                            // 空間タイプが変更された場合、関連するテキストも更新する
                            if (updates.spaceType && el.type === 'text') {
                                newEl.text = ["LDK", "DK", "K", "居室", "和室"].includes(updates.spaceType)
                                    ? `${updates.spaceType}\n約◯.◯帖`
                                    : updates.spaceType;
                            }
                        }
                        // ▲▲▲【ここまで】▲▲▲
            
                        return newEl;
                    });
                    
                    // 変更がなければ履歴を更新しない
                    if (JSON.stringify(prevState.present.svgElements) === JSON.stringify(updatedSvgElements)) {
                        return prevState;
                    }
                    
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedElement]);

            const analyzeImageWithAI = async (imageDataUrl) => {
                const base64ImageData = imageDataUrl.split(',')[1];
                const promptForExtraction = `あなたは、建築図面をピクセルレベルで正確に読み取る画像解析エンジンです。
提供された間取り図画像から、以下の要素を抽出してください。

【抽出対象】
1. 壁: 画像内の黒い線として認識される壁の線分。
2. 区画: 壁によって囲まれた全ての閉じた領域。複雑な形状であっても、その輪郭を忠実にトレースしてください。
3. テキスト: 区画内に存在する全てのテキストラベル。

【出力形式】
以下のJSON形式で、抽出した全ての情報を 빠짐なく出力してください。部屋のタイプの推測など、意味的な解釈は不要です。テキストをそのまま出力してください。

{
  "Blocks": [
    {
      "Text": "抽出したテキスト",
      "Geometry": {
        "Polygon": [
          { "x": 0, "y": 0 },
        ]
      }
    }
  ]
}
`;
                const exampleData1 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK",
                      "Geometry": {
                        "Polygon": [
                          { "x": 310, "y": 35 }, { "x": 630, "y": 35 },
                          { "x": 630, "y": 195 }, { "x": 565, "y": 195 },
                          { "x": 565, "y": 265 }, { "x": 580, "y": 265 },
                          { "x": 580, "y": 460 }, { "x": 310, "y": 460 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 565, "y": 195 }, { "x": 630, "y": 195 },
                          { "x": 630, "y": 265 }, { "x": 565, "y": 265 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 645, "y": 295 }, { "x": 710, "y": 295 },
                          { "x": 710, "y": 390 }, { "x": 645, "y": 390 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 580, "y": 390 }, { "x": 710, "y": 390 },
                          { "x": 710, "y": 515 }, { "x": 580, "y": 515 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗面所",
                      "Geometry": {
                        "Polygon": [
                          { "x": 580, "y": 295 }, { "x": 645, "y": 295 },
                          { "x": 645, "y": 390 }, { "x": 580, "y": 390 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 約7帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 310, "y": 460 }, { "x": 515, "y": 460 },
                          { "x": 515, "y": 785 }, { "x": 310, "y": 785 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 約5帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 515, "y": 460 }, { "x": 710, "y": 460 },
                          { "x": 710, "y": 715 }, { "x": 580, "y": 715 },
                          { "x": 580, "y": 515 }, { "x": 515, "y": 515 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 310, "y": 785 }, { "x": 710, "y": 785 },
                          { "x": 710, "y": 820 }, { "x": 310, "y": 820 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData2 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK 約 13.5 帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 170, "y": 275 }, { "x": 450, "y": 275 },
                          { "x": 450, "y": 480 }, { "x": 395, "y": 480 },
                          { "x": 395, "y": 450 }, { "x": 365, "y": 450 },
                          { "x": 365, "y": 385 }, { "x": 395, "y": 385 },
                          { "x": 395, "y": 275 }, { "x": 170, "y": 275 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 約 4.9帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 450, "y": 275 }, { "x": 630, "y": 275 },
                          { "x": 630, "y": 410 }, { "x": 450, "y": 410 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 約 4.4帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 450, "y": 480 }, { "x": 630, "y": 480 },
                          { "x": 630, "y": 600 }, { "x": 450, "y": 600 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 約 5.5帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 450, "y": 600 }, { "x": 630, "y": 600 },
                          { "x": 630, "y": 715 }, { "x": 450, "y": 715 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 450, "y": 195 }, { "x": 630, "y": 195 },
                          { "x": 630, "y": 275 }, { "x": 450, "y": 275 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗面室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 170, "y": 195 }, { "x": 395, "y": 195 },
                          { "x": 395, "y": 275 }, { "x": 170, "y": 275 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 170, "y": 385 }, { "x": 365, "y": 385 },
                          { "x": 365, "y": 450 }, { "x": 170, "y": 450 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "収納",
                      "Geometry": {
                        "Polygon": [
                          { "x": 365, "y": 385 }, { "x": 395, "y": 385 },
                          { "x": 395, "y": 450 }, { "x": 365, "y": 450 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 365, "y": 305 }, { "x": 395, "y": 305 },
                          { "x": 395, "y": 385 }, { "x": 365, "y": 385 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 450, "y": 410 }, { "x": 540, "y": 410 },
                          { "x": 540, "y": 480 }, { "x": 450, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 540, "y": 410 }, { "x": 630, "y": 410 },
                          { "x": 630, "y": 480 }, { "x": 540, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 450, "y": 600 }, { "x": 530, "y": 600 },
                          { "x": 530, "y": 650 }, { "x": 450, "y": 650 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 160, "y": 770 }, { "x": 640, "y": 770 },
                          { "x": 640, "y": 805 }, { "x": 160, "y": 805 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData3 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LD 12.2帖\nK 3.2帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 60, "y": 555 }, { "x": 470, "y": 555 },
                          { "x": 470, "y": 710 }, { "x": 60, "y": 710 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 6.0帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 330, "y": 100 }, { "x": 470, "y": 100 },
                          { "x": 470, "y": 310 }, { "x": 330, "y": 310 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5.0帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 60, "y": 100 }, { "x": 255, "y": 100 },
                          { "x": 255, "y": 310 }, { "x": 60, "y": 310 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5.0帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 330, "y": 410 }, { "x": 470, "y": 410 },
                          { "x": 470, "y": 540 }, { "x": 330, "y": 540 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 255, "y": 230 }, { "x": 315, "y": 230 },
                          { "x": 315, "y": 555 }, { "x": 255, "y": 555 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 270, "y": 100 }, { "x": 315, "y": 100 },
                          { "x": 315, "y": 230 }, { "x": 270, "y": 230 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗",
                      "Geometry": {
                        "Polygon": [
                          { "x": 60, "y": 380 }, { "x": 220, "y": 380 },
                          { "x": 220, "y": 440 }, { "x": 60, "y": 440 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 60, "y": 455 }, { "x": 220, "y": 455 },
                          { "x": 220, "y": 540 }, { "x": 60, "y": 540 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "T",
                      "Geometry": {
                        "Polygon": [
                          { "x": 255, "y": 115 }, { "x": 270, "y": 115 },
                          { "x": 270, "y": 165 }, { "x": 255, "y": 165 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "CL CL",
                      "Geometry": {
                        "Polygon": [
                          { "x": 60, "y": 310 }, { "x": 220, "y": 310 },
                          { "x": 220, "y": 360 }, { "x": 60, "y": 360 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "CL CL",
                      "Geometry": {
                        "Polygon": [
                          { "x": 330, "y": 310 }, { "x": 380, "y": 310 },
                          { "x": 380, "y": 340 }, { "x": 330, "y": 340 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "ウォークイン\nクローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 340 }, { "x": 470, "y": 340 },
                          { "x": 470, "y": 395 }, { "x": 380, "y": 395 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "物入",
                      "Geometry": {
                        "Polygon": [
                          { "x": 255, "y": 340 }, { "x": 315, "y": 340 },
                          { "x": 315, "y": 410 }, { "x": 255, "y": 410 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 60, "y": 725 }, { "x": 470, "y": 725 },
                          { "x": 470, "y": 760 }, { "x": 60, "y": 760 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData4 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK 11.0J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 300, "y": 410 }, { "x": 590, "y": 410 },
                          { "x": 590, "y": 715 }, { "x": 300, "y": 715 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "Bedroom 5.0J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 85 }, { "x": 270, "y": 85 },
                          { "x": 270, "y": 290 }, { "x": 65, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "Bedroom 6.0J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 85 }, { "x": 590, "y": 85 },
                          { "x": 590, "y": 290 }, { "x": 380, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "Bedroom 6.5J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 490 }, { "x": 300, "y": 490 },
                          { "x": 300, "y": 715 }, { "x": 65, "y": 715 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 300, "y": 245 }, { "x": 380, "y": 245 },
                          { "x": 380, "y": 490 }, { "x": 300, "y": 490 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "Ent.",
                      "Geometry": {
                        "Polygon": [
                          { "x": 300, "y": 85 }, { "x": 380, "y": 85 },
                          { "x": 380, "y": 245 }, { "x": 300, "y": 245 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "Washroom",
                      "Geometry": {
                        "Polygon": [
                          { "x": 160, "y": 290 }, { "x": 270, "y": 290 },
                          { "x": 270, "y": 385 }, { "x": 160, "y": 385 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "Bathroom",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 385 }, { "x": 270, "y": 385 },
                          { "x": 270, "y": 490 }, { "x": 65, "y": 490 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "Lav.",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 290 }, { "x": 480, "y": 290 },
                          { "x": 480, "y": 370 }, { "x": 380, "y": 370 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "Closet",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 290 }, { "x": 160, "y": 290 },
                          { "x": 160, "y": 340 }, { "x": 65, "y": 340 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "SB",
                      "Geometry": {
                        "Polygon": [
                          { "x": 270, "y": 85 }, { "x": 300, "y": 85 },
                          { "x": 300, "y": 150 }, { "x": 270, "y": 150 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "WIC",
                      "Geometry": {
                        "Polygon": [
                          { "x": 480, "y": 290 }, { "x": 590, "y": 290 },
                          { "x": 590, "y": 380 }, { "x": 480, "y": 380 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "Str",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 370 }, { "x": 480, "y": 370 },
                          { "x": 480, "y": 410 }, { "x": 380, "y": 410 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "Storage",
                      "Geometry": {
                        "Polygon": [
                          { "x": 270, "y": 385 }, { "x": 300, "y": 385 },
                          { "x": 300, "y": 490 }, { "x": 270, "y": 490 }
                        ]
                      }
                    },
                    {
                      "type": "PS",
                      "Text": "PS",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 340 }, { "x": 110, "y": 340 },
                          { "x": 110, "y": 385 }, { "x": 65, "y": 385 }
                        ]
                      }
                    },
                    {
                      "type": "PS",
                      "Text": "PS",
                      "Geometry": {
                        "Polygon": [
                          { "x": 480, "y": 380 }, { "x": 515, "y": 380 },
                          { "x": 515, "y": 410 }, { "x": 480, "y": 410 }
                        ]
                      }
                    },
                    {
                      "type": "MB",
                      "Text": "MB",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 40 }, { "x": 130, "y": 40 },
                          { "x": 130, "y": 75 }, { "x": 65, "y": 75 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "Balcony",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 715 }, { "x": 590, "y": 715 },
                          { "x": 590, "y": 770 }, { "x": 65, "y": 770 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData5 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK 11.0J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 300, "y": 410 }, { "x": 590, "y": 410 },
                          { "x": 590, "y": 715 }, { "x": 300, "y": 715 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "Bedroom 5.0J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 85 }, { "x": 270, "y": 85 },
                          { "x": 270, "y": 290 }, { "x": 65, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "Bedroom 6.0J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 85 }, { "x": 590, "y": 85 },
                          { "x": 590, "y": 290 }, { "x": 380, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "Bedroom 6.5J",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 490 }, { "x": 300, "y": 490 },
                          { "x": 300, "y": 715 }, { "x": 65, "y": 715 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 300, "y": 245 }, { "x": 380, "y": 245 },
                          { "x": 380, "y": 490 }, { "x": 300, "y": 490 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "Ent.",
                      "Geometry": {
                        "Polygon": [
                          { "x": 300, "y": 85 }, { "x": 380, "y": 85 },
                          { "x": 380, "y": 245 }, { "x": 300, "y": 245 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "Washroom",
                      "Geometry": {
                        "Polygon": [
                          { "x": 160, "y": 290 }, { "x": 270, "y": 290 },
                          { "x": 270, "y": 385 }, { "x": 160, "y": 385 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "Bathroom",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 385 }, { "x": 270, "y": 385 },
                          { "x": 270, "y": 490 }, { "x": 65, "y": 490 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "Lav.",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 290 }, { "x": 480, "y": 290 },
                          { "x": 480, "y": 370 }, { "x": 380, "y": 370 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "Closet",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 290 }, { "x": 160, "y": 290 },
                          { "x": 160, "y": 340 }, { "x": 65, "y": 340 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "SB",
                      "Geometry": {
                        "Polygon": [
                          { "x": 270, "y": 85 }, { "x": 300, "y": 85 },
                          { "x": 300, "y": 150 }, { "x": 270, "y": 150 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "WIC",
                      "Geometry": {
                        "Polygon": [
                          { "x": 480, "y": 290 }, { "x": 590, "y": 290 },
                          { "x": 590, "y": 380 }, { "x": 480, "y": 380 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "Str",
                      "Geometry": {
                        "Polygon": [
                          { "x": 380, "y": 370 }, { "x": 480, "y": 370 },
                          { "x": 480, "y": 410 }, { "x": 380, "y": 410 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "Storage",
                      "Geometry": {
                        "Polygon": [
                          { "x": 270, "y": 385 }, { "x": 300, "y": 385 },
                          { "x": 300, "y": 490 }, { "x": 270, "y": 490 }
                        ]
                      }
                    },
                    {
                      "type": "PS",
                      "Text": "PS",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 340 }, { "x": 110, "y": 340 },
                          { "x": 110, "y": 385 }, { "x": 65, "y": 385 }
                        ]
                      }
                    },
                    {
                      "type": "PS",
                      "Text": "PS",
                      "Geometry": {
                        "Polygon": [
                          { "x": 480, "y": 380 }, { "x": 515, "y": 380 },
                          { "x": 515, "y": 410 }, { "x": 480, "y": 410 }
                        ]
                      }
                    },
                    {
                      "type": "MB",
                      "Text": "MB",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 40 }, { "x": 130, "y": 40 },
                          { "x": 130, "y": 75 }, { "x": 65, "y": 75 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "Balcony",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 715 }, { "x": 590, "y": 715 },
                          { "x": 590, "y": 770 }, { "x": 65, "y": 770 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData6 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK 約 20.5 帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 75, "y": 475 }, { "x": 490, "y": 475 },
                          { "x": 490, "y": 620 }, { "x": 465, "y": 620 },
                          { "x": 465, "y": 705 }, { "x": 75, "y": 705 }
                        ]
                      }
                    },
                    {
                      "type": "和室",
                      "Text": "和室 約 4.5 帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 490, "y": 560 }, { "x": 655, "y": 560 },
                          { "x": 655, "y": 705 }, { "x": 490, "y": 705 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 480, "y": 75 }, { "x": 610, "y": 75 },
                          { "x": 610, "y": 205 }, { "x": 480, "y": 205 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗面室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 220, "y": 155 }, { "x": 330, "y": 155 },
                          { "x": 330, "y": 275 }, { "x": 220, "y": 275 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室 (1116)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 155 }, { "x": 220, "y": 155 },
                          { "x": 220, "y": 275 }, { "x": 65, "y": 275 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 270, "y": 75 }, { "x": 330, "y": 75 },
                          { "x": 330, "y": 155 }, { "x": 270, "y": 155 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "廊下",
                      "Geometry": {
                        "Polygon": [
                          { "x": 340, "y": 155 }, { "x": 470, "y": 155 },
                          { "x": 470, "y": 275 }, { "x": 340, "y": 275 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "シューズイン\nクローク",
                      "Geometry": {
                        "Polygon": [
                          { "x": 340, "y": 75 }, { "x": 470, "y": 75 },
                          { "x": 470, "y": 155 }, { "x": 340, "y": 155 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "土間収納",
                      "Geometry": {
                        "Polygon": [
                          { "x": 580, "y": 530 }, { "x": 655, "y": 530 },
                          { "x": 655, "y": 560 }, { "x": 580, "y": 560 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 490, "y": 530 }, { "x": 580, "y": 530 },
                          { "x": 580, "y": 560 }, { "x": 490, "y": 560 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "パントリー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 440, "y": 380 }, { "x": 490, "y": 380 },
                          { "x": 490, "y": 475 }, { "x": 440, "y": 475 }
                        ]
                      }
                    },
                    {
                      "type": "MB",
                      "Text": "MB",
                      "Geometry": {
                        "Polygon": [
                          { "x": 65, "y": 35 }, { "x": 130, "y": 35 },
                          { "x": 130, "y": 75 }, { "x": 65, "y": 75 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData7 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK 14.3帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 295, "y": 42 }, { "x": 473, "y": 42 },
                          { "x": 473, "y": 597 }, { "x": 295, "y": 597 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5.3帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 691 }, { "x": 229, "y": 691 },
                          { "x": 229, "y": 855 }, { "x": 52, "y": 855 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5.5帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 42 }, { "x": 724, "y": 42 },
                          { "x": 724, "y": 278 }, { "x": 546, "y": 278 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 646 }, { "x": 724, "y": 646 },
                          { "x": 724, "y": 782 }, { "x": 546, "y": 782 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "UP",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 494 }, { "x": 229, "y": 494 },
                          { "x": 229, "y": 600 }, { "x": 52, "y": 600 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "DN UP",
                      "Geometry": {
                        "Polygon": [
                          { "x": 295, "y": 600 }, { "x": 473, "y": 600 },
                          { "x": 473, "y": 855 }, { "x": 295, "y": 855 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "DN",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 363 }, { "x": 724, "y": 363 },
                          { "x": 724, "y": 560 }, { "x": 546, "y": 560 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 394 }, { "x": 139, "y": 394 },
                          { "x": 139, "y": 489 }, { "x": 52, "y": 489 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 645, "y": 320 }, { "x": 724, "y": 320 },
                          { "x": 724, "y": 409 }, { "x": 645, "y": 409 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 295 }, { "x": 163, "y": 295 },
                          { "x": 163, "y": 389 }, { "x": 52, "y": 389 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 184 }, { "x": 182, "y": 184 },
                          { "x": 182, "y": 290 }, { "x": 52, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 187, "y": 184 }, { "x": 229, "y": 184 },
                          { "x": 229, "y": 290 }, { "x": 187, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 604 }, { "x": 145, "y": 604 },
                          { "x": 145, "y": 686 }, { "x": 52, "y": 686 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "下駄箱",
                      "Geometry": {
                        "Polygon": [
                          { "x": 167, "y": 295 }, { "x": 229, "y": 295 },
                          { "x": 229, "y": 389 }, { "x": 167, "y": 389 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 281 }, { "x": 640, "y": 281 },
                          { "x": 640, "y": 360 }, { "x": 546, "y": 360 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 563 }, { "x": 640, "y": 563 },
                          { "x": 640, "y": 643 }, { "x": 546, "y": 643 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 785 }, { "x": 724, "y": 785 },
                          { "x": 724, "y": 846 }, { "x": 546, "y": 846 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData8 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK 14.3帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 295, "y": 42 }, { "x": 473, "y": 42 },
                          { "x": 473, "y": 597 }, { "x": 295, "y": 597 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5.3帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 691 }, { "x": 229, "y": 691 },
                          { "x": 229, "y": 855 }, { "x": 52, "y": 855 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5.5帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 42 }, { "x": 724, "y": 42 },
                          { "x": 724, "y": 278 }, { "x": 546, "y": 278 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室 5帖",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 646 }, { "x": 724, "y": 646 },
                          { "x": 724, "y": 782 }, { "x": 546, "y": 782 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "UP",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 494 }, { "x": 229, "y": 494 },
                          { "x": 229, "y": 600 }, { "x": 52, "y": 600 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "DN UP",
                      "Geometry": {
                        "Polygon": [
                          { "x": 295, "y": 600 }, { "x": 473, "y": 600 },
                          { "x": 473, "y": 855 }, { "x": 295, "y": 855 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "DN",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 363 }, { "x": 724, "y": 363 },
                          { "x": 724, "y": 560 }, { "x": 546, "y": 560 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 394 }, { "x": 139, "y": 394 },
                          { "x": 139, "y": 489 }, { "x": 52, "y": 489 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "トイレ",
                      "Geometry": {
                        "Polygon": [
                          { "x": 645, "y": 320 }, { "x": 724, "y": 320 },
                          { "x": 724, "y": 409 }, { "x": 645, "y": 409 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 295 }, { "x": 163, "y": 295 },
                          { "x": 163, "y": 389 }, { "x": 52, "y": 389 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 184 }, { "x": 182, "y": 184 },
                          { "x": 182, "y": 290 }, { "x": 52, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 187, "y": 184 }, { "x": 229, "y": 184 },
                          { "x": 229, "y": 290 }, { "x": 187, "y": 290 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 52, "y": 604 }, { "x": 145, "y": 604 },
                          { "x": 145, "y": 686 }, { "x": 52, "y": 686 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "下駄箱",
                      "Geometry": {
                        "Polygon": [
                          { "x": 167, "y": 295 }, { "x": 229, "y": 295 },
                          { "x": 229, "y": 389 }, { "x": 167, "y": 389 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 281 }, { "x": 640, "y": 281 },
                          { "x": 640, "y": 360 }, { "x": 546, "y": 360 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "クローゼット",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 563 }, { "x": 640, "y": 563 },
                          { "x": 640, "y": 643 }, { "x": 546, "y": 643 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 546, "y": 785 }, { "x": 724, "y": 785 },
                          { "x": 724, "y": 846 }, { "x": 546, "y": 846 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData9 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK(18.2帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 122, "y": 331 }, { "x": 500, "y": 331 },
                          { "x": 500, "y": 432 }, { "x": 536, "y": 432 },
                          { "x": 536, "y": 458 }, { "x": 562, "y": 458 },
                          { "x": 562, "y": 591 }, { "x": 122, "y": 591 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室(5.5帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 594, "y": 490 }, { "x": 716, "y": 490 },
                          { "x": 716, "y": 608 }, { "x": 594, "y": 608 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室(5.1帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 594, "y": 360 }, { "x": 716, "y": 360 },
                          { "x": 716, "y": 480 }, { "x": 594, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室(7.5帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 720, "y": 440 }, { "x": 865, "y": 440 },
                          { "x": 865, "y": 608 }, { "x": 720, "y": 608 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 716, "y": 360 }, { "x": 780, "y": 360 },
                          { "x": 780, "y": 480 }, { "x": 720, "y": 480 },
                          { "x": 720, "y": 440 }, { "x": 716, "y": 440 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 720, "y": 405 }, { "x": 780, "y": 405 },
                          { "x": 780, "y": 480 }, { "x": 720, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "WIC(3帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 790, "y": 380 }, { "x": 865, "y": 380 },
                          { "x": 865, "y": 480 }, { "x": 790, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 122, "y": 140 }, { "x": 240, "y": 140 },
                          { "x": 240, "y": 280 }, { "x": 122, "y": 280 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗面",
                      "Geometry": {
                        "Polygon": [
                          { "x": 302, "y": 140 }, { "x": 400, "y": 140 },
                          { "x": 400, "y": 252 }, { "x": 302, "y": 252 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 400, "y": 140 }, { "x": 500, "y": 140 },
                          { "x": 500, "y": 252 }, { "x": 400, "y": 252 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 248, "y": 140 }, { "x": 302, "y": 140 },
                          { "x": 302, "y": 252 }, { "x": 248, "y": 252 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 240, "y": 280 }, { "x": 370, "y": 280 },
                          { "x": 370, "y": 331 }, { "x": 240, "y": 331 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 80, "y": 140 }, { "x": 122, "y": 140 },
                          { "x": 122, "y": 280 }, { "x": 80, "y": 280 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 80, "y": 591 }, { "x": 122, "y": 591 },
                          { "x": 122, "y": 702 }, { "x": 80, "y": 702 }
                        ]
                      }
                    }
                  ]
                };
                const exampleData10 = {
                  "Blocks": [
                    {
                      "type": "LDK",
                      "Text": "LDK(18.2帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 122, "y": 331 }, { "x": 500, "y": 331 },
                          { "x": 500, "y": 432 }, { "x": 536, "y": 432 },
                          { "x": 536, "y": 458 }, { "x": 562, "y": 458 },
                          { "x": 562, "y": 591 }, { "x": 122, "y": 591 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室(5.5帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 594, "y": 490 }, { "x": 716, "y": 490 },
                          { "x": 716, "y": 608 }, { "x": 594, "y": 608 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室(5.1帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 594, "y": 360 }, { "x": 716, "y": 360 },
                          { "x": 716, "y": 480 }, { "x": 594, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "居室",
                      "Text": "洋室(7.5帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 720, "y": 440 }, { "x": 865, "y": 440 },
                          { "x": 865, "y": 608 }, { "x": 720, "y": 608 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 716, "y": 360 }, { "x": 780, "y": 360 },
                          { "x": 780, "y": 480 }, { "x": 720, "y": 480 },
                          { "x": 720, "y": 440 }, { "x": 716, "y": 440 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 720, "y": 405 }, { "x": 780, "y": 405 },
                          { "x": 780, "y": 480 }, { "x": 720, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "収納",
                      "Text": "WIC(3帖)",
                      "Geometry": {
                        "Polygon": [
                          { "x": 790, "y": 380 }, { "x": 865, "y": 380 },
                          { "x": 865, "y": 480 }, { "x": 790, "y": 480 }
                        ]
                      }
                    },
                    {
                      "type": "玄関",
                      "Text": "玄関",
                      "Geometry": {
                        "Polygon": [
                          { "x": 122, "y": 140 }, { "x": 240, "y": 140 },
                          { "x": 240, "y": 280 }, { "x": 122, "y": 280 }
                        ]
                      }
                    },
                    {
                      "type": "洗面所",
                      "Text": "洗面",
                      "Geometry": {
                        "Polygon": [
                          { "x": 302, "y": 140 }, { "x": 400, "y": 140 },
                          { "x": 400, "y": 252 }, { "x": 302, "y": 252 }
                        ]
                      }
                    },
                    {
                      "type": "浴室",
                      "Text": "浴室",
                      "Geometry": {
                        "Polygon": [
                          { "x": 400, "y": 140 }, { "x": 500, "y": 140 },
                          { "x": 500, "y": 252 }, { "x": 400, "y": 252 }
                        ]
                      }
                    },
                    {
                      "type": "トイレ",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 248, "y": 140 }, { "x": 302, "y": 140 },
                          { "x": 302, "y": 252 }, { "x": 248, "y": 252 }
                        ]
                      }
                    },
                    {
                      "type": "廊下",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 240, "y": 280 }, { "x": 370, "y": 280 },
                          { "x": 370, "y": 331 }, { "x": 240, "y": 331 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "",
                      "Geometry": {
                        "Polygon": [
                          { "x": 80, "y": 140 }, { "x": 122, "y": 140 },
                          { "x": 122, "y": 280 }, { "x": 80, "y": 280 }
                        ]
                      }
                    },
                    {
                      "type": "バルコニー",
                      "Text": "バルコニー",
                      "Geometry": {
                        "Polygon": [
                          { "x": 80, "y": 591 }, { "x": 122, "y": 591 },
                          { "x": 122, "y": 702 }, { "x": 80, "y": 702 }
                        ]
                      }
                    }
                  ]
                };
                const finalPrompt = `あなたは、日本の建築図面をピクセル単位で正確に解析する、超高性能な間取り図解析AIです。
ユーザーが提供する間取り図の画像から、各部屋の情報を抽出し、指定されたJSON形式で出力してください。

【最重要タスク】
あなたの最重要タスクは、画像内の壁で囲まれた全ての「部屋」または「空間」を、一つ残らず個別のブロックとしてJSONに出力することです。各ブロックには、その空間の輪郭を示す正確なポリゴン、空間の種類を示すtype、そして空間内のテキストを含める必要があります。

【思考プロセス】
1. 構造把握: まず画像全体を俯瞰し、どの壁がどの空間を構成しているか、大まかなレイアウトを把握します。
2. ラベルと空間の紐付け: 次に、「LDK」「洋室」といったテキストラベルを見つけ、そのラベルが含まれる壁で囲まれた空間を特定します。
3. 輪郭の精密トレース: 特定した空間の「壁の内側の線」を忠実にたどり、凹凸を含めた全ての頂点を拾い上げてポリゴンを定義します。これは最も重要なステップです。
4. 全空間の網羅: ラベルのない空間（廊下や小さな収納など）も見落とさず、同様にポリゴンとして定義します。

【絶対厳守ルール】
ルール1. 輪郭の完全な正確性: 部屋の形状を単純な四角形に絶対にしないでください。L字型や凹凸のある複雑な多角形であっても、その全ての頂点を完全に捉えてください。壁の厚みの内側のラインをピクセルレベルで正確にトレースすることが求められます。
ルール2. タイプの決定: 'type'は["LDK", "居室", "和室", "浴室", "洗面所", "トイレ", "収納", "玄関", "廊下", "バルコニー", "PS", "MB"]から選択します。空間内の日本語の部屋名を最優先し、"WIC"などは"収納"に分類します。"PS・MB"というテキストがあっても、そこが明らかにトイレの空間であれば'type'は"トイレ"と判断してください。
ルール3. 全ての空間を網羅: 非常に小さな収納スペースも見逃さず、必ず個別のブロックとして抽出してください。
ルール4. テキストの完全性: 'Text'には、部屋名だけでなく「約7帖」のような帖数表記ももれなく含めてください。テキストが存在しない場合は空文字 "" を設定してください。
ルール5. 自己検証: 全ての空間を抽出した後、壁で囲まれているにも関わらずどのブロックにも含まれていない「隙間」や「未定義領域」がないか、もう一度全体を見直してください。もし見つかった場合は、それを「廊下」や「収納」などの適切なブロックとして追加してください。


---
【完璧な出力例 1】
## 思考: 画像を解析した結果、LDK、玄関、トイレ、浴室、洗面所、2つの洋室、バルコニーの計8つの区画を認識した。特にLDKと洋室(5帖)は単純な四角形ではなく、壁の凹凸を反映した多角形として定義する必要があると判断。LDKは8つの頂点、洋室(5帖)は6つの頂点を持つポリゴンとして座標を丁寧に出力する。
## 理想的なJSON出力:
${JSON.stringify(exampleData1)}
---
【完璧な出力例 2】
## 思考: 画像から3つの洋室、LDK、水回り（浴室、洗面室、トイレ）、玄関、廊下、収納、バルコニーを認識した。各洋室に隣接する小さな区画を「収納」として正しく紐付ける。水回りと玄関をつなぐように存在する細長い空間を「廊下」として定義し、その境界を正確にトレースする。
## 理想的なJSON出力:
${JSON.stringify(exampleData2)}
---
【完璧な出力例 3】
## 思考: 画像下部の大半を占める空間をLDKとして認識。その上部に複数の洋室と水回りが配置されている構造を把握。特に中央の「廊下」が各部屋を繋ぐ重要な役割を果たしていると判断し、その複雑な形状を正確にトレースする。WICやCL、物入は全て「収納」タイプに分類する。
## 理想的なJSON出力:
${JSON.stringify(exampleData3)}
---
【完璧な出力例 4】
## 思考: 2つの洋室とLDKにまたがる大きな「バルコニー」をまず特定する。各部屋は収納（WIC、Closet）によって複雑な形状になっているため、単純な四角形として捉えず、壁の凹凸を忠実にポリゴンに反映させる。中央の廊下と水回りの配置関係を正確に認識することが重要。
## 理想的なJSON出力:
${JSON.stringify(exampleData4)}
---
【完璧な出力例 5】
## 思考: 右側の大きなLDKと、左側に配置された2つの洋室という基本構造を理解する。中央上部に密集している玄関、シューズインクローク(収納)、トイレ、洗面室、浴室をそれぞれ独立した四角形の区画として正確に切り分ける。
## 理想的なJSON出力:
${JSON.stringify(exampleData5)}
---
【完璧な出力例 6】
## 思考: 画像が上下2つのフロア（1階と2階）で構成されていることを認識する。まず1階部分について、LDK、和室、玄関、廊下、水回りをそれぞれ個別のポリゴンとして抽出する。次に2階部分について、3つの洋室と収納、そしてバルコニーを抽出する。「吹抜」と書かれたテキストは認識するが、指定されたタイプにないためポリゴンは生成しない。階段部分は「廊下」として扱う。
## 理想的なJSON出力:
${JSON.stringify(exampleData6)}
---
【完璧な出力例 7】
## 思考: 画像が左右3つのフロア（1階、2階、3階）に分かれていることを特定する。各フロアごとに解析を実行。1階は洋室と縦に並んだ水回りを抽出。2階は壁がほとんどないため、全体を一つの巨大なLDKポリゴンとして認識する。3階は2つの洋室と廊下、バルコニーを抽出する。各階の階段は「廊下」として扱う。
## 理想的なJSON出力:
${JSON.stringify(exampleData7)}
---
【完璧な出力例 8】
## 思考: 画像が3つのエリア（1階、2階、屋根裏収納）に分かれていることを認識する。各エリアごとに解析。1階はLDKと、上部に連なる複雑な水回りと廊下、玄関を正確に切り分ける。2階は3つの洋室とWIC(収納)、そして2部屋にまたがるバルコニーを認識する。屋根裏収納は「収納」と「廊下」として単純に分割する。
## 理想的なJSON出力:
${JSON.stringify(exampleData8)}
---
【完璧な出力例 9】
## 思考: 3つのエリア（1階、2階、屋根裏収納）を認識。1階はLDKと洋室、そして上部の水回りを繋ぐ廊下の形状を正確にトレースする。2階は3つの洋室と複数の収納、そしてバルコニーの位置関係を把握する。特に右側の洋室の上にある3つの独立した収納を個別に抽出することが重要。
## 理想的なJSON出力:
${JSON.stringify(exampleData9)}
---
【完璧な出力例 10】
## 思考: 3つのフロア（1階、2階、3階）を認識。1階は洋室と、その上に複雑に配置された収納、水回り、廊下、玄関を個別に抽出する。2階は広大なLDKを一つのポリゴンとして定義し、右上の階段(廊下)とトイレ、収納部分を切り抜いた形状として認識する。3階も同様に、中央の廊下を基準に各部屋を配置する。
## 理想的なJSON出力:
${JSON.stringify(exampleData10)}
---

上記の思考プロセスとルール、そして複数の出力例を厳密に参考にし、これから提供される新しい画像を解析して、JSONオブジェクトのみを出力してください。`;
            
                const payload = {
                    contents: [{
                        parts: [
                            { text: finalPrompt },
                            { inlineData: { mimeType: "image/jpeg", data: base64ImageData } }
                        ]
                    }],
                    generationConfig: {
                        responseMimeType: "application/json",
                        // スキーマも最初から「type」を含む理想の形式に合わせます
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "Blocks": {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            "type": { "type": "STRING" }, // typeフィールドを追加
                                            "Text": { "type": "STRING" },
                                            "Geometry": {
                                                type: "OBJECT",
                                                properties: {
                                                    "Polygon": {
                                                        type: "ARRAY",
                                                        items: {
                                                            type: "OBJECT",
                                                            properties: {
                                                                "x": { "type": "NUMBER" },
                                                                "y": { "type": "NUMBER" }
                                                            },
                                                            required: ["x", "y"]
                                                        }
                                                    }
                                                },
                                                required: ["Polygon"]
                                            }
                                        },
                                        required: ["type", "Text", "Geometry"] // typeを必須項目に追加
                                    }
                                }
                            },
                            required: ["Blocks"]
                        }
                    }
                };
            
                try {
                    const apiKey = "AIzaSyAjbITp1Dbv-AyO4i42L5IWy17g5-ctEjg";
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
            
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
            
                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`API Error: ${response.status} ${errorBody}`);
                    }
            
                    const result = await response.json();
            
                    if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        console.log("AIからのレスポンス(生テキスト):", jsonText); 
                        try {
                            const parsedJson = JSON.parse(jsonText);
                            console.log("AIからのレスポンス(パース後):", parsedJson); // パース後のオブジェクトも確認
                            return parsedJson;
                        } catch (e) {
                            console.error("JSONのパースに失敗しました:", e);
                            console.error("パースしようとしたテキスト:", jsonText);
                            return null; // パース失敗時はnullを返す
                        }
                        //return JSON.parse(jsonText);
                    } else {
                        console.error("AIからの応答が予期した形式ではありません。レスポンス全体:", result);
                        throw new Error("AIからの応答が予期した形式ではありません。");
                    }
                } catch (error) {
                    console.error("AIの解析中にエラーが発生しました:", error);
                    alert("AIの解析に失敗しました。時間をおいて再度お試しください。");
                    return null;
                }
            };

            const straightenAndAlignPolygon = (points, threshold = 10) => {
                if (points.length < 3) return points;
            
                // 座標の「揺れ」を吸収するためのクラスタリング関数
                const clusterValues = (values, threshold) => {
                    values.sort((a, b) => a - b);
                    const clusters = [];
                    if (values.length === 0) return {};
            
                    let currentCluster = [values[0]];
                    for (let i = 1; i < values.length; i++) {
                        if (values[i] - currentCluster[currentCluster.length - 1] <= threshold) {
                            currentCluster.push(values[i]);
                        } else {
                            clusters.push(currentCluster);
                            currentCluster = [values[i]];
                        }
                    }
                    clusters.push(currentCluster);
            
                    const map = {};
                    clusters.forEach(cluster => {
                        const representative = cluster[Math.floor(cluster.length / 2)]; // 中央値を代表値とする
                        cluster.forEach(val => {
                            map[val] = representative;
                        });
                    });
                    return map;
                };
            
                const allX = [...new Set(points.map(p => p.x))];
                const allY = [...new Set(points.map(p => p.y))];
            
                const xMap = clusterValues(allX, threshold);
                const yMap = clusterValues(allY, threshold);
                
                let newPoints = points.map(p => ({
                    x: xMap[p.x],
                    y: yMap[p.y]
                }));
            
                // 連続する重複頂点を削除
                newPoints = newPoints.filter((point, i) => {
                    const prev = newPoints[i === 0 ? newPoints.length - 1 : i - 1];
                    return point.x !== prev.x || point.y !== prev.y;
                });
                
                // 3点以上が直線上に並んでしまう中間点を削除
                const finalPoints = [];
                if (newPoints.length > 2) {
                    for (let i = 0; i < newPoints.length; i++) {
                        const p1 = newPoints[i];
                        const p2 = newPoints[(i + 1) % newPoints.length];
                        const p3 = newPoints[(i + 2) % newPoints.length];
            
                        // 3点が同じX座標またはY座標を持つ場合、中間点(p2)をスキップ
                        const isCollinear = (p1.x === p2.x && p2.x === p3.x) || (p1.y === p2.y && p2.y === p3.y);
                        if (!isCollinear) {
                            finalPoints.push(p2);
                        }
                    }
                } else {
                    return newPoints;
                }
                
                // フィルター処理で点が減りすぎた場合のフォールバック
                if(finalPoints.length < 3) return newPoints;
            
                return finalPoints;
            };

            const generateDrawingFromAi = useCallback((aiData, dimensions, originalImageDimensions) => {
                if (!aiData.Blocks || aiData.Blocks.length === 0) return [];
            
                const canvasWidth = dimensions.width;
                const canvasHeight = dimensions.height;
            
                // 1. AIが返した全座標から、間取り図全体の大きさを推定する
                let allPointsX = [];
                let allPointsY = [];
                aiData.Blocks.forEach(block => {
                    if (block.Geometry.Polygon) {
                        block.Geometry.Polygon.forEach(p => {
                            allPointsX.push(p.x);
                            allPointsY.push(p.y);
                        });
                    }
                });
            
                if (allPointsX.length === 0) return [];
            
                const minX = Math.min(...allPointsX);
                const minY = Math.min(...allPointsY);
                const maxX = Math.max(...allPointsX);
                const maxY = Math.max(...allPointsY);
            
                const aiDrawingWidth = maxX - minX;
                const aiDrawingHeight = maxY - minY;
            
                if (aiDrawingWidth === 0 || aiDrawingHeight === 0) return [];
            
                // --- ▼▼▼ ここを微調整します (0.95 → 0.9) ▼▼▼ ---
                // 2. AIが認識した間取り図のサイズが、キャンバスにフィットするように縮尺を計算
                const scaleX = canvasWidth / aiDrawingWidth;
                const scaleY = canvasHeight / aiDrawingHeight;
                const fitScale = Math.min(scaleX, scaleY) * 0.9; // さらに余白を持たせるため、係数を0.9に変更
                // --- ▲▲▲ ここまで ▲▲▲ ---
            
                // 3. 中央に配置するためのオフセットを計算
                const displayedWidth = aiDrawingWidth * fitScale;
                const displayedHeight = aiDrawingHeight * fitScale;
                const offsetX = (canvasWidth - displayedWidth) / 2;
                const offsetY = (canvasHeight - displayedHeight) / 2;
            
                const newElements = [];
                aiData.Blocks.forEach((block, index) => {
                    if (!block.Geometry.Polygon || block.Geometry.Polygon.length < 3) return;
            
                    // 4. 新しく計算したスケールとオフセットで座標を変換
                    let points = block.Geometry.Polygon.map(p => ({
                        x: ((p.x - minX) * fitScale) + offsetX,
                        y: ((p.y - minY) * fitScale) + offsetY
                    }));
                    
                    // 後処理の補正関数を呼び出す
                    points = straightenAndAlignPolygon(points);
            
                    const subGroupId = `space-group-ai-${Date.now()}-${index}`;
            
                    // 部屋のタイプ名を変換
                    let spaceType = block.type;
                    const text = block.Text || "";
                    if (spaceType === "Room") {
                        if (text.includes("LDK")) spaceType = "LDK";
                        else if (text.includes("洋室")) spaceType = "居室";
                        else if (text.includes("和室")) spaceType = "和室";
                        else if (text.includes("洗面")) spaceType = "洗面所";
                        else if (text.includes("浴室")) spaceType = "浴室";
                        else if (text.includes("トイレ")) spaceType = "トイレ";
                        else if (text.includes("玄関")) spaceType = "玄関";
                        else spaceType = "居室";
                    } else if (spaceType === "Storage" || spaceType === "Cabinet") {
                        spaceType = "収納";
                    } else if (spaceType === "Balcony") {
                        spaceType = "バルコニー";
                    }
            
                    const spaceElement = {
                        id: subGroupId,
                        type: 'space',
                        shape: 'polygon',
                        spaceType: spaceType,
                        groupId: subGroupId,
                        points: points.map(p => `${p.x},${p.y}`).join(' '),
                        fill: DEFAULT_FILL_COLORS[spaceType] || '#ffffff',
                        backgroundPattern: 'none'
                    };
                    newElements.push(spaceElement);
            
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        newElements.push({
                            id: `wall-ai-${Date.now()}-${index}-${i}`,
                            type: 'wall',
                            groupId: subGroupId,
                            edgeIndex: i,
                            x1: p1.x, y1: p1.y,
                            x2: p2.x, y2: p2.y,
                            color: DEFAULT_STROKE_COLOR,
                            strokeWidth: DEFAULT_STROKE_WIDTH,
                            lineStyle: 'solid'
                        });
                    }
            
                    const centroid = getPolygonCentroid(points);
                    const labelElement = {
                        id: `text-ai-${Date.now()}-${index}`,
                        type: 'text',
                        groupId: subGroupId,
                        x: (centroid.x / dimensions.width) * 100,
                        y: (centroid.y / dimensions.height) * 100,
                        text: block.Text,
                        color: '#000000',
                        backgroundColor: 'none',
                        fontSize: 16,
                        fontFamily: 'sans-serif',
                        textAlign: 'center',
                    };
                    newElements.push(labelElement);
                });
            
                return newElements;
            }, [dimensions]);

            const handleModalSubmit = useCallback(async (imageDataUrl, useAi) => {
                const img = new Image();
                img.onload = async () => {
                    const imageWidth = img.naturalWidth;
                    const imageHeight = img.naturalHeight;

                    setOriginalImageDimensions({ width: imageWidth, height: imageHeight });

                    const canvasWidth = dimensions.width;
                    const canvasHeight = dimensions.height;
                    const scaleX = canvasWidth / imageWidth;
                    const scaleY = canvasHeight / imageHeight;
                    const fitScale = Math.min(scaleX, scaleY);
                    
                    setImageUrl(imageDataUrl);
                    setImageScale(fitScale);
                    setImagePosition({ x: 0, y: 0 });
                    
                    if (useAi) {
                        setIsLoading(true);
                        try {
                            setLoadingMessage('AIが間取り図を解析中...');
                            // AI呼び出しを1回に統合
                            const finalOcrData = await analyzeImageWithAI(imageDataUrl);

                            if (finalOcrData && finalOcrData.Blocks) {
                                const newElements = generateDrawingFromAi(finalOcrData, dimensions, { width: imageWidth, height: imageHeight });
                                setHistoryState(prev => ({
                                    past: [...prev.past, prev.present],
                                    present: {
                                        ...prev.present,
                                        svgElements: [...prev.present.svgElements, ...newElements],
                                        ocrData: finalOcrData // 最終的なデータを保存
                                    },
                                    future: []
                                }));
                            } else {
                                throw new Error("AIからの応答が不正、または空です。");
                            }
                        } catch (err) {
                            console.error("AI処理エラー:", err);
                            alert(`エラーが発生しました: ${err.message}`);
                        } finally {
                            setIsLoading(false);
                            setUploadModalOpen(false);
                        }
                    } else {
                    setUploadModalOpen(false);
                    }
                };
                img.src = imageDataUrl;
            }, [dimensions, analyzeImageWithAI, generateDrawingFromAi]);

            const getCanvasCoords = useCallback((event) => {
                const svg = svgRef.current;
                if (!svg) return { x: 0, y: 0 };
                const svgRect = svg.getBoundingClientRect();
                const x = (event.clientX - svgRect.left) / zoom;
                const y = (event.clientY - svgRect.top) / zoom;
                return { x, y };
            }, [zoom]);

            const getGridSnappedPoint = useCallback((point) => {
                return {
                    x: Math.floor(point.x / gridSize) * gridSize + gridSize / 2,
                    y: Math.floor(point.y / gridSize) * gridSize + gridSize / 2
                };
            }, [gridSize]);

            const finishDrawing = useCallback(() => {
                if (drawingMode === 'space' && spaceShape === 'line' && linePoints.length > 1) {
                    createPolygonSpace(linePoints);
                } else if (drawingMode === 'stairs' && linePoints.length > 1) {
                    createStairs(linePoints);
                }
                setLinePoints([]);
            }, [linePoints, drawingMode, spaceShape, createPolygonSpace, createStairs]);

            const handleCanvasClick = useCallback((e) => {
                if (e.button === 2) return;
                const clickPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
            
                if (editorMode === 'edit') {
                    setSelectedId(targetId);
                    return;
                }
            
                if (editorMode === 'create' || editorMode === 'continuous-create') {
                    // 3クリック目：Fixture(設備)の回転・反転を確定
                    if (pendingFixture) {
                        const startPoint = pendingFixture;
                        const currentPos = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                        const dx = currentPos.x - startPoint.x;
                        const dy = currentPos.y - startPoint.y;
                        const finalRotation = fixtureRotation + ((dx < 0) ? 180 : 0);
                        const isFlipped = (dy > 0);
                        createItem(startPoint, null, { rotation: finalRotation, isFlipped: isFlipped });
                        setPendingFixture(null);
                        if (editorMode === 'create') setEditorMode('edit');
                        return;
                    }
            
                    // 3クリック目：ドア・窓の向きを確定
                    if (pendingWindow) {
                        const center = { x: (pendingWindow.start.x + pendingWindow.end.x) / 2, y: (pendingWindow.start.y + pendingWindow.end.y) / 2 };
                        const dx = clickPos.x - center.x;
                        const dy = clickPos.y - center.y;
                        let rotation = 0;
                        let isInner = false;
                        if (dx < 0 && dy < 0) { rotation = 180; isInner = true; }
                        else if (dx > 0 && dy < 0) { rotation = 0; isInner = false; }
                        else if (dx > 0 && dy > 0) { rotation = 0; isInner = true; }
                        else { rotation = 180; isInner = false; }
                        createItem(pendingWindow.start, pendingWindow.end, { rotation, isInner });
                        setPendingWindow(null);
                        setSnappedInfo(null);
                        activeSnapWallRef.current = null;
                        if (editorMode === 'create') setEditorMode('edit');
                        return;
                    }
                    
                    // 多角形描画の途中・完了クリック
                    if ((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs') {
                        const clickedPoint = mousePos;
                        if (linePoints.length > 1) { 
                            const lastPoint = linePoints[linePoints.length - 1];
                            const distToLast = Math.sqrt(Math.pow(clickPos.x - lastPoint.x, 2) + Math.pow(clickPos.y - lastPoint.y, 2));
            
                            if (distToLast < SNAP_THRESHOLD / zoom) {
                                if (drawingMode === 'stairs') createStairs(linePoints);
                                else createPolygonSpace(linePoints);
                                setLinePoints([]);
                                setSnappedInfo(null);
                                return;
                            }
                            if (drawingMode === 'space' && spaceShape === 'line') {
                                const firstPoint = linePoints[0];
                                const distToStart = Math.sqrt(Math.pow(clickPos.x - firstPoint.x, 2) + Math.pow(clickPos.y - firstPoint.y, 2));
                                if (distToStart < SNAP_THRESHOLD / zoom) {
                                    createPolygonSpace([...linePoints, firstPoint]);
                                    setLinePoints([]);
                                    setSnappedInfo(null);
                                    return;
                                }
                            }
                        }
                        if (drawingMode === 'stairs' && stairSnapPreview && linePoints.length === 0) {
                            setLinePoints([stairSnapPreview.center]);
                            setStairSnapPreview(null);
                            return;
                        }
                        setLinePoints(prev => [...prev, clickedPoint]);
                        setSnappedInfo(null);
                        return;
                    }
            
                    // 1クリック目の処理
                    if (!drawingStartPoint) {
                        const finalStartPoint = snappedInfo
                            ? snappedInfo.point
                            : ((isGridVisible && !isModifierKeyDown) ? getGridSnappedPoint(clickPos) : clickPos);
            
                        // スナップがグリッドによるものだったかを記録
                        const wasWallOrVertexSnap = !!(snappedInfo && snappedInfo.type !== 'grid') || !!activeSnapWallRef.current;
                        isGridSnapStart.current = (isGridVisible && !isModifierKeyDown) && !wasWallOrVertexSnap;
                        
                        if (drawingMode === 'fixture') {
                            setPendingFixture(finalStartPoint);
                        } else if (drawingMode === 'text') {
                            createItem(finalStartPoint);
                        } else {
                            setDrawingStartPoint(finalStartPoint);
                        }
                        setSnappedInfo(null);
                    }
                }
            }, [
                svgElements, editorMode, drawingMode, spaceShape, drawingStartPoint, linePoints, pendingWindow, pendingFixture,
                isGridVisible, getCanvasCoords, getGridSnappedPoint, dimensions, strokeColor,
                fontSize, fontFamily, textAlign, fixtureTemplateId, fixtureCategory, spaceType,
                fillColor, lineStyle, compassTemplateId, doorTemplateId, windowTemplateId, zoom,
                backgroundPattern, createPolygonSpace, createItem, createStairs,
                isSnapToWall, snappedInfo, fixtureRotation, fixtureFlip, isModifierKeyDown, finishDrawing,
                stairSnapPreview, mousePos
            ]);

            const createPolygonSpace = useCallback((points) => {
                // ポリゴンが閉じていない場合（線分ツールで描画した場合など）に、始点と終点を連結して閉じる
                if (points.length > 2 && (points[0].x !== points[points.length - 1].x || points[0].y !== points[points.length - 1].y)) {
                    points.push(points[0]);
                }
                // 稀に発生する末尾の重複点を削除
                if (points.length > 1 && points[points.length-1].x === points[points.length-2].x && points[points.length-1].y === points[points.length-2].y) {
                    points.pop();
                }

                const groupId = `space-group-${Date.now()}`;
                const newElements = [];
            
                // 選択中の空間タイプに基づいてスタイルを決定
                const specialProps = SUB_TYPE_PROPERTIES[spaceType];
                const finalLineStyle = specialProps?.lineStyle !== undefined ? specialProps.lineStyle : lineStyle;
                const finalStrokeWidth = specialProps?.strokeWidth !== undefined ? specialProps.strokeWidth : strokeWidth;
                const finalFillColor = specialProps?.fill !== undefined ? specialProps.fill : fillColor;
                const finalStrokeColor = strokeColor;

                let finalBackgroundPattern = backgroundPattern;
                if (spaceType === '玄関') finalBackgroundPattern = 'grid-small';
                if (spaceType === '和室') finalBackgroundPattern = 'grid-large';
                if (['吹抜', 'グルニエ', '折上天井', '床下収納'].includes(spaceType)) {
                    finalBackgroundPattern = 'dotted-x';
                }

                // 1. 空間要素を作成 (塗りつぶしと背景のみ、枠線はなし)
                const spaceElement = {
                    id: groupId, type: 'space', shape: 'polygon', spaceType: spaceType, groupId,
                    points: points.map(p => `${p.x},${p.y}`).join(' '),
                    fill: finalFillColor,
                    backgroundPattern: finalBackgroundPattern,
                    // 壁のスタイル情報をspace要素に持たせておく（編集パネルで参照するため）
                    stroke: finalStrokeColor,
                    strokeWidth: finalStrokeWidth,
                    lineStyle: finalLineStyle
                };
                newElements.push(spaceElement);

                // 2. 各辺に対応する壁要素を個別に作成
                for (let i = 0; i < points.length - 1; i++) { // 最後の点は始点と同じなのでループは-1まで
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    
                    if (p1.x === p2.x && p1.y === p2.y) continue; // 同じ点への線は作成しない
                    
                    newElements.push({
                        id: `wall-${groupId}-${i}`,
                        type: 'wall',
                        groupId: groupId,
                        edgeIndex: i,
                        x1: p1.x, y1: p1.y,
                        x2: p2.x, y2: p2.y,
                        stroke: spaceElement.stroke,
                        strokeWidth: spaceElement.strokeWidth,
                        lineStyle: spaceElement.lineStyle
                    });
                }

                // 3. ラベル用のテキスト要素を作成
                const centroid = getPolygonCentroid([...points]);
                const labelElement = createSpaceLabel(spaceType, centroid, dimensions);
                if (labelElement) {
                    labelElement.groupId = groupId;
                    newElements.push(labelElement);
                }
                
                setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                if (editorMode === 'create') {
                    setEditorMode('edit');
                }
                if (editorMode !== 'continuous-create') {
                    setSelectedId(groupId);
                }
            }, [spaceType, backgroundPattern, fillColor, strokeColor, lineStyle, strokeWidth, dimensions, editorMode]);

            const createStairs = useCallback((points) => {
                const stairId = `stairs-${Date.now()}`; // 階段とテキストの共通ID

                // 1. 階段要素を作成
                const newStairElement = {
                    id: stairId,
                    type: 'stairs',
                    groupId: stairId, // グループIDを追加
                    points: points.map(p => `${p.x},${p.y}`).join(' '),
                    width: stairWidth,
                    color: strokeColor,
                    strokeWidth: DEFAULT_STROKE_WIDTH,
                };

                // 2. 階段に付随するテキスト要素を別途作成
                let newTextElement = null;
                if (points.length >= 2) {
                    const startPoint = points[0];
                    const nextPoint = points[1];

                    const arrowVec = { x: nextPoint.x - startPoint.x, y: nextPoint.y - startPoint.y };
                    const arrowLen = Math.sqrt(arrowVec.x**2 + arrowVec.y**2);
                    const arrowDir = arrowLen > 0 ? { x: arrowVec.x / arrowLen, y: arrowVec.y / arrowLen } : { x: 0, y: 0 };
                    const arrowAngle = Math.atan2(arrowDir.y, arrowDir.x) * 180 / Math.PI;

                    const textOffsetX = -arrowDir.x * 20;
                    const textOffsetY = -arrowDir.y * 20;

                    const textContent = stairDirection === 'up' ? 'UP' : stairDirection === 'down' ? 'DN' : '';

                    // テキストが非表示でない場合のみ要素を作成
                    if (stairDirection !== 'none') {
                        newTextElement = {
                            id: `text-${Date.now()}`,
                            type: 'text',
                            groupId: stairId,
                            x: ((startPoint.x + textOffsetX) / dimensions.width) * 100,
                            y: ((startPoint.y + textOffsetY) / dimensions.height) * 100,
                            text: textContent,
                            color: strokeColor,
                            fontSize: 12,
                            fontFamily: 'sans-serif',
                            textAlign: 'center',
                            rotation: arrowAngle + 90
                        };
                    }
                }

                const elementsToAdd = [newStairElement];
                if (newTextElement) {
                    elementsToAdd.push(newTextElement);
                }

                setHistoryState(prev => ({ 
                    past: [...prev.past, prev.present], 
                    present: { ...prev.present, svgElements: [...prev.present.svgElements, ...elementsToAdd] }, 
                    future: [] 
                }));

                if (editorMode === 'create') {
                    setEditorMode('edit');
                }
                if (editorMode !== 'continuous-create') {
                    setSelectedId(newStairElement.id);
                }
            }, [stairWidth, stairDirection, strokeColor, editorMode, dimensions]);

            const createItem = (start, end, options = {}) => {
                const newElements = [];
                let newElementId = null;

                if (drawingMode === 'wall') {
                    const newElement = { id: `wall-${Date.now()}`, type: 'wall', x1: start.x, y1: start.y, x2: end.x, y2: end.y, stroke: strokeColor, strokeWidth: strokeWidth, lineStyle: lineStyle };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'compass') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const size = Math.min(300, Math.max(20, distance));
                    const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                    const newElement = { id: `compass-${Date.now()}`, type: 'compass', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100, size: size, rotation: rotation, templateId: compassTemplateId };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'door' || drawingMode === 'window') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const baseAngle = Math.atan2(dy, dx) * 180 / Math.PI;

                    const finalWallThickness = (isSnapToWall && activeSnapWallRef.current)
                    ? activeSnapWallRef.current.strokeWidth
                    : wallObjectThickness;

                    const newElement = {
                        id: `${drawingMode}-${Date.now()}`,
                        type: drawingMode,
                        templateId: drawingMode === 'door' ? doorTemplateId : windowTemplateId,
                        x1: start.x,
                        y1: start.y,
                        x2: end.x,
                        y2: end.y,
                        length: length,
                        baseAngle: baseAngle,
                        // ▼▼▼ options から回転と反転フラグを受け取るように修正 ▼▼▼
                        rotation: options.rotation || 0,
                        isInner: options.isInner !== undefined ? options.isInner : true,
                        // ▲▲▲ ここまで ▲▲▲
                        swingDirection: 'clockwise',
                        wallThickness: finalWallThickness,
                        color: DEFAULT_STROKE_COLOR,
                        strokeWidth: DEFAULT_STROKE_WIDTH
                    };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'text') {
                    const newElement = {
                        id: `text-${Date.now()}`, type: 'text', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100,
                        text: "テキスト", color: strokeColor, fontSize: fontSize, fontFamily: fontFamily, textAlign: textAlign, backgroundColor: 'none',
                        writingMode: 'horizontal' // ★★★ この行を追加 ★★★
                    };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'fixture') {
                    const template = FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {};
                    const baseSize = BASE_FIXTURE_DEFAULT_SIZE;
                    const templateDefaultSize = template.defaultSize || baseSize; // defaultSizeが未定義なら基準サイズを使う
                    // UIスライダーの値とdefaultSizeから、実際の描画サイズを計算
                    const actualWidth = fixtureSize * (baseSize / templateDefaultSize);
                    const aspectRatio = template.aspectRatio || 1;
                    const actualHeight = actualWidth / aspectRatio;
                    const newElement = {
                        id: `fixture-${Date.now()}`,
                        type: 'fixture',
                        x: (start.x / dimensions.width) * 100,
                        y: (start.y / dimensions.height) * 100,
                        templateId: fixtureTemplateId,
                        width: actualWidth,
                        height: actualHeight,
                        rotation: options.rotation !== undefined ? options.rotation : fixtureRotation,
                        isFlipped: options.isFlipped !== undefined ? options.isFlipped : fixtureFlip,
                        fill: template.defaultFill,
                        stroke: template.defaultStroke,
                        strokeWidth: template.defaultStrokeWidth
                    };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                }

                if (newElements.length > 0) {
                    setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                     if (editorMode === 'create') {
                        setEditorMode('edit');
                    }
                    if (editorMode !== 'continuous-create') {
                        setSelectedId(newElementId);
                    }
                }
            };

            const handleMouseDown = useCallback((e) => {
                if (e.button === 2) return;
                e.stopPropagation();

                if (!drawingMode && !imageUrl && editorMode !== 'edit') {
                    const clickPos = getCanvasCoords(e);

                    // 既存のタイマーをクリア
                    tooltipTimers.current.forEach(clearTimeout);

                    setTooltip({
                        visible: true,
                        fading: false,
                        x: clickPos.x,
                        y: clickPos.y,
                        message: "下絵を選択、もしくは描画したい項目を選択してください。"
                    });

                    // 3秒後にフェードアウトを開始するタイマー
                    const fadeTimer = setTimeout(() => {
                        setTooltip(prev => ({ ...prev, fading: true }));
                    }, 3000);

                    // 5秒後 (3秒表示 + 2秒フェード) に完全に非表示にするタイマー
                    const hideTimer = setTimeout(() => {
                        setTooltip(prev => ({ ...prev, visible: false, fading: false }));
                    }, 5000);

                    tooltipTimers.current = [fadeTimer, hideTimer];
                }

                if (isDisplaySettingsOpen && !drawingMode) {
                    // 表示設定が開いている時は、下絵のドラッグ操作を開始する
                    imageDragInfo.current = {
                        startMouseX: e.clientX,
                        startMouseY: e.clientY,
                        initialImageX: imagePosition.x,
                        initialImageY: imagePosition.y
                    };
                    return; // 図形描画処理は行わずに終了
                }

                const startCanvasX = getCanvasCoords(e).x;
                const startCanvasY = getCanvasCoords(e).y;
                mouseDownInfo.current = { x: e.clientX, y: e.clientY };

                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);

                if (editorMode === 'edit') {
                    const handleIndex = e.target.dataset.handleIndex;
                    const handleType = e.target.dataset.handleType;
                    if (handleIndex !== undefined) {
                        const elementId = e.target.dataset.id;
                        const elementToResize = svgElements.find(el => el.id === elementId);
                        if (elementToResize) {
                            setResizingHandleInfo({
                                id: elementId,
                                handleIndex: parseInt(handleIndex, 10),
                                type: handleType,
                                // リサイズ前の要素の状態を保存
                                startElement: { ...elementToResize },
                                // リサイズ開始時のマウス座標を保存
                                startMousePos: getCanvasCoords(e)
                            });
                            historyOnActionStart.current = historyState.present;
                            return;
                        }
                    }

                    dragTarget.current = targetElement;
                    if (targetElement) {
                        const initialElementCenter = getCenterPointForElement(targetElement, dimensions);
                        dragInfo.current = {
                            startMouseX: startCanvasX,
                            startMouseY: startCanvasY,
                            initialElementCenterX: initialElementCenter.x,
                            initialElementCenterY: initialElementCenter.y,
                        };
                        historyOnActionStart.current = historyState.present;
                    } else {
                        setSelectedId(null);
                    }
                } else { // create mode
                    if (!((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs')) {
                        setLinePoints([]);
                    }
                }
            }, [
                isDisplaySettingsOpen, imagePosition, getCanvasCoords, svgElements, editorMode, 
                selectedId, historyState.present, drawingMode, spaceShape, dimensions,
                isDisplaySettingsOpen, imagePosition, getCanvasCoords, svgElements, editorMode, 
                selectedId, historyState.present, drawingMode, spaceShape, dimensions, imageUrl, setTooltip
            ]);

            const handleMouseMove = useCallback((e) => {
                if (contextMenuRef.current && contextMenuRef.current.contains(e.target)) {
                    return;
                }
                const currentMousePos = getCanvasCoords(e);

                if (drawingMode === 'wall' && drawingStartPoint && !isModifierKeyDown) {
                    const dx = currentMousePos.x - drawingStartPoint.x;
                    const dy = currentMousePos.y - drawingStartPoint.y;
                
                    // 始点からの角度を計算 (ラジアンから度に変換)
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                    // スナップが作動する角度の閾値 (6度以内であればスナップ)
                    const snapAngleThreshold = 6; 
                
                    // 水平方向 (0度, 180度) へのスナップ判定
                    if (
                        Math.abs(angle) < snapAngleThreshold || 
                        Math.abs(angle - 180) < snapAngleThreshold || 
                        Math.abs(angle + 180) < snapAngleThreshold 
                    ) {
                        currentMousePos.y = drawingStartPoint.y; // Y座標を始点に固定
                    } 
                    // 垂直方向 (90度, -90度) へのスナップ判定
                    else if (
                        Math.abs(angle - 90) < snapAngleThreshold || 
                        Math.abs(angle + 90) < snapAngleThreshold
                    ) {
                        currentMousePos.x = drawingStartPoint.x; // X座標を始点に固定
                    }
                    // どの角度にも近くない場合は、スナップせずそのままの座標を使用
                }

                if (imageDragInfo.current) {
                    const dx = e.clientX - imageDragInfo.current.startMouseX;
                    const dy = e.clientY - imageDragInfo.current.startMouseY;
                    setImagePosition({
                        x: imageDragInfo.current.initialImageX + (dx / zoom),
                        y: imageDragInfo.current.initialImageY + (dy / zoom)
                    });
                    return;
                }
                
                let previewEndPoint = (isGridVisible && !isModifierKeyDown) ? getGridSnappedPoint(currentMousePos) : currentMousePos;
                let newSnappedInfo = null;
                let newGuideLines = [];
                const snapThreshold = SNAP_THRESHOLD / zoom;
                const isSnappingEnabled = (drawingMode !== 'none') && isSnapToWall && !isModifierKeyDown;
            
                if (drawingMode === 'stairs' && isSnappingEnabled) {
                    const allWallSegments = [];
                    const pointsToSnapAgainst = [];
                    svgElements.forEach(el => {
                        if (el.type === 'wall') {
                            const p1 = { x: el.x1, y: el.y1 }; const p2 = { x: el.x2, y: el.y2 };
                            allWallSegments.push({ ...el, p1, p2 });
                            pointsToSnapAgainst.push(p1, p2);
                        } else if (el.type === 'space' || el.type === 'stairs') {
                            const points = el.points.split(' ').map(p_str => ({x: parseFloat(p_str.split(',')[0]), y: parseFloat(p_str.split(',')[1])}));
                            pointsToSnapAgainst.push(...points);
                            if (el.type === 'space') {
                                for (let i = 0; i < points.length; i++) {
                                    allWallSegments.push({ ...el, p1: points[i], p2: points[(i + 1) % points.length] });
                                }
                            }
                        }
                    });
                    if (linePoints.length > 0) pointsToSnapAgainst.push(...linePoints);
            
                    if (linePoints.length > 0) {
                        setStairSnapPreview(null);
                        const lastPoint = linePoints[linePoints.length - 1];
                        const prevPoint = linePoints.length > 1 ? linePoints[linePoints.length - 2] : null;
                        let uShapeSnapApplied = false;
    
                        if (linePoints.length === 2) {
                            const p1 = linePoints[0];
                            const p2 = linePoints[1];
                            const stairW = stairWidth;
            
                            const isHorizontal = Math.abs(p2.x - p1.x) > Math.abs(p2.y - p1.y);
                            
                            let previewOnLine;
            
                            if (isHorizontal) {
                                previewOnLine = { x: p2.x, y: currentMousePos.y };
                            } else {
                                previewOnLine = { x: currentMousePos.x, y: p2.y };
                            }
                            
                            const vec_p2_to_mouse = { x: previewOnLine.x - p2.x, y: previewOnLine.y - p2.y };
                            const distance = Math.sqrt(vec_p2_to_mouse.x**2 + vec_p2_to_mouse.y**2);
            
                            if (distance > 0) {
                                const multiple = Math.round(distance / stairW);
            
                                if (multiple > 0) {
                                    const snappedDistance = multiple * stairW;
                                    
                                    const snappedPoint = {
                                        x: p2.x + (vec_p2_to_mouse.x / distance) * snappedDistance,
                                        y: p2.y + (vec_p2_to_mouse.y / distance) * snappedDistance
                                    };
            
                                    const distToSnap = Math.sqrt((previewOnLine.x - snappedPoint.x)**2 + (previewOnLine.y - snappedPoint.y)**2);
            
                                    if (distToSnap < snapThreshold) {
                                        previewEndPoint = snappedPoint;
                                        newSnappedInfo = { point: snappedPoint, type: 'vertex' };
                                        uShapeSnapApplied = true;
                                    } else {
                                        previewEndPoint = previewOnLine;
                                    }
                                } else {
                                    previewEndPoint = previewOnLine;
                                }
                            }
                            uShapeSnapApplied = true;
                        }
                        
                        if (!uShapeSnapApplied) {
                            let snapCandidate = null;
                            if (allWallSegments.length > 0) {
                                let minDistanceSq = Infinity, tempClosestPointOnWall = null, tempClosestWall = null;
                                for (const wall of allWallSegments) {
                                    const p1 = wall.p1, p2 = wall.p2, dx = p2.x - p1.x, dy = p2.y - p1.y;
                                    if (dx === 0 && dy === 0) continue;
                                    const t = ((currentMousePos.x - p1.x) * dx + (currentMousePos.y - p1.y) * dy) / (dx * dx + dy * dy);
                                    const clampedT = Math.max(0, Math.min(1, t));
                                    const pointOnLine = { x: p1.x + clampedT * dx, y: p1.y + clampedT * dy };
                                    const distSq = (currentMousePos.x - pointOnLine.x) ** 2 + (currentMousePos.y - pointOnLine.y) ** 2;
                                    if (distSq < minDistanceSq) { minDistanceSq = distSq; tempClosestWall = wall; tempClosestPointOnWall = pointOnLine; }
                                }
                    
                                if (minDistanceSq < (snapThreshold * 5) ** 2) {
                                    const { closestPointOnWall, closestWall } = { closestPointOnWall: tempClosestPointOnWall, closestWall: tempClosestWall };
                                    const wallDx = closestWall.p2.x - closestWall.p1.x, wallDy = closestWall.p2.y - closestWall.p1.y;
                                    const wallLen = Math.sqrt(wallDx**2 + wallDy**2);
                                    if (wallLen > 0) {
                                        const perp = { x: -wallDy / wallLen, y: wallDx / wallLen };
                                        const vecToMouse = { x: currentMousePos.x - closestPointOnWall.x, y: currentMousePos.y - closestPointOnWall.y };
                                        const dotProduct = vecToMouse.x * perp.x + vecToMouse.y * perp.y;
                                        const side = Math.sign(dotProduct) || 1;
                                        const offsetPoint = { x: closestPointOnWall.x + side * perp.x * (stairWidth / 2), y: closestPointOnWall.y + side * perp.y * (stairWidth / 2) };
                                        const isPrevHorizontal = prevPoint ? Math.abs(lastPoint.y - prevPoint.y) < 1 : Math.abs(offsetPoint.x - lastPoint.x) > Math.abs(offsetPoint.y - lastPoint.y);
                                        snapCandidate = isPrevHorizontal ? { x: offsetPoint.x, y: lastPoint.y } : { x: lastPoint.x, y: offsetPoint.y };
                                    }
                                }
                            }
                    
                            if (snapCandidate) {
                                const distToSnap = Math.sqrt(Math.pow(currentMousePos.x - snapCandidate.x, 2) + Math.pow(currentMousePos.y - snapCandidate.y, 2));
                                if (distToSnap < snapThreshold * 2) {
                                    previewEndPoint = snapCandidate;
                                    newSnappedInfo = { point: previewEndPoint, type: 'wall' };
                                }
                            }
                        }
                    } else {
                        setStairSnapPreview(null);
                        if (allWallSegments.length > 0) {
                            let minDistanceSq = Infinity, closestPointOnWall = null, closestWall = null;
                            for (const wall of allWallSegments) {
                                const p1 = wall.p1, p2 = wall.p2, dx = p2.x - p1.x, dy = p2.y - p1.y;
                                if (dx === 0 && dy === 0) continue;
                                const t = ((currentMousePos.x - p1.x) * dx + (currentMousePos.y - p1.y) * dy) / (dx * dx + dy * dy);
                                const clampedT = Math.max(0, Math.min(1, t));
                                const pointOnLine = { x: p1.x + clampedT * dx, y: p1.y + clampedT * dy };
                                const distSq = (currentMousePos.x - pointOnLine.x) ** 2 + (currentMousePos.y - pointOnLine.y) ** 2;
                                if (distSq < minDistanceSq) { minDistanceSq = distSq; closestWall = wall; closestPointOnWall = pointOnLine; }
                            }
                
                            if (closestWall && minDistanceSq < (snapThreshold * 5) ** 2) {
                                const wallDx = closestWall.p2.x - closestWall.p1.x, wallDy = closestWall.p2.y - closestWall.p1.y;
                                const wallLen = Math.sqrt(wallDx**2 + wallDy**2);
                                if (wallLen > 0) {
                                    const perp = { x: -wallDy / wallLen, y: wallDx / wallLen };
                                    const vecToMouse = { x: currentMousePos.x - closestPointOnWall.x, y: currentMousePos.y - closestPointOnWall.y };
                                    const dotProduct = vecToMouse.x * perp.x + vecToMouse.y * perp.y;
                                    const side = Math.sign(dotProduct) || 1;
                                    const offsetSnapPoint = { x: closestPointOnWall.x + side * perp.x * (stairWidth / 2), y: closestPointOnWall.y + side * perp.y * (stairWidth / 2) };
                                    const wallAngle = Math.atan2(wallDy, wallDx) * 180 / Math.PI;
                                    setStairSnapPreview({ center: offsetSnapPoint, angle: wallAngle });
                                    previewEndPoint = offsetSnapPoint;
                                }
                            }
                        }
                    }
                } else if (isSnappingEnabled) {
                    let closestSnap = null;
                    let pointsToSnapAgainst = [];
                    svgElements.forEach(el=>{if(el.type==='wall'||el.type==='door'||el.type==='window'){pointsToSnapAgainst.push({x:el.x1,y:el.y1},{x:el.x2,y:el.y2})}else if(el.type==='space'||el.type==='stairs'){pointsToSnapAgainst.push(...el.points.split(' ').map(p_str=>({x:parseFloat(p_str.split(',')[0]),y:parseFloat(p_str.split(',')[1])})))}});if(drawingStartPoint)pointsToSnapAgainst.push(drawingStartPoint);if(linePoints.length>0)pointsToSnapAgainst.push(...linePoints);
                    if (pointsToSnapAgainst.length > 0) {
                        let bestVerticalSnap = null, bestHorizontalSnap = null, minXDist = snapThreshold, minYDist = snapThreshold;
                        pointsToSnapAgainst.forEach(p=>{const distX=Math.abs(currentMousePos.x-p.x);if(distX<minXDist){minXDist=distX;bestVerticalSnap={x:p.x,from:p}}const distY=Math.abs(currentMousePos.y-p.y);if(distY<minYDist){minYDist=distY;bestHorizontalSnap={y:p.y,from:p}}});
                        if(bestVerticalSnap&&bestHorizontalSnap){const intersectionPoint={x:bestVerticalSnap.x,y:bestHorizontalSnap.y};const distToIntersection=Math.sqrt(Math.pow(currentMousePos.x-intersectionPoint.x,2)+Math.pow(currentMousePos.y-intersectionPoint.y,2));if(distToIntersection<snapThreshold){closestSnap={point:intersectionPoint,type:'intersection',guide:{vertical:{from:bestVerticalSnap.from},horizontal:{from:bestHorizontalSnap.from}}}}}
                        if(!closestSnap){if(minXDist<minYDist&&bestVerticalSnap){closestSnap={point:{x:bestVerticalSnap.x,y:currentMousePos.y},type:'extension',guide:{type:'vertical',from:bestVerticalSnap.from}}}else if(bestHorizontalSnap){closestSnap={point:{x:currentMousePos.x,y:bestHorizontalSnap.y},type:'extension',guide:{type:'horizontal',from:bestHorizontalSnap.from}}}}
                    }
                    if (closestSnap) { previewEndPoint = closestSnap.point; newSnappedInfo = closestSnap; if(closestSnap.guide?.type==='vertical'||closestSnap.guide?.type==='horizontal'){newGuideLines.push({x1:closestSnap.guide.from.x,y1:closestSnap.guide.from.y,x2:closestSnap.point.x,y2:closestSnap.point.y})}else if(closestSnap.type==='intersection'){newGuideLines.push({x1:closestSnap.guide.vertical.from.x,y1:closestSnap.guide.vertical.from.y,x2:closestSnap.point.x,y2:closestSnap.point.y});newGuideLines.push({x1:closestSnap.guide.horizontal.from.x,y1:closestSnap.guide.horizontal.from.y,x2:closestSnap.point.x,y2:closestSnap.point.y})}}
                }
            
                setMousePos(previewEndPoint);
                setGuideLines(newGuideLines);
                if (!stairSnapPreview) {
                    setSnappedInfo(newSnappedInfo);
                }
                
                if (editorMode === 'edit' && dragTarget.current && dragInfo.current && mouseDownInfo.current) {
                    const dist = Math.sqrt(Math.pow(e.clientX - mouseDownInfo.current.x, 2) + Math.pow(e.clientY - mouseDownInfo.current.y, 2));
                    if (!isDragging && dist > 5) { setIsDragging(true); setSelectedId(dragTarget.current.id); }
                }
                if (resizingHandleInfo) {
                    const { id, handleIndex, type } = resizingHandleInfo;
                    const snappedPos = (isGridVisible && !isModifierKeyDown) ? getGridSnappedPoint(currentMousePos) : currentMousePos;
                    let newElements = [...historyOnActionStart.current.svgElements];
                    const elementIndex = newElements.findIndex(el => el.id === id);
                    if (elementIndex === -1) return;
                
                    if (type === 'fixtureCorner' || type === 'fixtureEdge') {
                        const { id, handleIndex, type, startElement } = resizingHandleInfo;
                        const elementIndex = newElements.findIndex(el => el.id === id);
                        if (elementIndex === -1) return;
                        
                        // 1. 回転と反転のための初期値を準備
                        const rad = (startElement.rotation || 0) * Math.PI / 180;
                        const cos = Math.cos(rad);
                        const sin = Math.sin(rad);
                        const flip = startElement.isFlipped ? -1 : 1; // 反転係数を追加
                    
                        const startCx = startElement.x / 100 * dimensions.width;
                        const startCy = startElement.y / 100 * dimensions.height;
                        const startW = startElement.width;
                        const startH = startElement.height;
                    
                        // 2. アンカーポイント（動かない基準点）のワールド座標を計算
                        const halfW = startW / 2;
                        const halfH = startH / 2;
                        // ハンドルのローカル座標（中心が0,0）
                        const corners = [
                            {x: -halfW, y: -halfH}, {x: halfW, y: -halfH}, 
                            {x: halfW, y: halfH},   {x: -halfW, y: halfH}
                        ];
                        const edges = [
                            {x: 0, y: -halfH}, {x: halfW, y: 0}, 
                            {x: 0, y: halfH}, {x: -halfW, y: 0}
                        ];
                    
                        const anchorIndex = (handleIndex + 2) % 4; // 対角/対辺のインデックス
                        const anchorLocal = (type === 'fixtureCorner') ? corners[anchorIndex] : edges[anchorIndex];
                    
                        // アンカーのワールド座標（反転も考慮）
                        const anchorGlobal = {
                            x: startCx + (anchorLocal.x * cos * flip - anchorLocal.y * sin),
                            y: startCy + (anchorLocal.x * sin * flip + anchorLocal.y * cos)
                        };
                    
                        // 3. マウスの現在位置からアンカーへのベクトルを、回転・反転を解除したローカルなベクトルに変換
                        const mouseVec = { x: snappedPos.x - anchorGlobal.x, y: snappedPos.y - anchorGlobal.y };
                        const unrotatedMouseVec = {
                            x: (mouseVec.x * cos + mouseVec.y * sin) * flip,
                            y: (-mouseVec.x * sin + mouseVec.y * cos)
                        };
                    
                        let newWidth, newHeight;
                        let newCenterLocal;
                    
                        // 4. 新しい幅、高さ、中心点をローカル座標系で計算
                        if (type === 'fixtureEdge') {
                            const signX = (handleIndex === 1) ? 1 : -1;
                            const signY = (handleIndex === 0) ? -1 : 1; // TopハンドルはY軸負方向
                            switch(handleIndex) {
                                case 0: // Top
                                case 2: // Bottom
                                    newWidth = startW;
                                    newHeight = Math.max(10, signY * unrotatedMouseVec.y);
                                    newCenterLocal = { x: anchorLocal.x, y: anchorLocal.y + (signY * newHeight / 2) };
                                    break;
                                case 1: // Right
                                case 3: // Left
                                    newHeight = startH;
                                    newWidth = Math.max(10, signX * unrotatedMouseVec.x);
                                    newCenterLocal = { x: anchorLocal.x + (signX * newWidth / 2), y: anchorLocal.y };
                                    break;
                            }
                        } else { // fixtureCorner (アスペクト比を維持)
                            const aspectRatio = startW / startH;
                            const signX = (handleIndex === 1 || handleIndex === 2) ? 1 : -1;
                            const signY = (handleIndex === 2 || handleIndex === 3) ? 1 : -1;
                            
                            // マウス位置とアスペクト比から、新しい幅と高さを決定
                            if (Math.abs(unrotatedMouseVec.x / aspectRatio) > Math.abs(unrotatedMouseVec.y)) {
                                newWidth = Math.max(10, Math.abs(unrotatedMouseVec.x));
                                newHeight = newWidth / aspectRatio;
                            } else {
                                newHeight = Math.max(10, Math.abs(unrotatedMouseVec.y));
                                newWidth = newHeight * aspectRatio;
                            }
                            
                            newCenterLocal = {
                                x: anchorLocal.x + (signX * newWidth / 2),
                                y: anchorLocal.y + (signY * newHeight / 2)
                            };
                        }
                    
                        // 5. 新しいローカル中心座標を、回転・反転を考慮してワールド座標に戻す
                        const centerVecFromAnchorLocal = {
                            x: newCenterLocal.x - anchorLocal.x,
                            y: newCenterLocal.y - anchorLocal.y
                        };
                        const centerVecFromAnchorGlobal = {
                            x: centerVecFromAnchorLocal.x * cos * flip - centerVecFromAnchorLocal.y * sin,
                            y: centerVecFromAnchorLocal.x * sin * flip + centerVecFromAnchorLocal.y * cos
                        };
                        const newCx = anchorGlobal.x + centerVecFromAnchorGlobal.x;
                        const newCy = anchorGlobal.y + centerVecFromAnchorGlobal.y;
                    
                        // 6. 計算した新しい値で要素を更新
                        newElements[elementIndex] = {
                            ...startElement,
                            width: newWidth,
                            height: newHeight,
                            x: (newCx / dimensions.width) * 100,
                            y: (newCy / dimensions.height) * 100
                        };
                        
                        setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                        return;
                    }
                    // ▲▲▲ 差し替えはここまで ▲▲▲
                    
                    else if (type === 'wall' || type === 'door' || type === 'window') {
                        const elementToResize = { ...newElements[elementIndex] };
                
                        // 空間に属する壁 (groupId を持つ壁) のリサイズ処理
                        if (type === 'wall' && elementToResize.groupId) {
                            const groupId = elementToResize.groupId;
                            const spaceOfGroup = newElements.find(el => el.id === groupId);
                            
                            if (spaceOfGroup) {
                                // 1. 空間ポリゴンの頂点リストを更新
                                const polygonPoints = spaceOfGroup.points.split(' ').map(p => ({x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1])}));
                                const pointToMoveIndex = (elementToResize.edgeIndex + handleIndex) % polygonPoints.length;
                                polygonPoints[pointToMoveIndex] = { x: snappedPos.x, y: snappedPos.y };
                                
                                // 2. 更新された頂点リストから、関連要素を全て再計算
                                const newPointsStr = polygonPoints.map(p => `${p.x},${p.y}`).join(' ');
                                const newCentroid = getPolygonCentroid([...polygonPoints]);
                
                                newElements = newElements.map(el => {
                                    if (el.groupId !== groupId) return el; // 関係ない要素はスキップ
                
                                    if (el.id === groupId) { // space要素のpointsを更新
                                        return { ...el, points: newPointsStr };
                                    }
                                    if (el.type === 'wall') { // wall要素の始点・終点を更新
                                        const p1 = polygonPoints[el.edgeIndex];
                                        const p2 = polygonPoints[(el.edgeIndex + 1) % polygonPoints.length];
                                        return { ...el, x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
                                    }
                                    if (el.type === 'text') { // text要素の中心位置を更新
                                        return {...el, x: (newCentroid.x / dimensions.width) * 100, y: (newCentroid.y / dimensions.height) * 100 };
                                    }
                                    return el;
                                });
                            }
                        } else { // 独立した壁、またはドア、窓の場合 (従来のロジック)
                            const newElement = elementToResize;
                            if (handleIndex === 0) { newElement.x1 = snappedPos.x; newElement.y1 = snappedPos.y; } 
                            else { newElement.x2 = snappedPos.x; newElement.y2 = snappedPos.y; }
                            
                            if(type==='door'||type==='window'){
                                const dx=newElement.x2-newElement.x1; const dy=newElement.y2-newElement.y1;
                                newElement.length=Math.sqrt(dx*dx+dy*dy);
                                newElement.baseAngle=Math.atan2(dy,dx)*180/Math.PI
                            }
                            newElements[elementIndex] = newElement;
                        }
                    } else if (type === 'spaceCorner' || type === 'spaceEdge') {
                        const groupElements = newElements.filter(el => el.groupId === id); const spaceEl = groupElements.find(el => el.type === 'space'); if (!spaceEl) return; const originalPoints = spaceEl.points.split(' ').map(p => ({x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1])})); const xs = originalPoints.map(p => p.x); const ys = originalPoints.map(p => p.y); const originalBbox = { minX: Math.min(...xs), minY: Math.min(...ys), maxX: Math.max(...xs), maxY: Math.max(...ys) }; let newPoints;
                        if(type==='spaceCorner'){const corners=[{x:originalBbox.minX,y:originalBbox.minY},{x:originalBbox.maxX,y:originalBbox.minY},{x:originalBbox.maxX,y:originalBbox.maxY},{x:originalBbox.minX,y:originalBbox.maxY}];const anchor=corners[(handleIndex+2)%4];const originalCorner=corners[handleIndex];const scaleX=(originalCorner.x-anchor.x)===0?1:(snappedPos.x-anchor.x)/(originalCorner.x-anchor.x);const scaleY=(originalCorner.y-anchor.y)===0?1:(snappedPos.y-anchor.y)/(originalCorner.y-anchor.y);newPoints=originalPoints.map(p=>({x:Math.round(anchor.x+(p.x-anchor.x)*scaleX),y:Math.round(anchor.y+(p.y-anchor.y)*scaleY)}))}else{newPoints=originalPoints.map(p=>{let newP={...p};if(handleIndex===0&&p.y===originalBbox.minY)newP.y=snappedPos.y;if(handleIndex===1&&p.x===originalBbox.maxX)newP.x=snappedPos.x;if(handleIndex===2&&p.y===originalBbox.maxY)newP.y=snappedPos.y;if(handleIndex===3&&p.x===originalBbox.minX)newP.x=snappedPos.x;return newP})}
                        const newPointsStr=newPoints.map(p=>`${p.x},${p.y}`).join(' ');const newCentroid=getPolygonCentroid([...newPoints]);newElements=newElements.map(el=>{if(el.groupId!==id)return el;if(el.type==='space')return{...el,points:newPointsStr};if(el.type==='text')return{...el,x:(newCentroid.x/dimensions.width)*100,y:(newCentroid.y/dimensions.height)*100};if(el.type==='wall'){const p1=newPoints[el.edgeIndex];const p2=newPoints[(el.edgeIndex+1)%newPoints.length];return{...el,x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y}}return el});
                    }
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                    return;
                }
                if (isDragging) {
                    const startMouseCanvasX = dragInfo.current.startMouseX; 
                    const startMouseCanvasY = dragInfo.current.startMouseY; 
                    const mouseMoveDx = currentMousePos.x - startMouseCanvasX; 
                    const mouseMoveDy = currentMousePos.y - startMouseCanvasY; 
                    let finalDeltaX = mouseMoveDx; 
                    let finalDeltaY = mouseMoveDy; 
                    if (isGridVisible && !isModifierKeyDown) {
                        finalDeltaX = Math.round(mouseMoveDx / gridSize) * gridSize; 
                        finalDeltaY = Math.round(mouseMoveDy / gridSize) * gridSize; 
                    }
                    const elementToDragOriginal = historyOnActionStart.current.svgElements.find(el => el.id === selectedId);
                    if (!elementToDragOriginal) return;
                    
                    // グループ全体をドラッグするのは、'space'自体が選択された時のみに限定
                    const isGroupDrag = elementToDragOriginal.type === 'space';
                    const groupId = elementToDragOriginal.groupId || (isGroupDrag ? elementToDragOriginal.id : null);
                    
                    // グループドラッグでない場合は、選択された要素単体のみを移動対象とする
                    const elementsToUpdate = (isGroupDrag && groupId)
                        ? historyOnActionStart.current.svgElements.filter(el => el.groupId === groupId)
                        : [elementToDragOriginal];
                    const newElements = historyOnActionStart.current.svgElements.map(el => { 
                        const originalEl = elementsToUpdate.find(u_el => u_el.id === el.id);
                        if (originalEl) { 
                            const newEl = { ...el }; 
                            switch (originalEl.type) { 
                                case 'text': 
                                case 'fixture': 
                                case 'compass': 
                                    newEl.x = (originalEl.x / 100 * dimensions.width + finalDeltaX) / dimensions.width * 100; 
                                    newEl.y = (originalEl.y / 100 * dimensions.height + finalDeltaY) / dimensions.height * 100; 
                                    break; 
                                case 'door': 
                                case 'window': 
                                case 'wall': 
                                    newEl.x1 = originalEl.x1 + finalDeltaX; 
                                    newEl.y1 = originalEl.y1 + finalDeltaY; 
                                    newEl.x2 = originalEl.x2 + finalDeltaX; 
                                    newEl.y2 = originalEl.y2 + finalDeltaY; 
                                    break; 
                                case 'space': 
                                case 'stairs': 
                                    const originalPoints = originalEl.points.split(' ').map(p_str => ({x: parseFloat(p_str.split(',')[0]), y: parseFloat(p_str.split(',')[1])})); 
                                    const movedPoints = originalPoints.map(p => ({ x: p.x + finalDeltaX, y: p.y + finalDeltaY })); 
                                    newEl.points = movedPoints.map(p => `${p.x},${p.y}`).join(' '); 
                                    break; 
                            } return newEl; 
                        } return el; 
                    });
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                    return;
                }
            }, [
                getCanvasCoords, zoom, isDisplaySettingsOpen, imagePosition, svgElements, editorMode, selectedId, isDragging, resizingHandleInfo, dragInfo.current, historyState.present, isGridVisible, getGridSnappedPoint, drawingMode, spaceShape, linePoints, isSnapToWall, isModifierKeyDown,
                stairWidth,
                stairSnapPreview, strokeColor, dimensions, drawingStartPoint
            ]);

            const handleMouseUp = (e) => {
                // サイドバー内でのクリックだった場合は、フォーカス解除処理を行わずに終了する
                if (sidebarRef.current && sidebarRef.current.contains(e.target)) {
                    // ドラッグ状態などはリセットしておく
                    setIsDragging(false);
                    setResizingHandleInfo(null);
                    dragTarget.current = null;
                    dragInfo.current = null;
                    historyOnActionStart.current = null;
                    mouseDownInfo.current = null;
                    return; // ここで処理を中断
                }
                if (contextMenuRef.current && contextMenuRef.current.contains(e.target)) {
                    return;
                }
                const wasDraggingImage = !!imageDragInfo.current;
                if (imageDragInfo.current) {
                    imageDragInfo.current = null;
                }
            
                if (!isDragging && !resizingHandleInfo && !wasDraggingImage) {
                    // 2クリック描画の完了時 (1クリック目が押されている状態)
                    if (drawingStartPoint) {
                        const endPoint = getCanvasCoords(e);
                        const finalEndPoint = snappedInfo ? snappedInfo.point : (isGridVisible && !isModifierKeyDown ? getGridSnappedPoint(endPoint) : endPoint);
                        
                        if (drawingMode === 'door' || drawingMode === 'window') {
                            let startForCreate = { ...drawingStartPoint };
                            let endForCreate = { ...finalEndPoint };

                            // 常に描画サイズを少し内側に縮めることで、壁へのはみ出しを防ぎます。
                            const inset = 2.0; // 内側へのオフセット量(px)。この値を調整してください。
                            const dx = endForCreate.x - startForCreate.x;
                            const dy = endForCreate.y - startForCreate.y;
                            const length = Math.sqrt(dx * dx + dy * dy);

                            // 長さがオフセット量x2より大きい場合のみ縮小処理を行う
                            if (length > inset * 2) {
                                const unitX = dx / length;
                                const unitY = dy / length;

                                startForCreate.x += unitX * inset;
                                startForCreate.y += unitY * inset;
                                endForCreate.x -= unitX * inset;
                                endForCreate.y -= unitY * inset;
                            }

                            setPendingWindow({ start: startForCreate, end: endForCreate });
                        } else if (drawingMode === 'space' && spaceShape === 'rect') {
                            const x1 = Math.min(drawingStartPoint.x, finalEndPoint.x);
                            const y1 = Math.min(drawingStartPoint.y, finalEndPoint.y);
                            const x2 = Math.max(drawingStartPoint.x, finalEndPoint.x);
                            const y2 = Math.max(drawingStartPoint.y, finalEndPoint.y);
                            const rectPoints = [{x: x1, y: y1}, {x: x2, y: y1}, {x: x2, y: y2}, {x: x1, y: y2}];
                            createPolygonSpace(rectPoints);
                        } else {
                            createItem(drawingStartPoint, finalEndPoint);
                        }
                        setDrawingStartPoint(null);
                        setSnappedInfo(null);
                    } else {
                        handleCanvasClick(e);
                    }
                } else {
                    // ドラッグ終了時の処理
                    const draggedElement = historyOnActionStart.current?.svgElements.find(el => el.id === selectedId);
                    if (draggedElement && draggedElement.type === 'wall' && draggedElement.groupId && isDragging) {
                        setHistoryState(prevState => {
                            const updatedElements = prevState.present.svgElements.map(el => {
                                if (el.id === selectedId) {
                                    const { groupId, edgeIndex, ...independentWall } = el;
                                    return independentWall;
                                }
                                return el;
                            });
                            return {
                                past: [...prevState.past, historyOnActionStart.current],
                                present: { ...prevState.present, svgElements: updatedElements },
                                future: []
                            };
                        });
                    } else if (historyOnActionStart.current && JSON.stringify(historyOnActionStart.current.svgElements) !== JSON.stringify(svgElements)) {
                        setHistoryState(prev => ({ ...prev, past: [...prev.past, historyOnActionStart.current], future: [] }));
                    }
                }
            
                // 各種状態をリセット
                setIsDragging(false);
                setResizingHandleInfo(null);
                dragTarget.current = null;
                dragInfo.current = null;
                historyOnActionStart.current = null;
                mouseDownInfo.current = null;
            };

            const deleteSelectedElement = useCallback((idToDelete) => {
                const id = idToDelete || selectedId; // 引数でIDが渡されればそれを、なければstateのIDを使用
                if (!id) return;
                const elementToDelete = svgElements.find(el => el.id === id);
                if (!elementToDelete) return;

                setHistoryState(prevState => {
                    const presentElements = prevState.present.svgElements;
                    let newSvgElements;

                    const groupId = elementToDelete.groupId || 
                          (elementToDelete.type === 'space' ? elementToDelete.id : null) ||
                          (elementToDelete.type === 'stairs' ? elementToDelete.id : null);
                          
                    if (elementToDelete.type === 'wall' && groupId) {
                        // 削除された壁線はグループから独立させる
                        newSvgElements = presentElements.filter(el => el.id !== selectedId);
                        // グループのスペースとテキストはそのまま残す
                    } else if (groupId) {
                        // 空間の塗りつぶし、ラベル、またはグループに属する他の要素が選択された場合は、グループ全体を削除する
                        newSvgElements = presentElements.filter(el => el.groupId !== groupId);
                    } else {
                        // 独立した要素が削除された場合
                        newSvgElements = presentElements.filter(el => el.id !== selectedId);
                    }

                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: newSvgElements },
                        future: []
                    };
                });

                setSelectedId(null);
            }, [selectedId, svgElements]);

            const handleUngroupWall = useCallback(() => {
                if (!selectedId) return;
                const wallToUngroup = svgElements.find(el => el.id === selectedId);
                // グループに属していない壁の場合は何もしない
                if (!wallToUngroup || !wallToUngroup.groupId) return;
            
                setHistoryState(prevState => {
                    const newSvgElements = prevState.present.svgElements.map(el => {
                        if (el.id === selectedId) {
                            // groupIdとedgeIndexを削除して、独立した壁オブジェクトを返す
                            const { groupId, edgeIndex, ...independentWall } = el;
                            return independentWall;
                        }
                        return el;
                    });
            
                    // 変更を履歴に保存
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: newSvgElements },
                        future: []
                    };
                });
            
            }, [selectedId, svgElements]);

            const handleStairDirectionChange = (newDirection) => {
                if (!selectedElement) return;
                const groupId = selectedElement.groupId || selectedElement.id;

                setHistoryState(prevState => {
                    const past = [...prevState.past, prevState.present];
                    let future = [];
                    let newElements = [...prevState.present.svgElements];
                    
                    const existingText = newElements.find(el => el.groupId === groupId && el.type === 'text');
                    const stair = newElements.find(el => el.id === groupId);

                    const textContent = newDirection === 'up' ? 'UP' : newDirection === 'down' ? 'DN' : '';

                    if (existingText) {
                        if (newDirection === 'none') {
                            // テキストを削除
                            newElements = newElements.filter(el => el.id !== existingText.id);
                        } else {
                            // テキストを更新
                            newElements = newElements.map(el => el.id === existingText.id ? { ...el, text: textContent } : el);
                        }
                    } else if (newDirection !== 'none' && stair) {
                        // テキストが存在せず、'none'以外が選択された場合は新規作成
                        const points = stair.points.split(' ').map(p => ({ x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1]) }));
                        const startPoint = points[0];
                        const nextPoint = points[1];
                        const arrowVec = { x: nextPoint.x - startPoint.x, y: nextPoint.y - startPoint.y };
                        const arrowLen = Math.sqrt(arrowVec.x**2 + arrowVec.y**2);
                        const arrowDir = arrowLen > 0 ? { x: arrowVec.x / arrowLen, y: arrowVec.y / arrowLen } : { x: 0, y: 0 };
                        const arrowAngle = Math.atan2(arrowDir.y, arrowDir.x) * 180 / Math.PI;
                        const textOffsetX = -arrowDir.x * 20;
                        const textOffsetY = -arrowDir.y * 20;

                        const newTextElement = {
                            id: `text-${Date.now()}`,
                            type: 'text',
                            groupId: groupId,
                            x: ((startPoint.x + textOffsetX) / dimensions.width) * 100,
                            y: ((startPoint.y + textOffsetY) / dimensions.height) * 100,
                            text: textContent,
                            color: stair.color,
                            fontSize: 12,
                            fontFamily: 'sans-serif',
                            textAlign: 'center',
                            rotation: arrowAngle + 90
                        };
                        newElements.push(newTextElement);
                    }

                    return { past, present: { ...prevState.present, svgElements: newElements }, future };
                });
            };


            const handleUndo = useCallback(() => {
                // 1. 線や階段の描画途中の場合、最後の点を削除
                if (linePoints.length > 0) {
                    setLinePoints(prev => prev.slice(0, -1));
                    return;
                }
            
                // 2. 2クリック描画の途中（1クリック目または2クリック目）の場合、その状態をリセット
                if (drawingStartPoint || pendingFixture || pendingWindow) {
                    setDrawingStartPoint(null);
                    setPendingFixture(null);
                    setPendingWindow(null);
                    activeSnapWallRef.current = null;
                    return;
                }
            
                // 3. 上記以外の場合、通常の履歴（完成した図形）を戻す操作
                setHistoryState(prevState => {
                    const past = [...prevState.past];
                    const newPresent = past.pop();
                    if (!newPresent) return prevState;
                    return { past: past, present: newPresent, future: [prevState.present, ...prevState.future] };
                });
            }, [linePoints, drawingStartPoint, pendingFixture, pendingWindow]);

            const handleRedo = useCallback(() => {
                setHistoryState(prevState => {
                    const future = [...prevState.future];
                    const newPresent = future.shift();
                    if (!newPresent) return prevState;
                    return { past: [...prevState.past, prevState.present], present: newPresent, future: future };
                });
            }, []);

            const rotateSelectedElement90Degrees = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window' || selectedElement.type === 'compass' || selectedElement.type === 'fixture')) {
                    let newRotation = (selectedElement.rotation || 0) + 90;
                    if (newRotation > 180) {
                        newRotation -= 360;
                    }
                    handleSelectedElementUpdate({ rotation: newRotation });
                }
            }, [selectedElement, handleSelectedElementUpdate]);

            const toggleSelectedElementSwingDirection = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window')) {
                    const newIsInner = !selectedElement.isInner;
                    handleSelectedElementUpdate({ isInner: newIsInner });
                }
            }, [selectedElement, handleSelectedElementUpdate]);

            const handleSaveImage = async () => {
                const storedId = selectedId;
                setSelectedId(null);

                await new Promise(resolve => setTimeout(resolve, 0));

                const svgNode = svgRef.current;
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = dimensions.width;
                exportCanvas.height = dimensions.height;
                const ctx = exportCanvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                const svgClone = svgNode.cloneNode(true);
                svgClone.style.opacity = 1;

                const images = svgClone.querySelectorAll('image');
                const promises = Array.from(images).map(imageNode => {
                    const href = imageNode.getAttribute('href');
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    return fetch(proxyUrl + encodeURIComponent(href))
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Network response was not ok for ${href}`);
                            }
                            return response.blob();
                        })
                        .then(blob => new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                imageNode.setAttribute('href', reader.result);
                                resolve();
                            };
                            reader.onerror = () => {
                                reject(new Error('FileReader error'));
                            };
                            reader.readAsDataURL(blob);
                        }))
                        .catch(error => {
                            console.error(`Failed to fetch and embed image from ${href}:`, error);
                        });
                });

                try {
                    await Promise.all(promises);
                } catch (error) {
                    console.error("PNG保存エラー: 画像の埋め込みに失敗しました。", error);
                }

                const svgString = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                const img = new Image();

                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);
                    const link = document.createElement('a');
                    const today = new Date();
                    const yyyy = today.getFullYear();
                    const mm = String(today.getMonth() + 1).padStart(2, '0');
                    const dd = String(today.getDate()).padStart(2, '0');
                    link.download = `floorplan_${yyyy}${mm}${dd}.png`;
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                    setSelectedId(storedId);
                };
                img.onerror = () => {
                    console.error("Failed to load SVG blob into image for export.");
                    setSelectedId(storedId);
                }
                img.src = url;
            };

            const handleExportJson = useCallback(() => {
                if (!historyState.present || !historyState.present.svgElements) {
                    alert("エクスポートするデータがありません。");
                    return;
                }
    
                // AIへのお手本として使いやすいように、svgElements部分だけを抽出
                const exportData = {
                    "Blocks": [
                        // ここでデータを変換することも可能ですが、まずは生のデータをコピーします
                    ],
                    // svgElementsのデータをここに含める形が良いでしょう
                    "svgElements": historyState.present.svgElements 
                };
                
                // JSONデータを整形して文字列に変換
                const jsonString = JSON.stringify(historyState.present, null, 2); // historyState.present全体をコピー
    
                // クリップボードにコピー
                navigator.clipboard.writeText(jsonString).then(() => {
                    alert("間取り図のJSONデータをクリップボードにコピーしました。");
                }).catch(err => {
                    console.error("コピーに失敗しました:", err);
                    alert("クリップボードへのコピーに失敗しました。コンソールを確認してください。");
                });
            }, [historyState.present]);



            useEffect(() => {
                // 設備のカテゴリが変更されたら、選択中の設備IDをそのカテゴリの先頭のIDに更新する
                const templates = FIXTURE_TEMPLATES[fixtureCategory];
                if (templates && templates.length > 0) {
                    setFixtureTemplateId(templates[0].id);
                }
            }, [fixtureCategory]); // fixtureCategory が変更された時だけこの処理を実行

            useEffect(() => {
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [handleMouseMove, handleMouseUp]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }, [zoom, isGridVisible]);


            useEffect(() => {
                if (editorAreaRef.current) {
                    const area = editorAreaRef.current;
                    const timer = setTimeout(() => {
                        area.scrollTop = (area.scrollHeight - area.clientHeight) / 2;
                        const scrollLeftCenter = (area.scrollWidth - area.clientWidth) / 2;
                        const sidebarWidth = 320;
                        const newScrollLeft = isSidebarOpen ? scrollLeftCenter - (sidebarWidth / 2) : scrollLeftCenter;
                        area.scrollLeft = newScrollLeft;
                    }, 0);
                    return () => clearTimeout(timer);
                }
            }, [imageUrl, isSidebarOpen]);

            useEffect(() => {
                setFillColor(DEFAULT_FILL_COLORS[spaceType] || '#ffffff');
            }, [spaceType]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // テキスト入力中はショートカットを無効にする
                    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                        return;
                    }
            
                    // ▼▼▼ プレビュー開始のロジックを追加 ▼▼▼
                    if (e.key.toLowerCase() === 'a') {
                        setPreviewMode('drawing');
                    } else if (e.key.toLowerCase() === 's') {
                        setPreviewMode('image');
                    } 
                    // ▲▲▲ ここまで追加 ▲▲▲
                    
                    else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); handleUndo(); }
                    else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); handleRedo(); }
                    else if (e.key === 'Delete') { 
                        if (selectedId) {
                            e.preventDefault(); 
                            deleteSelectedElement();
                        }
                    }
                    else if (e.key === 'Escape') {
                        setDrawingStartPoint(null);
                        setLinePoints([]);
                        setSelectedId(null);
                        setResizingHandleInfo(null);
                        setPendingWindow(null);
                        setPendingFixture(null);
                        activeSnapWallRef.current = null;
                    }
                };
            
                // ▼▼▼ プレビュー終了のロジックを追加 ▼▼▼
                const handleKeyUp = (e) => {
                    if (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 's') {
                        setPreviewMode(null);
                    }
                };
                // ▲▲▲ ここまで追加 ▲▲▲
            
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp); // 👈 keyupイベントリスナーを追加
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp); // 👈 keyupイベントリスナーを削除
                };
            }, [handleUndo, handleRedo, deleteSelectedElement, selectedId]);

            useEffect(() => {
                // 右クリックメニューが非表示になった時に選択を解除する
                if (!contextMenu.visible) {
                    setSelectedId(null);
                }
            }, [contextMenu.visible]);

            useEffect(() => {
                const editorArea = editorAreaRef.current;
                const editorContainer = editorContainerRef.current;
                if (!editorArea) return;

                    const handleWheel = (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();

                        const oldZoom = zoom;
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        const newZoom = Math.max(0.2, Math.min(3, oldZoom + delta));

                        const rect = editorArea.getBoundingClientRect();

                        // マウスカーソルのビューポート内での相対座標
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;

                        // ズーム前のマウスカーソルが指している、キャンバス全体のコンテンツ座標
                        // editorContainerがtranslate(-50%, -50%)されていることを考慮する必要がある
                        // scroll-wrapperの原点からの座標で考える
                        const contentMouseX = editorArea.scrollLeft + mouseX;
                        const contentMouseY = editorArea.scrollTop + mouseY;

                        // ズーム前のeditorContainerの左上基準の座標 (px)
                        // editorContainerはscroll-wrapperの中央に配置されているため、そのオフセットを計算
                        const currentContainerLeft = (editorArea.scrollWidth - dimensions.width * oldZoom) / 2;
                        const currentContainerTop = (editorArea.scrollHeight - dimensions.height * oldZoom) / 2;

                        // マウスが指している「editor-container」内の相対座標
                        const mouseInContainerX = (contentMouseX - currentContainerLeft) / oldZoom;
                        const mouseInContainerY = (contentMouseY - currentContainerTop) / oldZoom;


                        // ズーム率を更新
                        setZoom(newZoom);

                        // 新しいズーム率でのeditorContainerのサイズ
                        const newContainerWidth = dimensions.width * newZoom;
                        const newContainerHeight = dimensions.height * newZoom;

                        // 新しいズーム率でのeditorContainerの左上基準の座標
                        const newContainerLeft = (editorArea.scrollWidth - newContainerWidth) / 2;
                        const newContainerTop = (editorArea.scrollHeight - newContainerHeight) / 2;

                        // マウスが指しているeditor-container内の相対座標を新しいズーム率で計算し、
                        // 新しいeditorContainerの左上からのオフセットを加算
                        const newScrollLeft = (mouseInContainerX * newZoom) + newContainerLeft - mouseX;
                        const newScrollTop = (mouseInContainerY * newZoom) + newContainerTop - mouseY;

                        // スクロール位置を調整
                        editorArea.scrollLeft = newScrollLeft;
                        editorArea.scrollTop = newScrollTop;
                    }
                };

                editorArea.addEventListener('wheel', handleWheel, { passive: false });
                return () => editorArea.removeEventListener('wheel', handleWheel);
            }, [zoom, dimensions.width, dimensions.height]); // dimensionsも依存配列に追加

            useEffect(() => {
                setDrawingStartPoint(null);
                setLinePoints([]);
                setPendingWindow(null);
                setPendingFixture(null);
                setGuideLines([]);
                activeSnapWallRef.current = null;
                isGridSnapStart.current = false;
            }, [editorMode, drawingMode, spaceShape]);

            useEffect(() => {
                if (!isDisplaySettingsOpen) return;
                function handleClickOutside(event) {
                    // ▼▼▼ 条件にモーダルのチェックを追加 ▼▼▼
                    if (displaySettingsRef.current && !displaySettingsRef.current.contains(event.target) &&
                        editorAreaRef.current && !editorAreaRef.current.contains(event.target) &&
                        (!modalRef.current || !modalRef.current.contains(event.target)) // ← この行を追加
                    ) {
                        setDisplaySettingsOpen(false);
                    }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [isDisplaySettingsOpen]);

            useEffect(() => {
                if (editorMode === 'create' || editorMode === 'continuous-create') {
                    setSelectedId(null);
                }
            }, [editorMode]);

            useEffect(() => {
                const selectedEl = svgElements.find(el => el.id === selectedId);
             
                // 選択が解除された場合、前回IDの記録をリセット
                if (!selectedEl) {
                    prevSelectedIdRef.current = null;
                    return;
                }
    
                // テキスト要素が選択された場合
                if (selectedEl.type === 'text' && textEditAreaRef.current) {
                    // 前回選択されていたIDと現在のIDが異なる場合（＝新しく選択された場合）のみ全選択を実行
                    if (selectedId !== prevSelectedIdRef.current) {
                        textEditAreaRef.current.focus();
                        textEditAreaRef.current.select();
                    }
                }
    
                // 設備が選択された場合の処理（変更なし）
                if (selectedEl.type === 'fixture') {
                    const categoryKey = Object.keys(FIXTURE_TEMPLATES).find(cat =>
                        FIXTURE_TEMPLATES[cat].some(t => t.id === selectedEl.templateId)
                    );
                    if (categoryKey) {
                        setFixtureCategory(categoryKey);
                    }
                }

                // 今回のIDを「前回のID」として記録する
                prevSelectedIdRef.current = selectedId;
                
            }, [selectedId, svgElements]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Alt' || e.key === 'Shift') {
                        setIsModifierKeyDown(true);
                    }
                };
                const handleKeyUp = (e) => {
                    if (e.key === 'Alt' || e.key === 'Shift') {
                        setIsModifierKeyDown(false);
                    }
                };
                // ウィンドウからフォーカスが外れた場合もキー状態をリセット
                const handleBlur = () => {
                    setIsModifierKeyDown(false);
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                window.addEventListener('blur', handleBlur);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                    window.removeEventListener('blur', handleBlur);
                };
            }, []); // このuseEffectは初回レンダリング時のみ実行

            // ▼▼▼ 自動保存用のuseEffect ▼▼▼
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const madorizuId = params.get('id');
        
                if (!madorizuId) {
                    alert('編集する間取り図が指定されていません。トップページに戻ります。');
                    window.location.href = 'index.html';
                    return;
                }
        
                const fetchMadorizuData = async () => {
                    setSaveStatus('読み込み中...');
                    const API_ENDPOINT = `https://y5cg2tb2yc.execute-api.ap-northeast-1.amazonaws.com/v1/madorizu/${madorizuId}`;
        
                    try {
                        const response = await fetch(API_ENDPOINT);
                        if (!response.ok) throw new Error('データの読み込みに失敗しました。');
        
                        const data = await response.json();
        
                        if (data && data.drawingData && data.drawingData.svgElements) {
                            setMadorizuName(data.name || '無題の間取り図');
                            setHistoryState(prevState => ({
                                ...prevState,
                                present: {
                                    ocrData: data.drawingData.ocrData || null,
                                    svgElements: data.drawingData.svgElements || []
                                }
                            }));
                        } else {
                            setMadorizuName(data.name || '無題の間取り図');
                            setHistoryState({ past: [], present: { ocrData: null, svgElements: [] }, future: [] });
                        }
                         setSaveStatus('保存済み');
                    } catch (error) {
                        console.error("読み込みエラー:", error);
                        setSaveStatus('読み込みエラー');
                        alert(error.message);
                    }
                };
        
                fetchMadorizuData();
            }, []); // このuseEffectは初回のみ実行
            
            // ▼▼▼ 名前変更時の自動保存用useEffect ▼▼▼
        useEffect(() => {
            // 初回読み込み時は、名前がセットされても保存しない
            if (isInitialNameLoad.current) {
                isInitialNameLoad.current = false;
                return;
            }

            // 名前が変更されたら「未保存」にする
            setSaveStatus('未保存');

            // 2秒後に保存処理を実行するタイマーを設定
            const timerId = setTimeout(() => {
                const saveData = async () => {
                    setSaveStatus('保存中...');
                    const params = new URLSearchParams(window.location.search);
                    const madorizuId = params.get('id');
                    if (!madorizuId) {
                        setSaveStatus('エラー');
                        return;
                    }
                    const API_ENDPOINT = `https://y5cg2tb2yc.execute-api.ap-northeast-1.amazonaws.com/v1/madorizu/${madorizuId}`;

                    try {
                        const response = await fetch(API_ENDPOINT, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                name: madorizuName, // 更新された名前を使用
                                drawingData: historyState.present // 描画データは現在の状態をそのまま使用
                            }),
                        });
                        if (!response.ok) throw new Error('サーバーへの保存に失敗しました。');
                        setSaveStatus('保存済み');
                    } catch (error) {
                        console.error("名前の自動保存エラー:", error);
                        setSaveStatus('エラー');
                    }
                };
                saveData();
            }, 2000); // ユーザーの入力が終わるのを2秒待つ

            // ユーザーがさらに入力を続けた場合、前回のタイマーはキャンセルする
            return () => clearTimeout(timerId);

        }, [madorizuName]); // madorizuNameが変更された時だけこの処理を実行

            const getCursorClass = () => {
                if (isDragging || resizingHandleInfo) return 'cursor-grabbing';
                if (editorMode === 'create' || editorMode === 'continuous-create') return 'cursor-crosshair';
                return 'cursor-default';
            };
            
            const getVerticesAndEdges = (element) => {
                if (!element) return { vertices: [], edges: [] };

                // ▼▼▼【修正】'door'と'window'の場合も壁と同様に頂点を返すようにする ▼▼▼
                if (element.type === 'wall' || element.type === 'door' || element.type === 'window') {
                    return { vertices: [{x: element.x1, y: element.y1}, {x: element.x2, y: element.y2}], edges: [] };
                }
                
                if (element.type === 'space') {
                    const points = element.points.split(' ').map(p => ({x: parseFloat(p.split(',')[0]), y: parseFloat(p.split(',')[1])}));
                    const xs = points.map(p => p.x);
                    const ys = points.map(p => p.y);
                    const bbox = { minX: Math.min(...xs), minY: Math.min(...ys), maxX: Math.max(...xs), maxY: Math.max(...ys) };
                    const corners = [
                        {x: bbox.minX, y: bbox.minY}, {x: bbox.maxX, y: bbox.minY},
                        {x: bbox.maxX, y: bbox.maxY}, {x: bbox.minX, y: bbox.maxY}
                    ];
                    const edges = [
                        {x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY}, {x: bbox.maxX, y: (bbox.minY + bbox.maxY) / 2},
                        {x: (bbox.minX + bbox.maxX) / 2, y: bbox.maxY}, {x: bbox.minX, y: (bbox.minY + bbox.maxY) / 2}
                    ];
                    return { vertices: [], corners, edges };
                }
                if (element.type === 'fixture') {
                    const w = element.width;
                    const h = element.height;
                    const corners = [
                        { x: -w / 2, y: -h / 2 }, { x: w / 2, y: -h / 2 },
                        { x: w / 2, y: h / 2 }, { x: -w / 2, y: h / 2 }
                    ];
                    const edges = [
                        { x: 0, y: -h / 2 }, { x: w / 2, y: 0 },
                        { x: 0, y: h / 2 }, { x: -w / 2, y: 0 }
                    ];
                    return { vertices: [], corners, edges };
                }

                return { vertices: [], corners: [], edges: [] };
            }
            
            const getResizeCursor = (index, totalPoints) => {
                if (totalPoints === 4) { // Assume rect-like polygon
                    return ['nwse-resize', 'nesw-resize', 'nwse-resize', 'nesw-resize'][index];
                }
                return 'move';
            }
            
            const getLayerLevel = (type) => {
                switch(type) {
                    case 'space':
                    case 'wall':
                    case 'stairs':
                        return 0; // 空間と壁が同じレイヤー
                    case 'door':
                    case 'window':
                    case 'fixture':
                    case 'compass':
                        return 1;
                    case 'text':
                        return 2;
                    default:
                        return 99;
                }
            };
    
            const originalIndexMap = new Map(svgElements.map((el, index) => [el.id, index]));
    
            const sortedElements = [...svgElements].sort((a, b) => {
                const levelA = getLayerLevel(a.type);
                const levelB = getLayerLevel(b.type);
    
                if (levelA !== levelB) {
                    // 1. まずはレイヤーレベルで並び替え
                    return levelA - levelB;
                } else {
                    // 2. 同じレイヤーレベル内では、元の配列の順序を維持する
                    //    (「最前面へ移動」などで変更された順序がここで反映される)
                    return originalIndexMap.get(a.id) - originalIndexMap.get(b.id);
                }
            });

            const TextRenderer = ({ element, isDirectlySelected, isDragging }) => {
                const textRef = useRef(null);
                const [bbox, setBbox] = useState(null);
                
                // ... (useLayoutEffectや、textAnchor, x_px, y_px などの定義は元のまま)
                useLayoutEffect(() => {
                    if (textRef.current) {
                        const textBbox = textRef.current.getBBox();
                        setBbox(textBbox);
                    }
                }, [element.text, element.fontSize, element.fontFamily, element.textAlign, element.x, element.y, element.rotation, element.writingMode, element.letterSpacing]); // 依存配列に letterSpacing を追加
            
                let textAnchor = 'start';
                if (element.textAlign === 'center') textAnchor = 'middle';
                else if (element.textAlign === 'right') textAnchor = 'end';
                
                const x_px = element.x / 100 * dimensions.width;
                const y_px = element.y / 100 * dimensions.height;
            
                const textStyle = {
                    cursor: isDirectlySelected && isDragging ? 'grabbing' : 'grab',
                    pointerEvents: 'all',
                    writingMode: element.writingMode === 'vertical' ? 'vertical-rl' : 'horizontal-tb',
                    textOrientation: element.writingMode === 'vertical' ? 'mixed' : 'sideways',
                };
            
                return (
                    <g data-id={element.id} transform={`rotate(${element.rotation || 0} ${x_px} ${y_px})`} onContextMenu={handleContextMenu}>
                        {bbox && element.backgroundColor && element.backgroundColor !== 'none' && (
                            <rect
                                x={bbox.x - 4} y={bbox.y - 4}
                                width={bbox.width + 8} height={bbox.height + 8}
                                fill={element.backgroundColor}
                                rx="2"
                                style={{ pointerEvents: 'none' }}
                            />
                        )}
                        <text
                            ref={textRef}
                            x={`${element.x}%`}
                            y={`${element.y}%`}
                            fill={element.color}
                            fontSize={element.fontSize}
                            fontFamily={element.fontFamily}
                            style={textStyle}
                            textAnchor={textAnchor}
                            dominantBaseline="central"
                            // ▼▼▼ この行を追加 ▼▼▼
                            letterSpacing={element.letterSpacing} 
                        >
                            {element.text.split('\n').map((line, i) => {
                                const isVertical = element.writingMode === 'vertical';
                                return (
                                    <tspan
                                        key={i}
                                        x={!isVertical || i === 0 ? `${element.x}%` : undefined}
                                        y={isVertical && i > 0 ? `${element.y}%` : undefined}
                                        dx={isVertical && i > 0 ? `-${i * 1.2}em` : undefined}
                                        dy={!isVertical && i > 0 ? '1.2em' : undefined}
                                    >
                                        {line}
                                    </tspan>
                                );
                            })}
                        </text>
                        {isDirectlySelected && bbox && (
                            <>
                                <rect
                                    x={bbox.x - 4} y={bbox.y - 4}
                                    width={bbox.width + 8} height={bbox.height + 8}
                                    fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth={2 / zoom}
                                    rx="2" style={{ pointerEvents: 'none' }}
                                />
                                <line 
                                    x1={x_px} y1={y_px - bbox.height / 2 - 10}
                                    x2={x_px} y2={y_px - bbox.height / 2 - 20}
                                    stroke={SELECTED_ELEMENT_COLOR} strokeWidth={2 / zoom}
                                    style={{ pointerEvents: 'none' }}
                                />
                                <circle 
                                    data-id={element.id}
                                    data-handle-type="textRotation"
                                    cx={x_px} cy={y_px - bbox.height / 2 - 25} r={5 / zoom}
                                    fill="white" stroke={SELECTED_ELEMENT_COLOR} strokeWidth={2 / zoom}
                                    style={{ cursor: 'alias' }}
                                />
                            </>
                        )}
                    </g>
                );
            };

            // 背景パターンを描画するためのコンポーネント
            const BackgroundRenderer = ({ element }) => {
                if (!element.backgroundPattern || element.backgroundPattern === 'none' || element.type !== 'space') {
                    return null;
                }

                const points = element.points.split(' ').map(p_str => {
                    const [x, y] = p_str.split(',').map(parseFloat);
                    return { x, y };
                });

                if (points.length < 3) return null;

                const clipPathId = `clip-${element.id}`;

                const xs = points.map(p => p.x);
                const ys = points.map(p => p.y);
                const bbox = {
                    minX: Math.min(...xs),
                    minY: Math.min(...ys),
                    maxX: Math.max(...xs),
                    maxY: Math.max(...ys),
                };
                bbox.width = bbox.maxX - bbox.minX;
                bbox.height = bbox.maxY - bbox.minY;

                const renderPattern = () => {
                    const pattern = element.backgroundPattern;
                    const paths = [];
                    const strokeColor = '#cccccc';
                    const strokeWidth = 1;

                    switch (pattern) {
                        case 'vertical-lines': {
                            const step = 10;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'horizontal-lines': {
                            const step = 10;
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'grid-small': {
                            const step = 10;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'grid-large': {
                            const step = 30;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={'#000000'} strokeWidth={strokeWidth} />);
                            }
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={'#000000'} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'solid-x':
                        case 'dotted-x': {
                            const dashArray = pattern === 'dotted-x' ? '2 2' : 'none';
                            paths.push(<line key="x1" x1={bbox.minX} y1={bbox.minY} x2={bbox.maxX} y2={bbox.maxY} stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            paths.push(<line key="x2" x1={bbox.minX} y1={bbox.maxY} x2={bbox.maxX} y2={bbox.minY} stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            return paths;
                        }
                        case 'solid-triangle':
                        case 'dotted-triangle': {
                            const leftPoints = points.filter(p => p.x === bbox.minX).sort((a,b) => a.y - b.y);
                            const rightPoints = points.filter(p => p.x === bbox.maxX).sort((a,b) => a.y - b.y);

                            if (leftPoints.length >= 2 && rightPoints.length >= 1) {
                                const p1 = leftPoints[0];
                                const p2 = leftPoints[leftPoints.length - 1];
                                const pm = { x: bbox.maxX, y: (bbox.maxY + bbox.minY) / 2 };
                                const dashArray = pattern === 'dotted-triangle' ? '2 2' : 'none';
                                paths.push(<path key="tri" d={`M${p1.x},${p1.y} L${p2.x},${p2.y} L${pm.x},${pm.y} Z`} fill="none" stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            }
                            return paths;
                        }
                        default:
                            return null;
                    }
                };

                return (
                    <g style={{pointerEvents: 'none'}}>
                        <defs>
                            <clipPath id={clipPathId}>
                                <polygon points={element.points} />
                            </clipPath>
                        </defs>
                        <g clipPath={`url(#${clipPathId})`}>
                            {renderPattern()}
                        </g>
                    </g>
                );
            };

            const StairsPrePlacementPreview = ({ previewInfo, width, color }) => {
                if (!previewInfo) return null;
            
                const { center, angle } = previewInfo;
                const rad = angle * Math.PI / 180;
            
                // 階段のプレビュー用の短い線の長さ
                const previewLength = 50; 
            
                // 中心線から両端までのベクトル
                const perpVec = { x: -Math.sin(rad) * (width / 2), y: Math.cos(rad) * (width / 2) };
                
                // 進行方向のベクトル
                const dirVec = { x: Math.cos(rad) * (previewLength / 2), y: Math.sin(rad) * (previewLength / 2) };
                
                // 両端の線の始点と終点
                const line1_p1 = { x: center.x + perpVec.x - dirVec.x, y: center.y + perpVec.y - dirVec.y };
                const line1_p2 = { x: center.x + perpVec.x + dirVec.x, y: center.y + perpVec.y + dirVec.y };
                const line2_p1 = { x: center.x - perpVec.x - dirVec.x, y: center.y - perpVec.y - dirVec.y };
                const line2_p2 = { x: center.x - perpVec.x + dirVec.x, y: center.y - perpVec.y + dirVec.y };
            
                return (
                    <g style={{ pointerEvents: 'none', opacity: 0.8 }}>
                        <line 
                            x1={line1_p1.x} y1={line1_p1.y} 
                            x2={line1_p2.x} y2={line1_p2.y} 
                            stroke={color} strokeWidth={2} strokeDasharray="6,4" 
                        />
                        <line 
                            x1={line2_p1.x} y1={line2_p1.y} 
                            x2={line2_p2.x} y2={line2_p2.y} 
                            stroke={color} strokeWidth={2} strokeDasharray="6,4" 
                        />
                    </g>
                );
            };

            const StairsRenderer = ({ element, onContextMenu }) => {
                const { points: pointsStr, width, color, strokeWidth } = element;
            
                const points = pointsStr.split(' ').map(p => { const [x, y] = p.split(',').map(parseFloat); return { x, y }; });
                if (points.length < 2) return null;
            
                const outlines = [[], []];
                const halfWidth = width / 2;
            
                for (let i = 0; i < points.length; i++) {
                    const p_curr = points[i];
                    const p_prev = i > 0 ? points[i - 1] : null;
                    const p_next = i < points.length - 1 ? points[i + 1] : null;
                    const getPerp = (p1, p2) => {
                        const vec = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const len = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                        return len > 0 ? { x: -vec.y / len, y: vec.x / len } : { x: 0, y: 0 };
                    };
            
                    if (!p_prev) {
                        const perp = getPerp(p_curr, p_next);
                        outlines[0].push({ x: p_curr.x + perp.x * halfWidth, y: p_curr.y + perp.y * halfWidth });
                        outlines[1].push({ x: p_curr.x - perp.x * halfWidth, y: p_curr.y - perp.y * halfWidth });
                    } else if (!p_next) {
                        const perp = getPerp(p_prev, p_curr);
                        outlines[0].push({ x: p_curr.x + perp.x * halfWidth, y: p_curr.y + perp.y * halfWidth });
                        outlines[1].push({ x: p_curr.x - perp.x * halfWidth, y: p_curr.y - perp.y * halfWidth });
                    } else {
                        const perp_in = getPerp(p_prev, p_curr);
                        const perp_out = getPerp(p_curr, p_next);
                        const vec_in_dir = { x: p_curr.x - p_prev.x, y: p_curr.y - p_prev.y };
                        const vec_out_dir = { x: p_next.x - p_curr.x, y: p_next.y - p_curr.y };
                        const len_in_dir = Math.sqrt(vec_in_dir.x**2 + vec_in_dir.y**2);
                        const len_out_dir = Math.sqrt(vec_out_dir.x**2 + vec_out_dir.y**2);
                        const dir_in = { x: vec_in_dir.x / len_in_dir, y: vec_in_dir.y / len_in_dir };
                        const dir_out = { x: vec_out_dir.x / len_out_dir, y: vec_out_dir.y / len_out_dir };
                        const dotProduct = dir_in.x * dir_out.x + dir_in.y * dir_out.y;
                        if (dotProduct < -0.985) { 
                             [1, -1].forEach(side => {
                                const outline_index = side === 1 ? 0 : 1;
                                const p2 = { x: p_curr.x + side * perp_in.x * halfWidth, y: p_curr.y + side * perp_in.y * halfWidth };
                                outlines[outline_index].push(p2);
                            });
                        } else {
                            [1, -1].forEach(side => {
                                const outline_index = side === 1 ? 0 : 1;
                                const p1 = { x: p_prev.x + side * perp_in.x * halfWidth, y: p_prev.y + side * perp_in.y * halfWidth };
                                const p2 = { x: p_curr.x + side * perp_in.x * halfWidth, y: p_curr.y + side * perp_in.y * halfWidth };
                                const p3 = { x: p_curr.x + side * perp_out.x * halfWidth, y: p_curr.y + side * perp_out.y * halfWidth };
                                const p4 = { x: p_next.x + side * perp_out.x * halfWidth, y: p_next.y + side * perp_out.y * halfWidth };
                                let cornerPoint = getLineIntersection(p1, p2, p3, p4);
                                if (!cornerPoint) { cornerPoint = p2; }
                                outlines[outline_index].push(cornerPoint);
                            });
                        }
                    }
                }
            
                const steps = [];
                const stepInterval = 15;
                let accumulatedLength = 0;
                const cornerMargins = new Array(points.length).fill(0);
                const cornerAngles = new Array(points.length).fill(0); 
            
                for (let i = 1; i < points.length - 1; i++) {
                    const p_prev = points[i-1], p_curr = points[i], p_next = points[i+1];
                    const vec_in = { x: p_curr.x - p_prev.x, y: p_curr.y - p_prev.y };
                    const vec_out = { x: p_next.x - p_curr.x, y: p_next.y - p_curr.y };
                    const len_in = Math.sqrt(vec_in.x**2 + vec_in.y**2);
                    const len_out = Math.sqrt(vec_out.x**2 + vec_out.y**2);
                    const dir_in = len_in > 0 ? {x: vec_in.x/len_in, y: vec_in.y/len_in} : {x:0, y:0};
                    const dir_out = len_out > 0 ? {x: vec_out.x/len_out, y: vec_out.y/len_out} : {x:0, y:0};
                    let dot = dir_in.x * dir_out.x + dir_in.y * dir_out.y;
                    dot = Math.max(-1, Math.min(1, dot));
                    const angle = Math.acos(dot);
                    cornerAngles[i] = angle;
            
                    let margin = 0;
                    if (angle >= Math.PI / 18) {
                        margin = Math.min(width / 1.5, len_in / 2, len_out / 2);
                    }
                    const threshold = margin + stepInterval * 1.5;
                    if (len_in > threshold && len_out > threshold) {
                        margin -= stepInterval;
                    }
                    margin = Math.max(0, margin);
                    cornerMargins[i] = margin;
                }
            
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i], p2 = points[i+1];
                    const segmentVec = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const segmentLen = Math.sqrt(segmentVec.x**2 + segmentVec.y**2);
                    if (segmentLen < 1) continue;
                    const startMargin = cornerMargins[i];
                    const endMargin = cornerMargins[i+1];
                    const segmentDir = { x: segmentVec.x / segmentLen, y: segmentVec.y / segmentLen };
                    const perp = { x: -segmentDir.y, y: segmentDir.x };
                    let nextStepDist = Math.ceil((accumulatedLength + startMargin) / stepInterval) * stepInterval;
                    while(nextStepDist < accumulatedLength + segmentLen - endMargin) {
                        const l = nextStepDist - accumulatedLength;
                        if (l >= startMargin) {
                            const stepCenter = { x: p1.x + segmentDir.x * l, y: p1.y + segmentDir.y * l };
                            const s1 = { x: stepCenter.x + perp.x * halfWidth, y: stepCenter.y + perp.y * halfWidth };
                            const s2 = { x: stepCenter.x - perp.x * halfWidth, y: stepCenter.y - perp.y * halfWidth };
                            steps.push(<line key={`step-s-${i}-${l}`} x1={s1.x} y1={s1.y} x2={s2.x} y2={s2.y} stroke={color} strokeWidth={1} />);
                        }
                        nextStepDist += stepInterval;
                    }
                    accumulatedLength += segmentLen;
                }
                
                for (let i = 1; i < points.length - 1; i++) {
                    const margin = cornerMargins[i];
                    const crossProduct = (points[i].x - points[i-1].x) * (points[i+1].y - points[i].y) - (points[i].y - points[i-1].y) * (points[i+1].x - points[i].x);
                    const innerOutlineIndex = (crossProduct > 0) ? 0 : 1;
                    const outerOutlineIndex = (crossProduct > 0) ? 1 : 0;
                    const innerCornerPoint = outlines[innerOutlineIndex][i];
                    const outerCornerPoint = outlines[outerOutlineIndex][i];
            
                    if (margin === 0) {
                        const angle = cornerAngles[i];
                        if (angle > 0.01) {
                           steps.push(<line key={`step-c-${i}`} x1={innerCornerPoint.x} y1={innerCornerPoint.y} x2={outerCornerPoint.x} y2={outerCornerPoint.y} stroke={color} strokeWidth={1} />);
                        }
                    } else {
                        const prevOuterPoint = outlines[outerOutlineIndex][i - 1];
                        const nextOuterPoint = outlines[outerOutlineIndex][i + 1];
            
                        const vecToPrev = { x: prevOuterPoint.x - outerCornerPoint.x, y: prevOuterPoint.y - outerCornerPoint.y };
                        const lenToPrev = Math.sqrt(vecToPrev.x**2 + vecToPrev.y**2);
                        const dirToPrev = lenToPrev > 0 ? { x: vecToPrev.x / lenToPrev, y: vecToPrev.y / lenToPrev } : {x:0, y:0};
                        const outerP1 = { x: outerCornerPoint.x + dirToPrev.x * margin, y: outerCornerPoint.y + dirToPrev.y * margin };
                        
                        const vecToNext = { x: nextOuterPoint.x - outerCornerPoint.x, y: nextOuterPoint.y - outerCornerPoint.y };
                        const lenToNext = Math.sqrt(vecToNext.x**2 + vecToNext.y**2);
                        const dirToNext = lenToNext > 0 ? { x: vecToNext.x / lenToNext, y: vecToNext.y / lenToNext } : {x:0, y:0};
                        const outerP2 = { x: outerCornerPoint.x + dirToNext.x * margin, y: outerCornerPoint.y + dirToNext.y * margin };
                        
                        // ▼▼▼【修正点】角度に関わらず、常に2本の斜め線を描画するよう修正 ▼▼▼
                        steps.push(<line key={`step-c-${i}-1`} x1={innerCornerPoint.x} y1={innerCornerPoint.y} x2={outerP1.x} y2={outerP1.y} stroke={color} strokeWidth={1} />);
                        steps.push(<line key={`step-c-${i}-2`} x1={innerCornerPoint.x} y1={innerCornerPoint.y} x2={outerP2.x} y2={outerP2.y} stroke={color} strokeWidth={1} />);
                    }
                }
            
                return (
                    <g data-id={element.id} onContextMenu={onContextMenu} style={{ pointerEvents: 'all', cursor: 'grab' }}>
                        <path d={`M ${outlines[0].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={strokeWidth} strokeLinejoin="miter" strokeLinecap="square" />
                        <path d={`M ${outlines[1].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={strokeWidth} strokeLinejoin="miter" strokeLinecap="square" />
                        {steps}
                        <path d={`M ${points.map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={1} markerEnd="url(#arrowhead)" />
                    </g>
                );
            };
            
            const StairsPreviewRenderer = ({ points, width, color }) => {
                if (points.length < 2) return null;
            
                // 上のStairsRendererと全く同じロジックを使用
                const getLineIntersection = (p1, p2, p3, p4) => {
                    const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                    if (Math.abs(d) < 1e-8) { return null; }
                    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
                    return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                };

                const getLineIntersectionWithCheck = (p1, p2, p3, p4) => {
                    const d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
                    if (Math.abs(d) < 1e-8) return null;
                
                    const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / d;
                    const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / d;
                
                    // 線分上での交差をチェック
                    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                        return { x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
                    }
                    return null;
                };
            
                const outlines = [[], []];
                const halfWidth = width / 2;
            
                for (let i = 0; i < points.length; i++) {
                    const p_curr = points[i];
                    const p_prev = i > 0 ? points[i - 1] : null;
                    const p_next = i < points.length - 1 ? points[i + 1] : null;
                    const getPerp = (p1, p2) => {
                        const vec = { x: p2.x - p1.x, y: p2.y - p1.y };
                        const len = Math.sqrt(vec.x ** 2 + vec.y ** 2);
                        return len > 0 ? { x: -vec.y / len, y: vec.x / len } : { x: 0, y: 0 };
                    };
                    if (!p_prev) {
                        const perp = getPerp(p_curr, p_next);
                        outlines[0].push({ x: p_curr.x + perp.x * halfWidth, y: p_curr.y + perp.y * halfWidth });
                        outlines[1].push({ x: p_curr.x - perp.x * halfWidth, y: p_curr.y - perp.y * halfWidth });
                    } else if (!p_next) {
                        const perp = getPerp(p_prev, p_curr);
                        outlines[0].push({ x: p_curr.x + perp.x * halfWidth, y: p_curr.y + perp.y * halfWidth });
                        outlines[1].push({ x: p_curr.x - perp.x * halfWidth, y: p_curr.y - perp.y * halfWidth });
                    } else {
                        const perp_in = getPerp(p_prev, p_curr);
                        const perp_out = getPerp(p_curr, p_next);
                        [1, -1].forEach(side => {
                            const outline_index = side === 1 ? 0 : 1;
                            const p1 = { x: p_prev.x + side * perp_in.x * halfWidth, y: p_prev.y + side * perp_in.y * halfWidth };
                            const p2 = { x: p_curr.x + side * perp_in.x * halfWidth, y: p_curr.y + side * perp_in.y * halfWidth };
                            const p3 = { x: p_curr.x + side * perp_out.x * halfWidth, y: p_curr.y + side * perp_out.y * halfWidth };
                            const p4 = { x: p_next.x + side * perp_out.x * halfWidth, y: p_next.y + side * perp_out.y * halfWidth };
                            let cornerPoint = getLineIntersection(p1, p2, p3, p4);
                            if (!cornerPoint) { cornerPoint = p2; }
                            outlines[outline_index].push(cornerPoint);
                        });
                    }
                }
            
                return (
                    <g style={{pointerEvents: 'none', opacity: 0.7}}>
                        <path d={`M ${outlines[0].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5" />
                        <path d={`M ${outlines[1].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5" />
                        <path d={`M ${points.map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={1} strokeDasharray="5,5"/>
                    </g>
                );
            };

            // --- コンテキストメニュー用のコンポーネント ---
            const ContextMenu = () => {
                if (!contextMenu.visible) return null;
    
                const { x, y, targetId, targetElement } = contextMenu;
                const menuStyle = { top: y, left: x, position: 'fixed', zIndex: 1000 };
    
                const handleAction = (action, option) => {
                    switch (action) {
                        case 'cut': handleCut(); break;
                        case 'copy': handleCopy(); break;
                        case 'paste': handlePaste(); break;
                        case 'delete': deleteSelectedElement(targetId); break;
                        case 'reorder': reorderElements(option); break;
                        case 'toggleGrid': setGridVisible(prev => !prev); break;
                    }
                    setContextMenu({ visible: false });
                };
    
                // 要素がない場所（キャンバス）で右クリックした場合のメニュー
                if (!targetElement) {
                    return (
                        <div 
                            style={menuStyle} 
                            className="bg-white rounded-md shadow-lg border border-gray-200 text-sm" 
                            onContextMenu={(e) => e.preventDefault()}
                            onClick={(e) => e.stopPropagation()}
                        >
                            <button onClick={() => handleAction('paste')} disabled={!clipboard} className="w-full text-left px-4 py-1.5 hover:bg-gray-100 flex justify-between disabled:opacity-50 disabled:hover:bg-white"><span>貼り付け</span><span className="text-gray-400">Ctrl+V</span></button>
                            <div className="my-1 border-t border-gray-200"></div>
                            <button onClick={() => handleAction('toggleGrid')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100 flex justify-between"><span>{isGridVisible ? 'グリッド線を非表示' : 'グリッド線を表示'}</span></button>
                        </div>
                    );
                }
    
                // 要素の上で右クリックした場合のメニュー
                return (
                    <div 
                        ref={contextMenuRef} 
                        style={menuStyle} 
                        className="w-44 bg-white rounded-md shadow-lg border border-gray-200 text-sm py-1" 
                        onContextMenu={(e) => e.preventDefault()}
                        onClick={(e) => e.stopPropagation()}
                    >
                        {/* ▼▼▼ flex justify-between を flex items-center に変更し、ショートカットのspanに ml-auto を追加 ▼▼▼ */}
                        <button onClick={() => handleAction('cut')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100 flex items-center">
                            <span>切り取り</span>
                            <span className="ml-auto text-gray-400">Ctrl+X</span>
                        </button>
                        <button onClick={() => handleAction('copy')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100 flex items-center">
                            <span>コピー</span>
                            <span className="ml-auto text-gray-400">Ctrl+C</span>
                        </button>
                        <button onClick={() => handleAction('paste')} disabled={!clipboard} className="w-full text-left px-4 py-1.5 hover:bg-gray-100 flex items-center disabled:opacity-50 disabled:hover:bg-white">
                            <span>貼り付け</span>
                            <span className="ml-auto text-gray-400">Ctrl+V</span>
                        </button>
                        
                        <div className="my-1 border-t border-gray-200"></div>
                
                        <button onClick={() => handleAction('reorder', 'front')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100">最前面へ移動</button>
                        <button onClick={() => handleAction('reorder', 'forward')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100">前面へ移動</button>
                        <button onClick={() => handleAction('reorder', 'backward')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100">背面へ移動</button>
                        <button onClick={() => handleAction('reorder', 'back')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100">最背面へ移動</button>
                
                        <div className="my-1 border-t border-gray-200"></div>
                        <button onClick={() => handleAction('delete')} className="w-full text-left px-4 py-1.5 hover:bg-gray-100 flex items-center">
                            <span>削除</span>
                            <span className="ml-auto text-gray-400">Delete</span>
                        </button>
                    </div>
                );
            };

            // 右クリックされたのが図形の上ではない（SVGキャンバス自体）の場合のみメニューを表示
            const handleCanvasContextMenu = (e) => {
                if (e.target === svgRef.current) {
                    e.preventDefault();
                    setContextMenu({ 
                        visible: true, 
                        x: e.clientX, 
                        y: e.clientY, 
                        targetId: null,
                        targetElement: null 
                    });
                }
            };
            
            // --- コンテキストメニューのアクション関数 ---
            const handleContextMenu = (e) => {
                e.preventDefault();
                const targetId = e.currentTarget.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);
                if (targetElement) {
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, targetId, targetElement });
                    setSelectedId(targetId); // 右クリックした要素を選択状態にする
                }
            };
    
            const handleCopy = () => {
                const { targetId } = contextMenu;
                if (!targetId) return;
    
                const elementToCopy = svgElements.find(el => el.id === targetId);
                if (!elementToCopy) return;
                
                const groupId = elementToCopy.groupId || (elementToCopy.type === 'space' ? elementToCopy.id : null);
                let elementsToCopy = [];
    
                if (groupId) {
                    elementsToCopy = svgElements.filter(el => el.groupId === groupId);
                } else {
                    elementsToCopy = [elementToCopy];
                }
                
                setClipboard({
                    type: 'copy',
                    elements: JSON.parse(JSON.stringify(elementsToCopy)) // Deep copy
                });
            };
            
            const handleCut = () => {
                handleCopy(); // 先にコピー
                deleteSelectedElement(contextMenu.targetId); // その後削除
            };
    
            const handlePaste = () => {
                if (!clipboard) return;
                
                const offset = 20; // 貼り付け時のオフセット量 (ピクセル)
                
                // クリップボード内のデータをディープコピーして新しい要素を作成
                let elementsToAdd = JSON.parse(JSON.stringify(clipboard.elements));
                let newClipboardElements = [];
    
                const newGroupId = `space-group-${Date.now()}`;
                const isGroup = elementsToAdd.length > 1;
    
                elementsToAdd.forEach(el => {
                    const newId = `${el.type}-${Date.now()}-${Math.random()}`;
                    el.id = newId;
    
                    if (isGroup) {
                        el.groupId = newGroupId;
                    }
    
                    // 各要素タイプの座標にオフセットを加算
                    if (el.type === 'space' || el.type === 'stairs') {
                        const points = el.points.split(' ').map(p_str => ({x: parseFloat(p_str.split(',')[0]), y: parseFloat(p_str.split(',')[1])}));
                        const movedPoints = points.map(p => ({ x: p.x + offset, y: p.y + offset }));
                        el.points = movedPoints.map(p => `${p.x},${p.y}`).join(' ');
                    } else if (el.type === 'wall' || el.type === 'door' || el.type === 'window') {
                        el.x1 += offset; el.y1 += offset;
                        el.x2 += offset; el.y2 += offset;
                    } else { // text, fixture, compass
                        el.x = ((el.x / 100 * dimensions.width) + offset) / dimensions.width * 100;
                        el.y = ((el.y / 100 * dimensions.height) + offset) / dimensions.height * 100;
                    }
                    newClipboardElements.push(JSON.parse(JSON.stringify(el))); // 次のペーストのために、移動後の要素を保存
                });
                
                // 描画データに新しい要素を追加
                setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...elementsToAdd] }, future: [] }));
    
                // クリップボードの内容を、今貼り付けた要素の情報で更新する
                setClipboard({
                    type: 'copy',
                    elements: newClipboardElements
                });
            };
    
            const reorderElements = (direction) => {
                const { targetId } = contextMenu;
                if (!targetId) return;
            
                // 現在の要素配列のコピーを作成
                const currentElements = [...svgElements];
                const elementToMove = currentElements.find(el => el.id === targetId);
                if (!elementToMove) return;
            
                // グループ化されている要素（部屋、階段など）か、単体の要素かを判断
                const groupId = elementToMove.groupId || (['space', 'stairs'].includes(elementToMove.type) ? targetId : null);
            
                // 移動対象となる要素（単体またはグループ全体）を取得
                const itemsToMove = groupId
                    ? currentElements.filter(el => el.groupId === groupId)
                    : [elementToMove];
                
                const itemsToMoveIds = new Set(itemsToMove.map(el => el.id));
                // 移動対象「以外」の要素
                const others = currentElements.filter(el => !itemsToMoveIds.has(el.id));
            
                let newSvgElements;
            
                switch (direction) {
                    case 'front':
                        // 配列の最後に移動対象を追加
                        newSvgElements = [...others, ...itemsToMove];
                        break;
                    case 'back':
                        // 配列の先頭に移動対象を追加
                        newSvgElements = [...itemsToMove, ...others];
                        break;
                    case 'forward': {
                        // 移動対象の最後の要素のインデックスを取得
                        const lastItemOriginalIndex = currentElements.map(el => el.id).lastIndexOf(itemsToMove[itemsToMove.length - 1].id);
                        // 既に最前面の場合は何もしない
                        if (lastItemOriginalIndex >= currentElements.length - 1) return;
                        
                        // 移動対象を一旦削除
                        const tempArray = currentElements.filter(el => !itemsToMoveIds.has(el.id));
                        // 1つ手前の要素のインデックスを見つける
                        const insertAtIndex = tempArray.findIndex(el => el.id === currentElements[lastItemOriginalIndex + 1].id);
                        
                        // 1つ手前の要素の「後」に挿入
                        tempArray.splice(insertAtIndex + 1, 0, ...itemsToMove);
                        newSvgElements = tempArray;
                        break;
                    }
                    case 'backward': {
                        // 移動対象の最初の要素のインデックスを取得
                        const firstItemOriginalIndex = currentElements.findIndex(el => el.id === itemsToMove[0].id);
                        // 既に最背面の場会は何もしない
                        if (firstItemOriginalIndex <= 0) return;
    
                        // 移動対象を一旦削除
                        const tempArray = currentElements.filter(el => !itemsToMoveIds.has(el.id));
                        // 1つ奥の要素のインデックスを見つける
                        const insertAtIndex = tempArray.findIndex(el => el.id === currentElements[firstItemOriginalIndex - 1].id);
    
                        // 1つ奥の要素の「前」に挿入
                        tempArray.splice(insertAtIndex, 0, ...itemsToMove);
                        newSvgElements = tempArray;
                        break;
                    }
                    default:
                        return; // 何もしない
                }
            
                // 履歴を更新
                setHistoryState(prev => ({
                    past: [...prev.past, prev.present],
                    present: { ...prev.present, svgElements: newSvgElements },
                    future: []
                }));
            };

            let displayImageOpacity = 1 - imageOpacity;
            let displayDrawingOpacity = 1 - drawingOpacity;
        
            if (previewMode === 'image') {
                displayImageOpacity = 1;
                displayDrawingOpacity = 0;
            } else if (previewMode === 'drawing') {
                displayImageOpacity = 0;
                displayDrawingOpacity = 1;
            }

            // 描画する前に、二重線の交差処理を行う
            // これにより、交差する二重線が適切に分割された新しい要素リストが生成される
            const elementsToRender = processDoubleLineIntersections(svgElements);
            
            // レイヤー順のソートも、処理後のリストに対して行う
            const finalOriginalIndexMap = new Map(elementsToRender.map((el, index) => [el.id, index]));
            const finalSortedElements = [...elementsToRender].sort((a, b) => {
                const levelA = getLayerLevel(a.type);
                const levelB = getLayerLevel(b.type);
                if (levelA !== levelB) {
                    return levelA - levelB;
                } else {
                    return finalOriginalIndexMap.get(a.id) - finalOriginalIndexMap.get(b.id);
                }
            });

            return (                    
                <div className="flex flex-col h-screen" onClick={() => setContextMenu({ visible: false })}>
                    <ContextMenu />
                    <UploadModal
                        isOpen={isUploadModalOpen}
                        onClose={() => setUploadModalOpen(false)}
                        onSubmit={handleModalSubmit}
                        isLoading={isLoading}
                        loadingMessage={loadingMessage}
                        modalRef={modalRef}
                    />
                    <header className="bg-white shadow-md p-2 flex items-center justify-between z-30 flex-shrink-0">
                        <div className="flex items-center space-x-4">
                            {isEditingName ? (
                                <input
                                    type="text"
                                    value={madorizuName}
                                    onChange={(e) => setMadorizuName(e.target.value)}
                                    onBlur={() => setIsEditingName(false)}
                                    onKeyDown={(e) => { if (e.key === 'Enter') setIsEditingName(false); }}
                                    className="text-xl font-bold text-gray-800 ml-4 bg-gray-100 border-b-2 border-indigo-500 focus:outline-none"
                                    autoFocus
                                />
                            ) : (
                                <span
                                    onClick={() => setIsEditingName(true)}
                                    className="text-xl font-bold text-gray-800 ml-4 cursor-pointer hover:bg-gray-100 p-1 rounded-md"
                                    title="クリックして名前を編集"
                                >
                                    {madorizuName}
                                </span>
                            )}
                            <div className={`text-sm transition-opacity duration-300 
                                ${saveStatus === '保存済み' ? 'text-gray-500' : 
                                saveStatus === '保存中...' ? 'text-blue-500 animate-pulse' : 
                                'text-gray-800 font-medium'
                                }`}>
                                {saveStatus}
                            </div>
                        </div>
                        <div className="flex items-center space-x-2">
                            <button onClick={() => window.location.href = 'index.html'} className="px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600">TOPに戻る</button>
                            <button onClick={handleSaveImage} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">PNGで保存</button>
                            <button onClick={handleExportJson} className="px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600">JSONコピー</button>
                            <button onClick={handleUndo} disabled={historyState.past.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">戻る</button>
                            <button onClick={handleRedo} disabled={historyState.future.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">進む</button>
                            <div className="flex items-center space-x-2">
                                <button onClick={() => setZoom(z => Math.max(0.2, z - 0.1))} className="px-3 py-1 bg-gray-200 rounded">-</button>
                                <span>{Math.round(zoom * 100)}%</span>
                                <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="px-3 py-1 bg-gray-200 rounded">+</button>
                            </div>
                        </div>
                    </header>

                    <div className="flex-1 relative overflow-hidden">
                        <DebugPanel 
                            isDebugOpen={isDebugOpen} 
                            setIsDebugOpen={setIsDebugOpen} 
                            debugData={debugData} 
                        />
                        <main ref={editorAreaRef} className="editor-area w-full h-full bg-gray-200">
                            <div className="scroll-wrapper">
                                <div ref={editorContainerRef} className="editor-container" style={{ width: dimensions.width, height: dimensions.height, transform: `translate(-50%, -50%) scale(${zoom})`, ...(isGridVisible && { backgroundImage: `linear-gradient(to right, #f3f4f6 1px, transparent 1px), linear-gradient(to bottom, #f3f4f6 1px, transparent 1px)`, backgroundSize: `${gridSize}px ${gridSize}px` }) }}>
                                    {imageUrl && <img 
                                        ref={imageRef} 
                                        src={imageUrl} 
                                        alt="間取り図" 
                                        className="editor-image" 
                                        style={{ 
                                            opacity: displayImageOpacity,
                                            transition: 'opacity 0.2s ease-in-out',
                                            transform: `translate(-50%, -50%) translate(${imagePosition.x}px, ${imagePosition.y}px) scale(${imageScale})`,
                                            cursor: isDisplaySettingsOpen ? 'grab' : 'default',
                                            pointerEvents: isDisplaySettingsOpen ? 'all' : 'none'
                                        }} 
                                        crossOrigin="anonymous"
                                    />}
                                    <canvas ref={canvasRef} className={getCursorClass()} width={dimensions.width} height={dimensions.height} />
                                    <svg ref={svgRef} className="editor-svg" width={dimensions.width} height={dimensions.height} xmlns="http://www.w3.org/2000/svg" style={{ opacity: displayDrawingOpacity, transition: 'opacity 0.2s ease-in-out' }} onMouseDown={handleMouseDown} onContextMenu={handleCanvasContextMenu}>
                                        <defs>
                                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                                <polygon points="0 0, 10 3.5, 0 7" />
                                            </marker>
                                        </defs>
                                        {sortedElements.map(el => {
                                            const isDirectlySelected = el.id === selectedId;
                                            const isPartOfSelectedSpace = selectedElement?.type === 'space' && el.groupId === selectedId;
                                            const isHighlighted = (isDirectlySelected || isPartOfSelectedSpace) && !isPickingColor;

                                            const stroke = isHighlighted ? SELECTED_ELEMENT_COLOR : (el.color || el.stroke || DEFAULT_STROKE_COLOR); 
                                            const strokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                            const style = LINE_STYLES.find(s => s.id === el.lineStyle);
                                            
                                            if (el.type === 'space') {
                                                return (
                                                    <g key={el.id} data-id={el.id} onContextMenu={handleContextMenu}>
                                                        <polygon
                                                            data-id={el.id}
                                                            points={el.points}
                                                            fill={el.fill}
                                                            stroke="none"
                                                            style={{ pointerEvents: isHighlighted ? 'all' : 'auto', cursor: 'pointer' }}
                                                        />
                                                        <BackgroundRenderer element={el} />
                                                        
                                                        {el.lineStyle === 'double' && (() => {
                                                            const wallStroke = (isHighlighted && !isPickingColor) ? SELECTED_ELEMENT_COLOR : (el.stroke || DEFAULT_STROKE_COLOR);
                                                            const wallWidth = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                                            const singleLineWidth = 1.5;
                                                            const whiteLineWidth = Math.max(0, wallWidth - (singleLineWidth * 2));
                                            
                                                            return (
                                                                <g style={{ pointerEvents: 'none' }}>
                                                                    {/* 1. 外側の枠線 (マイター結合を指定) */}
                                                                    <polygon
                                                                        points={el.points}
                                                                        fill="none"
                                                                        stroke={wallStroke}
                                                                        strokeWidth={wallWidth}
                                                                        strokeLinejoin="miter" // ← ★★★マイター結合を指定
                                                                    />
                                                                    {/* 2. 内側の白い線 (マイター結合を指定) */}
                                                                    <polygon
                                                                        points={el.points}
                                                                        fill="none"
                                                                        stroke="white"
                                                                        strokeWidth={whiteLineWidth}
                                                                        strokeLinejoin="miter" // ← ★★★マイター結合を指定
                                                                    />
                                                                </g>
                                                            );
                                                        })()}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'wall') {
                                                const isPartOfSpace = !!el.groupId;
                                                const isWallSelected = selectedId === el.id;
                                                const isSpaceSelected = isPartOfSpace && selectedId === el.groupId;
                                                const isHighlighted = isWallSelected || isSpaceSelected;
                                            
                                                // ▼▼▼【ここからが変更箇所です】▼▼▼
                                                
                                                // 空間に属する壁で、スタイルが二重線の場合の特別処理
                                                if (el.groupId && el.lineStyle === 'double') {
                                                    return (
                                                        <g key={el.id} data-id={el.id} onContextMenu={handleContextMenu}>
                                                            {/* 1. クリックや右クリックのイベントを受け取るための、透明な太い線 */}
                                                            <line
                                                                x1={el.x1} y1={el.y1}
                                                                x2={el.x2} y2={el.y2}
                                                                stroke="transparent"
                                                                strokeWidth={Math.max(el.strokeWidth || 0, 10)} // クリックしやすいように最低10pxの幅を確保
                                                                style={{ cursor: 'pointer' }}
                                                            />
                                                            {/* 2. この壁が「直接」選択された場合のみ、ハイライト線を描画 */}
                                                            {isWallSelected && (
                                                                <line
                                                                    x1={el.x1} y1={el.y1}
                                                                    x2={el.x2} y2={el.y2}
                                                                    stroke={SELECTED_ELEMENT_COLOR}
                                                                    strokeWidth={el.strokeWidth}
                                                                    strokeLinejoin="miter" // 結合部を滑らかにする
                                                                    style={{ pointerEvents: 'none' }} // ハイライト自体はクリックイベントを拾わない
                                                                />
                                                            )}
                                                        </g>
                                                    );
                                                }
                                                
                                                // --- 通常の壁（独立した壁や、二重線以外の空間の壁）の描画処理 ---
                                                const finalStroke = isHighlighted ? SELECTED_ELEMENT_COLOR : (el.stroke || el.color || DEFAULT_STROKE_COLOR);
                                                const finalStrokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                                const finalLineStyleId = el.lineStyle || 'solid';
                                                const finalStyle = LINE_STYLES.find(s => s.id === finalLineStyleId);
                                            
                                                // 実線または二重線の場合 (CustomLineRendererを使わない場合)
                                                if (finalLineStyleId === 'solid' || finalLineStyleId === 'double') {
                                                    const isDouble = finalLineStyleId === 'double';
                                                    const singleLineWidth = 1.5;
                                                    const innerSpaceWidth = finalStrokeW - (singleLineWidth * 2);
                                                    const offsetDistance = (finalStrokeW / 2) - (singleLineWidth / 2);
                                            
                                                    const dx = el.x2 - el.x1;
                                                    const dy = el.y2 - el.y1;
                                                    const len = Math.sqrt(dx * dx + dy * dy);
                                                    const offsetX = len > 0 ? -dy / len * offsetDistance : 0;
                                                    const offsetY = len > 0 ? dx / len * offsetDistance : 0;
                                            
                                                    return (
                                                        <g key={el.id} data-id={el.id} onContextMenu={handleContextMenu} style={{ cursor: 'pointer' }}>
                                                            {isDouble ? (
                                                                <g style={{ pointerEvents: 'none' }}>
                                                                    <line x1={el.x1} y1={el.y1} x2={el.x2} y2={el.y2} stroke="white" strokeWidth={innerSpaceWidth + 2} strokeLinecap="butt" strokeLinejoin="miter" />
                                                                    <line x1={el.x1 + offsetX} y1={el.y1 + offsetY} x2={el.x2 + offsetX} y2={el.y2 + offsetY} stroke={finalStroke} strokeWidth={singleLineWidth} strokeLinecap="butt" strokeLinejoin="miter" />
                                                                    <line x1={el.x1 - offsetX} y1={el.y1 - offsetY} x2={el.x2 - offsetX} y2={el.y2 - offsetY} stroke={finalStroke} strokeWidth={singleLineWidth} strokeLinecap="butt" strokeLinejoin="miter" />
                                                                </g>
                                                            ) : (
                                                                <line x1={el.x1} y1={el.y1} x2={el.x2} y2={el.y2} stroke={finalStroke} strokeWidth={finalStrokeW} strokeLinecap="square" style={{ pointerEvents: 'none' }} />
                                                            )}
                                                            <line x1={el.x1} y1={el.y1} x2={el.x2} y2={el.y2} stroke="transparent" strokeWidth={Math.max(finalStrokeW, 10)} />
                                                        </g>
                                                    );
                                                } else {
                                                    // それ以外の線（点線、破線など）は新しいコンポーネントで描画
                                                    return (
                                                        <CustomLineRenderer
                                                            key={el.id}
                                                            id={el.id}
                                                            x1={el.x1} y1={el.y1}
                                                            x2={el.x2} y2={el.y2}
                                                            stroke={finalStroke}
                                                            strokeWidth={finalStrokeW}
                                                            lineStyle={finalLineStyleId}
                                                            onContextMenu={handleContextMenu}
                                                        />
                                                    );
                                                }
                                            }
                                            if (el.type === 'stairs') {
                                                return <StairsRenderer key={el.id} element={{...el, color: stroke, strokeWidth: strokeW}} onContextMenu={handleContextMenu} />;
                                            }
                                            if (el.type === 'text') {
                                                return (
                                                    <TextRenderer 
                                                        key={el.id} 
                                                        element={el} 
                                                        isDirectlySelected={isDirectlySelected} 
                                                        isDragging={isDragging} 
                                                        onContextMenu={handleContextMenu}
                                                        dimensions={dimensions}
                                                        zoom={zoom}
                                                    />
                                                );
                                            }
                                            if (el.type === 'compass') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const template = COMPASS_TEMPLATES.find(t => t.id === el.templateId) || COMPASS_TEMPLATES[0];
                                                return (
                                                    <g key={el.id} data-id={el.id} onContextMenu={handleContextMenu} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0})`} style={{cursor: isDirectlySelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <image href={template.src} x={-el.size / 2} y={-el.size / 2} width={el.size} height={el.size} preserveAspectRatio="xMidYMid meet" />
                                                        {isDirectlySelected && <rect x={-el.size/2 - 2} y={-el.size/2 - 2} width={el.size + 4} height={el.size + 4} fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2" />}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'fixture') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === el.templateId))] || FIXTURE_TEMPLATES.kitchen;
                                                const template = templateCategory.find(t => t.id === el.templateId) || FIXTURE_TEMPLATES.kitchen[0];

                                                let handles = null;
                                                // 選択されている場合にのみハンドルを描画
                                                if (isDirectlySelected) {
                                                    const { corners, edges } = getVerticesAndEdges(el);
                                                    handles = (
                                                        <g>
                                                            {/* 青い枠線 */}
                                                            <rect 
                                                                x={-el.width / 2 - 5} y={-el.height / 2 - 5}
                                                                width={el.width + 10} height={el.height + 10}
                                                                fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth={1.5 / zoom}
                                                                strokeDasharray={`${4 / zoom}, ${2 / zoom}`}
                                                                style={{ pointerEvents: 'none' }}
                                                            />
                                                            {/* 四隅の黒いポッチ */}
                                                            {corners.map((corner, index) => (
                                                                <circle key={`handle-corner-${el.id}-${index}`}
                                                                    data-id={el.id} data-handle-index={index} data-handle-type="fixtureCorner"
                                                                    cx={corner.x} cy={corner.y} r={6 / zoom}
                                                                    fill="black" stroke="white" strokeWidth={2 / zoom}
                                                                    style={{ cursor: ['nwse-resize', 'nesw-resize', 'nwse-resize', 'nesw-resize'][index] }}
                                                                />
                                                            ))}
                                                            {/* 各辺の白いひし形 */}
                                                            {edges.map((edge, index) => (
                                                                <rect key={`handle-edge-${el.id}-${index}`}
                                                                    data-id={el.id} data-handle-index={index} data-handle-type="fixtureEdge"
                                                                    x={edge.x - 5 / zoom} y={edge.y - 5 / zoom}
                                                                    width={10 / zoom} height={10 / zoom}
                                                                    fill="white" stroke="black" strokeWidth={1 / zoom}
                                                                    style={{ cursor: (index === 0 || index === 2) ? 'ns-resize' : 'ew-resize' }}
                                                                    transform={`rotate(45 ${edge.x} ${edge.y})`}
                                                                />
                                                            ))}
                                                        </g>
                                                    );
                                                }

                                                let fixtureElement;
                                                if (template.src) {
                                                    fixtureElement = <image
                                                        href={template.src}
                                                        x={-el.width / 2} y={-el.height / 2}
                                                        width={el.width} height={el.height}
                                                        preserveAspectRatio="none"
                                                    />;
                                                } else {
                                                    const scaleX = el.width / template.defaultSize;
                                                    const scaleY = el.height / template.defaultSize;
                                                    fixtureElement = <g transform={`scale(${scaleX}, ${scaleY})`}>
                                                        <path 
                                                            d={template.path} 
                                                            fill={el.fill} 
                                                            stroke={el.stroke} 
                                                            strokeWidth={el.strokeWidth}
                                                            vectorEffect="non-scaling-stroke" // スケールしても線の太さを維持
                                                        />
                                                    </g>;
                                                }

                                                return (
                                                    <g key={el.id} data-id={el.id} onContextMenu={handleContextMenu} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0}) ${el.isFlipped ? 'scale(-1, 1)' : ''}`} style={{cursor: isDirectlySelected ? 'default' : 'grab'}}>
                                                        {fixtureElement}
                                                        {handles}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'door' || el.type === 'window') {
                                                // 要素の中心座標を計算
                                                const centerX = (el.x1 + el.x2) / 2;
                                                const centerY = (el.y1 + el.y2) / 2;
                                                const template = el.type === 'door' 
                                                ? (DOOR_TEMPLATES.find(t => t.id === el.templateId) || DOOR_TEMPLATES[0]) 
                                                : (WINDOW_TEMPLATES.find(t => t.id === el.templateId) || WINDOW_TEMPLATES[0]);
                                                
                                                const totalRotation = el.baseAngle + (el.rotation || 0);
                                                const paths = template.path(el.length, el.swingDirection, el.isInner, el.wallThickness);

                                                if (Array.isArray(paths)) {
                                                    const padding = 4 / zoom;
                                                    const clickPadding = 5;
                                                    return (
                                                        <g key={el.id} data-id={el.id} onContextMenu={handleContextMenu} transform={`translate(${centerX}, ${centerY}) rotate(${totalRotation}) translate(${-el.length / 2}, 0)`} style={{cursor: isDirectlySelected && isDragging ? 'grabbing' : 'grab'}}>
                                                            {paths.map((part, index) => (
                                                            <path
                                                                key={index}
                                                                d={part.d}
                                                                fill={part.fill === 'currentColor' ? stroke : part.fill || 'none'}
                                                                stroke={part.stroke === 'currentColor' ? stroke : part.stroke || 'none'}
                                                                strokeWidth={part.strokeWidth || 1}
                                                                strokeLinecap="square"
                                                                style={{pointerEvents: 'none'}}
                                                            />
                                                            ))}
                                                            <rect 
                                                                x={-clickPadding}
                                                                y={-el.wallThickness / 2 - clickPadding}
                                                                width={el.length + clickPadding * 2}
                                                                height={el.wallThickness + clickPadding * 2}
                                                                fill="transparent" 
                                                                style={{pointerEvents: 'all', cursor: 'pointer'}}
                                                            />
                                                            {isHighlighted && (
                                                            <rect
                                                                x={-padding}
                                                                y={-el.wallThickness / 2 - padding}
                                                                width={el.length + padding * 2}
                                                                height={el.wallThickness + padding * 2}
                                                                fill="none"
                                                                stroke={SELECTED_ELEMENT_COLOR}
                                                                strokeWidth={1.5 / zoom}
                                                                strokeDasharray={`4, ${4 / zoom}`}
                                                                style={{ pointerEvents: 'none' }}
                                                            />
                                                            )}
                                                        </g>
                                                    );
                                                }
                                            }
                                            return null;
                                        })}

                                        {guideLines.map((line, index) => (
                                            <line
                                                key={`guide-${index}`}
                                                x1={line.x1}
                                                y1={line.y1}
                                                x2={line.x2}
                                                y2={line.y2}
                                                stroke={SELECTED_ELEMENT_COLOR}
                                                strokeWidth={1 / zoom}
                                                strokeDasharray={`${4 / zoom}, ${4 / zoom}`}
                                                style={{ pointerEvents: 'none' }}
                                            />
                                        ))}

                                        <StairsPrePlacementPreview 
                                            previewInfo={stairSnapPreview} 
                                            width={stairWidth} 
                                            color={SELECTED_ELEMENT_COLOR} 
                                        />
                                        
                                        <StairsPrePlacementPreview 
                                            previewInfo={stairSnapPreview} 
                                            width={stairWidth} 
                                            color={SELECTED_ELEMENT_COLOR} 
                                        />

                                        {/* スナップされた位置に表示される丸印 */}
                                        {snappedInfo && (editorMode === 'create' || editorMode === 'continuous-create') && (() => {
                                            let snapStrokeColor;
                                            let snapStrokeWidth;

                                            if (snappedInfo.type === 'vertex' || snappedInfo.type === 'startPoint') { // 'startPoint' を追加
                                                snapStrokeColor = '#FF0000'; // 赤色に統一
                                                snapStrokeWidth = 4 / zoom; // 太めの線
                                            } else if (snappedInfo.type === 'wall') {
                                                snapStrokeColor = '#FF0000'; // 赤色に統一
                                                snapStrokeWidth = 2 / zoom; // 通常の線
                                            } else { // 'grid' の場合
                                                snapStrokeColor = SELECTED_ELEMENT_COLOR; // グリッドスナップはデフォルトの青色
                                                snapStrokeWidth = 2 / zoom;
                                            }

                                            return (
                                                <circle
                                                    cx={snappedInfo.point.x}
                                                    cy={snappedInfo.point.y}
                                                    r={8 / zoom} // ズームによってサイズを調整
                                                    fill="none"
                                                    stroke={snapStrokeColor}
                                                    strokeWidth={snapStrokeWidth}
                                                    style={{ pointerEvents: 'none' }}
                                                />
                                            );
                                        })()}
                                                
                                        {/* 編集モード時のハンドルや枠線の描画 */}
                                        {editorMode === 'edit' && (() => {
                                            if (!selectedElement) return null;
                                        
                                            const { id, type } = selectedElement;
                                        
                                            // 選択された要素のタイプに応じて、適切なハンドルを描画
                                            switch (type) {
                                                // 壁・ドア・窓が選択された場合：両端の頂点ハンドルを表示
                                                case 'wall':
                                                case 'door':
                                                case 'window': {
                                                    const { vertices } = getVerticesAndEdges(selectedElement);
                                                    return (
                                                        <g>
                                                            {vertices.map((vertex, index) => (
                                                                <circle
                                                                    key={`handle-vertex-${id}-${index}`}
                                                                    data-id={id}
                                                                    data-handle-index={index}
                                                                    data-handle-type={type}
                                                                    cx={vertex.x}
                                                                    cy={vertex.y}
                                                                    r={6 / zoom}
                                                                    fill="black"
                                                                    stroke="white"
                                                                    strokeWidth={2 / zoom}
                                                                    style={{ cursor: 'pointer' }}
                                                                />
                                                            ))}
                                                        </g>
                                                    );
                                                }
                                                
                                                // 空間が選択された場合：四隅と各辺のハンドルを表示
                                                case 'space': {
                                                    const { corners, edges } = getVerticesAndEdges(selectedElement);
                                                    return (
                                                        <g>
                                                            {corners.map((corner, index) => (
                                                                <circle
                                                                    key={`handle-corner-${id}-${index}`}
                                                                    data-id={id}
                                                                    data-handle-index={index}
                                                                    data-handle-type="spaceCorner"
                                                                    cx={corner.x}
                                                                    cy={corner.y}
                                                                    r={6 / zoom}
                                                                    fill="black"
                                                                    stroke="white"
                                                                    strokeWidth={2 / zoom}
                                                                    style={{ cursor: getResizeCursor(index, corners.length) }}
                                                                />
                                                            ))}
                                                            {edges.map((edge, index) => (
                                                                <rect
                                                                    key={`handle-edge-${id}-${index}`}
                                                                    data-id={id}
                                                                    data-handle-index={index}
                                                                    data-handle-type="spaceEdge"
                                                                    x={edge.x - 5 / zoom}
                                                                    y={edge.y - 5 / zoom}
                                                                    width={10 / zoom}
                                                                    height={10 / zoom}
                                                                    fill="white"
                                                                    stroke="black"
                                                                    strokeWidth={1 / zoom}
                                                                    style={{ cursor: (index === 0 || index === 2) ? 'ns-resize' : 'ew-resize' }}
                                                                    transform={`rotate(45 ${edge.x} ${edge.y})`}
                                                                />
                                                            ))}
                                                        </g>
                                                    );
                                                }
                                                
                                                // 他の要素タイプ（fixtureなど）のハンドル表示もここに追加できます
                                        
                                                default:
                                                    return null;
                                            }
                                        })()}

                                        {/* --- 設備プレビューの描画 --- */}
                                        {(editorMode === 'create' || editorMode === 'continuous-create') && drawingMode === 'fixture' && (() => {
                                            const template = FIXTURE_TEMPLATES[fixtureCategory]?.find(t => t.id === fixtureTemplateId) || FIXTURE_TEMPLATES.kitchen[0];
                                            if (!template) return null;

                                            const baseSize = BASE_FIXTURE_DEFAULT_SIZE;
                                            const templateDefaultSize = template.defaultSize || baseSize;
                                            const scaleRatio = baseSize / templateDefaultSize;
                                            const previewWidth = fixtureSize * scaleRatio;
                                            const aspectRatio = template.aspectRatio || 1;
                                            const previewHeight = previewWidth / aspectRatio;

                                            let previewElement;
                                            if (template.src) {
                                                previewElement = <image href={template.src} x={-previewWidth / 2} y={-previewHeight / 2} width={previewWidth} height={previewHeight} preserveAspectRatio="none" />;
                                            } else {
                                                const scaleX = previewWidth / template.defaultSize;
                                                const scaleY = previewHeight / template.defaultSize;
                                                previewElement = <g transform={`scale(${scaleX}, ${scaleY})`}><path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} vectorEffect="non-scaling-stroke" /></g>;
                                            }

                                            // ▼▼▼【修正点】1クリック前と後で処理を分岐 ▼▼▼
                                            if (pendingFixture) {
                                                // 1クリック後の処理 (位置を固定し、回転/反転をマウスで変更)
                                                const startPoint = pendingFixture;
                                                const endPoint = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                                const dx = endPoint.x - startPoint.x;
                                                const dy = endPoint.y - startPoint.y;
                                                const finalRotation = fixtureRotation + ((dx < 0) ? 180 : 0);
                                                const isFlipped = (dy > 0);
                                                return (
                                                    <g transform={`translate(${startPoint.x}, ${startPoint.y}) rotate(${finalRotation || 0}) ${isFlipped ? 'scale(-1, 1)' : ''}`} style={{ opacity: 0.7, pointerEvents: 'none' }}>
                                                        {previewElement}
                                                    </g>
                                                );
                                            } else {
                                                // 1クリック前の処理 (マウスカーソルに追従)
                                                const previewPos = (isGridVisible && !isModifierKeyDown) ? getGridSnappedPoint(mousePos) : mousePos;
                                                return (
                                                    <g transform={`translate(${previewPos.x}, ${previewPos.y}) rotate(${fixtureRotation || 0}) ${fixtureFlip ? 'scale(-1, 1)' : ''}`} style={{ opacity: 0.7, pointerEvents: 'none' }}>
                                                        {previewElement}
                                                    </g>
                                                );
                                            }
                                        })()}

                                        {/* --- 方角の1クリック前プレビュー --- */}
                                          {!drawingStartPoint && (editorMode === 'create' || editorMode === 'continuous-create') && drawingMode === 'compass' && (() => {
                                              const template = COMPASS_TEMPLATES.find(t => t.id === compassTemplateId) || COMPASS_TEMPLATES[0];
                                              const previewSize = 50; // プレビュー用のデフォルトサイズ
                                              const previewPos = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                  
                                              return (
                                                  <g transform={`translate(${previewPos.x}, ${previewPos.y})`} style={{ opacity: 0.7, pointerEvents: 'none' }}>
                                                      <image
                                                          href={template.src}
                                                          x={-previewSize / 2}
                                                          y={-previewSize / 2}
                                                          width={previewSize}
                                                          height={previewSize}
                                                          preserveAspectRatio="xMidYMid meet"
                                                      />
                                                  </g>
                                              );
                                          })()}

                                        {/* --- 既存の2クリック描画プレビュー --- */}
                                        {drawingStartPoint && !linePoints.length && (editorMode === 'create' || editorMode === 'continuous-create') && (() => {
                                            let previewEndPoint;
                                            const walls = svgElements.filter(el => el.type === 'wall');

                                            // 「壁の上に描画」が有効で、かつ1クリック目で壁にスナップした場合
                                            if ((drawingMode === 'door' || drawingMode === 'window') && isSnapToWall && !isModifierKeyDown && activeSnapWallRef.current) {
                                                
                                                // 1クリック目でスナップした壁の情報を取得
                                                const wall = activeSnapWallRef.current;
                                                const p1 = { x: wall.x1, y: wall.y1 };
                                                const p2 = { x: wall.x2, y: wall.y2 };
                                        
                                                // マウスカーソルを「その壁の線分上」に投影して終点を計算
                                                const dx = p2.x - p1.x;
                                                const dy = p2.y - p1.y;
                                        
                                                if (dx === 0 && dy === 0) {
                                                     previewEndPoint = p1; // 線分が点の場合は始点をそのまま使用
                                                } else {
                                                    // 線分に対するマウスカーソルの射影を計算
                                                    const t = ((mousePos.x - p1.x) * dx + (mousePos.y - p1.y) * dy) / (dx * dx + dy * dy);
                                                    // 線分の範囲内（0 <= t <= 1）に終点をクランプする
                                                    const clampedT = Math.max(0, Math.min(1, t)); 
                                                    previewEndPoint = {
                                                        x: p1.x + clampedT * dx,
                                                        y: p1.y + clampedT * dy
                                                    };
                                                }
                                        
                                            } else {
                                                // それ以外の場合は、従来通りスナップ情報かグリッド位置を使用
                                                previewEndPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(mousePos) : mousePos);
                                            }
                                            if(drawingMode === 'compass') {
                                                const template = COMPASS_TEMPLATES.find(t => t.id === compassTemplateId) || COMPASS_TEMPLATES[0];
                                                const dx = mousePos.x - drawingStartPoint.x;
                                                const dy = mousePos.y - drawingStartPoint.y;
                                                const distance = Math.sqrt(dx*dx + dy*dy);
                                                const size = Math.min(300, Math.max(20, distance));
                                                const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                                                return (
                                                    <g transform={`translate(${drawingStartPoint.x}, ${drawingStartPoint.y}) rotate(${rotation})`} style={{ pointerEvents: 'none' }}>
                                                        <image href={template.src} x={-size / 2} y={-size / 2} width={size} height={size} preserveAspectRatio="xMidYMid meet" opacity="0.7"/>
                                                    </g>
                                                );
                                            }
                                            if(drawingMode === 'space' && spaceShape === 'rect') {
                                                // スナップ情報があればそれを使い、なければグリッドスナップされたマウス位置を使います
                                                const previewEndPoint = snappedInfo ? snappedInfo.point : (isGridVisible ? getGridSnappedPoint(mousePos) : mousePos);
                                                return <rect 
                                                    x={Math.min(drawingStartPoint.x, previewEndPoint.x)} 
                                                    y={Math.min(drawingStartPoint.y, previewEndPoint.y)} 
                                                    width={Math.abs(drawingStartPoint.x - previewEndPoint.x)} 
                                                    height={Math.abs(drawingStartPoint.y - previewEndPoint.y)} 
                                                    fill="transparent" 
                                                    stroke={SELECTED_ELEMENT_COLOR}
                                                    strokeWidth={strokeWidth} // strokeWidth stateを参照するように変更
                                                    strokeDasharray="5,5" 
                                                    style={{ pointerEvents: 'none' }} 
                                                    shapeRendering="crispEdges" 
                                                />;
                                            }
                                            if(drawingMode === 'door' || drawingMode === 'window' || drawingMode === 'wall') return <line 
                                                x1={drawingStartPoint.x} 
                                                y1={drawingStartPoint.y} 
                                                x2={previewEndPoint.x} 
                                                y2={previewEndPoint.y} 
                                                stroke={SELECTED_ELEMENT_COLOR}
                                                strokeWidth={strokeWidth} 
                                                strokeDasharray="5,5" 
                                                style={{ pointerEvents: 'none' }} 
                                            />;
                                            return null;
                                        })()}
                                        {snappedInfo && (
                                            <g style={{ pointerEvents: 'none' }}>
                                                <circle 
                                                    cx={snappedInfo.point.x} 
                                                    cy={snappedInfo.point.y} 
                                                    r={SNAP_THRESHOLD / zoom} 
                                                    fill="rgba(59, 130, 246, 0.2)" 
                                                />
                                                <circle 
                                                    cx={snappedInfo.point.x} 
                                                    cy={snappedInfo.point.y} 
                                                    r={6 / zoom} 
                                                    fill="white"
                                                    stroke="#3b82f6"
                                                    strokeWidth={1.5 / zoom}
                                                />
                                            </g>
                                        )}
                                        {snappedInfo && !drawingStartPoint && (
                                            <g style={{ pointerEvents: 'none' }}>
                                                <circle 
                                                    cx={snappedInfo.point.x}
                                                    cy={snappedInfo.point.y}
                                                    r={SNAP_THRESHOLD / zoom} 
                                                    fill="rgba(59, 130, 246, 0.2)" 
                                                />
                                                <circle 
                                                    cx={snappedInfo.point.x} 
                                                    cy={snappedInfo.point.y} 
                                                    r={6 / zoom} 
                                                    fill="white"
                                                    stroke="#3b82f6"
                                                    strokeWidth={1.5 / zoom}
                                                />
                                            </g>
                                        )}
                                        {linePoints.length > 0 && (
                                            <g style={{ pointerEvents: 'none' }}>
                                            {linePoints.map((p, i) => {
                                                if (i === 0) return null;
                                                const p1 = linePoints[i-1];
                                                return <line key={i} x1={p1.x} y1={p1.y} x2={p.x} y2={p.y} stroke={SELECTED_ELEMENT_COLOR} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray={LINE_STYLES.find(s => s.id === lineStyle)?.dashArray || 'none'} />;
                                            })}
                                                <line
                                                    x1={linePoints[linePoints.length - 1].x}
                                                    y1={linePoints[linePoints.length - 1].y}
                                                    x2={isSnappingToStart ? linePoints[0].x : (snappedInfo ? snappedInfo.point.x : (isGridVisible ? getGridSnappedPoint(mousePos).x : mousePos.x))}
                                                    y2={isSnappingToStart ? linePoints[0].y : (snappedInfo ? snappedInfo.point.y : (isGridVisible ? getGridSnappedPoint(mousePos).y : mousePos.y))}
                                                    stroke={SELECTED_ELEMENT_COLOR}
                                                    strokeWidth={DEFAULT_STROKE_WIDTH}
                                                    strokeDasharray="5,5"
                                                />
                                            </g>
                                        )}
                                        {linePoints.length > 0 && drawingMode === 'stairs' && (
                                            // 階段作成時は、新しいプレビューコンポーネントを呼び出す
                                            <StairsPreviewRenderer 
                                                points={[...linePoints, mousePos]}
                                                width={stairWidth}
                                                color={strokeColor}
                                            />
                                        )}
                                        {pendingWindow && (editorMode === 'create' || editorMode === 'continuous-create') && (() => {
                                            const { start, end } = pendingWindow;
                                            // 始点と終点の中間点を計算
                                            const center = {
                                                x: (start.x + end.x) / 2,
                                                y: (start.y + end.y) / 2,
                                            };
                                            // 中間点とマウスカーソルの相対位置を計算
                                            const dx = mousePos.x - center.x;
                                            const dy = mousePos.y - center.y;

                                            let rotation = 0;
                                            let isInner = false;

                                            // マウスカーソルの位置から4方向を決定
                                            if (dx < 0 && dy < 0) { // 左上
                                                rotation = 180;
                                                isInner = true;
                                            } else if (dx > 0 && dy < 0) { // 右上
                                                rotation = 0;
                                                isInner = false;
                                            } else if (dx > 0 && dy > 0) { // 右下
                                                rotation = 0;
                                                isInner = true;
                                            } else { // 左下
                                                rotation = 180;
                                                isInner = false;
                                            }

                                            const length = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                                            const baseAngle = Math.atan2(end.y - start.y, end.x - start.x) * 180 / Math.PI;
                                            const totalRotation = baseAngle + rotation;
                                            
                                            let template;
                                            if (drawingMode === 'door') {
                                                template = DOOR_TEMPLATES.find(t => t.id === doorTemplateId) || DOOR_TEMPLATES[0];
                                            } else { // windowの場合
                                                template = WINDOW_TEMPLATES.find(t => t.id === windowTemplateId) || WINDOW_TEMPLATES[0];
                                            }
                                            const wallThickness = (isSnapToWall && activeSnapWallRef.current ? activeSnapWallRef.current.strokeWidth : wallObjectThickness);
                                            const paths = template.path(length, 'clockwise', isInner, wallThickness);

                                            if (!Array.isArray(paths)) return null;

                                            // 決定した方向でプレビュー用の窓を描画
                                            return (
                                                <g 
                                                    transform={`translate(${center.x}, ${center.y}) rotate(${totalRotation}) translate(${-length / 2}, 0)`}
                                                    style={{ pointerEvents: 'none', opacity: 0.7 }}
                                                >
                                                    {paths.map((part, index) => (
                                                        <path
                                                            key={index}
                                                            d={part.d}
                                                            fill={part.fill === 'currentColor' ? strokeColor : part.fill || 'none'}
                                                            stroke={part.stroke === 'currentColor' ? strokeColor : part.stroke || 'none'}
                                                            strokeWidth={part.strokeWidth || 1}
                                                            strokeDasharray="5,5" // プレビューなので点線にする
                                                        />
                                                    ))}
                                                </g>
                                            );
                                        })()}
                                        {tooltip.visible && (
                                            <foreignObject x={tooltip.x - 125} y={tooltip.y - 55} width="250" height="60" style={{ pointerEvents: 'none', overflow: 'visible' }}>
                                                <div xmlns="http://www.w3.org/1999/xhtml"
                                                    style={{
                                                        opacity: tooltip.fading ? 0 : 1,
                                                        transition: 'opacity 2s ease-out',
                                                        background: 'rgba(0, 0, 0, 0.75)',
                                                        color: 'white',
                                                        padding: '8px 12px',
                                                        borderRadius: '6px',
                                                        fontSize: '13px',
                                                        fontFamily: "'Noto Sans JP', sans-serif",
                                                        position: 'relative',
                                                        textAlign: 'center',
                                                        userSelect: 'none'
                                                    }}>
                                                        {tooltip.message}
                                                        <div style={{
                                                            position: 'absolute',
                                                            top: '100%',
                                                            left: '50%',
                                                            transform: 'translateX(-50%)',
                                                            width: 0,
                                                            height: 0,
                                                            borderLeft: '8px solid transparent',
                                                            borderRight: '8px solid transparent',
                                                            orderTop: '8px solid rgba(0, 0, 0, 0.75)',
                                                        }} />
                                                    </div>
                                            </foreignObject>
                                        )}
                                    </svg>
                                </div>
                            </div>
                        </main>

                        <button onClick={() => setSidebarOpen(!isSidebarOpen)} className={`absolute top-16 z-20 bg-indigo-600 hover:bg-indigo-700 text-white w-6 h-12 flex items-center justify-center rounded-r-lg cursor-pointer transition-all duration-300 ease-in-out focus:outline-none ${isSidebarOpen ? 'left-80' : '-left-0'}`} aria-label={isSidebarOpen ? "サイドバーを閉じる" : "サイドバーを開く"}>
                            {isSidebarOpen ? '＜' : '＞'}
                        </button>

                        <aside ref={sidebarRef} className={`absolute top-0 left-0 h-full w-80 bg-gray-50 p-4 space-y-4 z-10 transform transition-transform duration-300 ease-in-out ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`} style={{overflowY: 'auto'}}>
                            <div ref={displaySettingsRef}>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDisplaySettingsOpen(!isDisplaySettingsOpen)}>
                                    <span>表示設定</span>
                                    <span className={`arrow-icon text-gray-400 ${isDisplaySettingsOpen ? 'arrow-icon-open' : 'arrow-icon-closed'}`}>▼</span>
                                </h2>
                                <div className={`accordion-content ${isDisplaySettingsOpen ? 'accordion-content-open' : ''}`}>
                                    <div className="space-y-4">
                                        <div>
                                            <button 
                                                onClick={() => setUploadModalOpen(true)}
                                                className="cursor-pointer block w-full text-sm text-center text-blue-700 bg-blue-50 hover:bg-blue-100 font-semibold py-2 px-4 rounded-full"
                                            >
                                                下絵をアップロード
                                            </button>
                                        </div>
                                        {imageUrl && (
                                            <>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">下絵のサイズ: {Math.round(imageScale * 100)}%</label>
                                                    <div className="flex items-center space-x-2 mt-1">
                                                        <input type="range" min="10" max="300" step="1" value={imageScale * 100} onChange={(e) => setImageScale(parseFloat(e.target.value) / 100)} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        <input type="number" value={Math.round(imageScale * 100)} onChange={(e) => setImageScale(parseInt(e.target.value) / 100 || 0.1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                    </div>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">下絵の透明度: {Math.round(imageOpacity * 100)}%</label>
                                                    <div className="flex items-center space-x-2 mt-1">
                                                        <input type="range" min="0" max="1" step="0.05" value={imageOpacity} onChange={(e) => setImageOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        <input type="number" value={Math.round(imageOpacity * 100)} onChange={(e) => setImageOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                    </div>
                                                </div>
                                            </>
                                        )}
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">レイヤーの透明度: {Math.round(drawingOpacity * 100)}%</label>
                                            <div className="flex items-center space-x-2 mt-1">
                                                <input type="range" min="0" max="1" step="0.05" value={drawingOpacity} onChange={(e) => setDrawingOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                <input type="number" value={Math.round(drawingOpacity * 100)} onChange={(e) => setDrawingOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                            </div>
                                        </div>
                                        <div className="flex items-center">
                                            <input id="grid-toggle" type="checkbox" checked={isGridVisible} onChange={() => setGridVisible(!isGridVisible)} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                            <label htmlFor="grid-toggle" className="ml-2 block text-sm font-medium text-gray-700">グリッド線を表示</label>
                                        </div>
                                        {isGridVisible && (
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">グリッドサイズ: {gridSize}px</label>
                                                <div className="flex items-center space-x-2 mt-1">
                                                    <input type="range" min="1" max="30" step="1" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                    <input type="number" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                            <hr/>
                            <div>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDrawingToolsOpen(!isDrawingToolsOpen)}>
                                    <span>図形描画</span>
                                    <span className={`arrow-icon text-gray-400 ${isDrawingToolsOpen ? 'arrow-icon-open' : 'arrow-icon-closed'}`}>▼</span>
                                </h2>
                                <div className={`accordion-content ${isDrawingToolsOpen ? 'accordion-content-open' : ''}`}>
                                    <div>
                                        <div className="grid grid-cols-3 gap-2 mb-4">
                                            {/* 連続作成ボタン */}
                                            <button
                                                onClick={() => setEditorMode('continuous-create')}
                                                className={`py-2 px-3 rounded-lg text-sm font-semibold transition-all duration-200 ${
                                                    editorMode === 'continuous-create'
                                                        ? 'bg-blue-600 text-white shadow-lg transform scale-105'
                                                        : 'bg-white text-gray-800 hover:bg-blue-50 ring-1 ring-inset ring-gray-200'
                                                }`}
                                            >
                                                連続作成
                                            </button>
                                            
                                            {/* 作成ボタン */}
                                            <button
                                                onClick={() => setEditorMode('create')}
                                                className={`py-2 px-3 rounded-lg text-sm font-semibold transition-all duration-200 ${
                                                    editorMode === 'create'
                                                        ? 'bg-blue-600 text-white shadow-lg transform scale-105'
                                                        : 'bg-white text-gray-800 hover:bg-blue-50 ring-1 ring-inset ring-gray-200'
                                                }`}
                                            >
                                                作成
                                            </button>
                                        
                                            {/* 編集ボタン */}
                                            <button
                                                onClick={() => setEditorMode('edit')}
                                                className={`py-2 px-3 rounded-lg text-sm font-semibold transition-all duration-200 ${
                                                    editorMode === 'edit'
                                                        ? 'bg-amber-500 text-white shadow-lg transform scale-105'
                                                        : 'bg-white text-gray-800 hover:bg-amber-50 ring-1 ring-inset ring-gray-200'
                                                }`}
                                            >
                                                編集
                                            </button>
                                        </div>

                                        {(editorMode === 'create' || editorMode === 'continuous-create') && (
                                            <>
                                                <div className="grid grid-cols-4 gap-2">
                                                    {['space', 'door', 'window', 'wall', 'fixture', 'stairs', 'compass', 'text'].map(mode => {
                                                        const names = {'space':'空間', 'door':'ドア', 'window':'窓', 'wall':'壁', 'fixture':'設備', 'stairs':'階段', 'compass':'方角', 'text':'文字'};
                                                        return <button key={mode} onClick={() => setDrawingMode(mode)} className={`px-2 py-2 rounded text-sm ${drawingMode === mode ? 'bg-indigo-600 text-white' : 'bg-gray-200'}`}>{names[mode]}</button>
                                                    })}
                                                </div>
                                                {drawingMode === 'space' && (
                                                    <div className="mt-4 space-y-4">
                                                        {/* 四角形/線の切り替えボタンは、空間タイプの上で問題なし */}
                                                        <div className="flex bg-gray-200 rounded-lg p-1">
                                                            <button onClick={() => setSpaceShape('rect')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'rect' ? 'bg-white shadow' : ''}`}>四角形</button>
                                                            <button onClick={() => setSpaceShape('line')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'line' ? 'bg-white shadow' : ''}`}>線</button>
                                                        </div>

                                                        {/* 1. 空間タイプ */}
                                                        <SpaceTypeSelector selectedType={spaceType} onChange={handleSpaceTypeChange} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />

                                                        {/* 2. 背景 */}
                                                        <BackgroundSelector selected={backgroundPattern} onChange={setBackgroundPattern} />

                                                        {/* 3. 塗りつぶしの色 */}
                                                        <div> {/* 「塗りつぶしの色」全体のコンテナ */}
                                                            <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                            <div className="flex items-center justify-between mt-1">
                                                                <div className="flex items-center">
                                                                    <input id="transparent-toggle" type="checkbox" checked={fillColor === 'none'} onChange={(e) => {
                                                                        if (e.target.checked) {
                                                                            setLastFillColor(fillColor);
                                                                            setFillColor('none');
                                                                        } else {
                                                                            setFillColor(lastFillColor);
                                                                        }
                                                                    }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                                                    <label htmlFor="transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                </div>
                                                            </div>
                                                            <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${fillColor === 'none' ? 'transparent-bg' : ''}`}>
                                                                <input type="color" value={fillColor === 'none' ? '#ffffff' : fillColor} onChange={(e) => setFillColor(e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className={`h-full w-full ${fillColor === 'none' ? 'opacity-0' : ''}`} disabled={fillColor === 'none'}/>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* 線のプロパティグループ (線の種類、太さ、色) */}
                                                        {/* 編集モードではここに <h3 className="text-md font-semibold mb-2">壁のプロパティ</h3> があるが、作成モードでは不要であれば削除 */}
                                                        <div className="mt-4 pt-4 border-t border-gray-300">
                                                            {/* 4. 線の種類 */}
                                                            <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} isRectShape={spaceShape === 'rect'}/>
                                                            {/* 5. 線の太さ */}
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                                <div className="flex items-center space-x-2 mt-1">
                                                                    <input type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                    <input type="number" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                                </div>
                                                            </div>
                                                            {/* 6. 線の色 */}
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                        </div>

                                                    </div>
                                                )}
                                                {drawingMode === 'wall' && (
                                                    <div className="mt-4 space-y-4">
                                                        <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'stairs' && (
                                                    <div className="mt-4 space-y-4">
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">階段幅: {stairWidth}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="100" step="1" value={stairWidth} onChange={(e) => setStairWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={stairWidth} onChange={(e) => setStairWidth(parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">方向</label>
                                                           <div className="flex bg-gray-200 rounded-lg p-1 mt-1">
                                                                <button onClick={() => setStairDirection('up')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'up' ? 'bg-white shadow' : ''}`}>UP</button>
                                                                <button onClick={() => setStairDirection('down')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'down' ? 'bg-white shadow' : ''}`}>DN</button>
                                                                <button onClick={() => setStairDirection('none')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'none' ? 'bg-white shadow' : ''}`}>非表示</button>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'door' && <div className="mt-4 space-y-4">
                                                    <DoorTemplateSelector selectedTemplateId={doorTemplateId} onChange={setDoorTemplateId} />
                                                    <div className="flex items-center p-2 bg-gray-100 rounded-md">
                                                        <input 
                                                            id="door-snap-toggle" 
                                                            type="checkbox" 
                                                            checked={isSnapToWall} 
                                                            onChange={() => setSnapToWall(!isSnapToWall)}
                                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                        />
                                                        <label htmlFor="door-snap-toggle" className="ml-2 block text-sm font-medium text-gray-700">壁の上に描画する</label>
                                                    </div>
                                                    {!isSnapToWall && (
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">ドアの厚み: {wallObjectThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range" min="1" max="30" step="1"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value))}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value) || 1)}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>}
                                                {drawingMode === 'window' && <div className="mt-4 space-y-4">
                                                    <WindowTemplateSelector selectedTemplateId={windowTemplateId} onChange={setWindowTemplateId} />
                                                    <div className="flex items-center p-2 bg-gray-100 rounded-md">
                                                        <input 
                                                            id="window-snap-toggle" 
                                                            type="checkbox" 
                                                            checked={isSnapToWall} 
                                                            onChange={() => setSnapToWall(!isSnapToWall)}
                                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                        />
                                                        <label htmlFor="window-snap-toggle" className="ml-2 block text-sm font-medium text-gray-700">壁の上に描画する</label>
                                                    </div>
                                                    {!isSnapToWall && (
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">窓の厚み: {wallObjectThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range" min="1" max="30" step="1"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value))}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={wallObjectThickness}
                                                                    onChange={(e) => setWallObjectThickness(parseInt(e.target.value) || 1)}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>}
                                                {drawingMode === 'fixture' && <div className="mt-4 space-y-4">
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700">カテゴリ</label>
                                                        <div className="mt-2 grid grid-cols-4 gap-2">
                                                            {FIXTURE_CATEGORIES.map(cat => (
                                                                <button
                                                                    key={cat.key}
                                                                    onClick={() => setFixtureCategory(cat.key)}
                                                                    className={`px-2 py-2 rounded text-[11px] text-center ${fixtureCategory === cat.key ? 'bg-indigo-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}
                                                                >
                                                                    {cat.name}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    <FixtureTemplateSelector
                                                        selectedTemplateId={fixtureTemplateId}
                                                        onChange={setFixtureTemplateId}
                                                        category={fixtureCategory}
                                                        mode="create"
                                                        isFlipped={fixtureFlip}
                                                        onFlipChange={setFixtureFlip}
                                                    />
                                                    {/* サイズ調整 */}
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700">サイズ: {fixtureSize}px</label>
                                                        <div className="flex items-center space-x-2 mt-1">
                                                            <input
                                                                type="range"
                                                                min="5"
                                                                max="300"
                                                                step="1"
                                                                value={fixtureSize}
                                                                onChange={(e) => setFixtureSize(parseInt(e.target.value))}
                                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                            />
                                                            <input
                                                                type="number"
                                                                value={fixtureSize}
                                                                onChange={(e) => setFixtureSize(parseInt(e.target.value) || 5)}
                                                                className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                            />
                                                        </div>
                                                    </div>

                                                    {/* 回転調整 */}
                                                    <div>
                                                        <label className="block text-sm font-medium text-gray-700">回転: {fixtureRotation}°</label>
                                                        <div className="flex items-center space-x-2 mt-1">
                                                            <input
                                                                type="range"
                                                                min="-180"
                                                                max="180"
                                                                step="1"
                                                                value={fixtureRotation}
                                                                onChange={(e) => setFixtureRotation(parseInt(e.target.value))}
                                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                            />
                                                            <input
                                                                type="number"
                                                                value={fixtureRotation}
                                                                onChange={(e) => setFixtureRotation(parseInt(e.target.value) || 0)}
                                                                className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                            />
                                                            <button
                                                                onClick={() => setFixtureRotation(prev => {
                                                                let newAngle = prev + 90;
                                                                if (newAngle > 180) {
                                                                    newAngle -= 360;
                                                                }
                                                                return newAngle;
                                                            })}
                                                                className="p-1 bg-gray-200 rounded hover:bg-gray-300 flex-shrink-0" // 少しスタイルを調整
                                                                title="90度回転"
                                                            >
                                                                <img 
                                                                    src="https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/90.jpg" 
                                                                    alt="90度回転" 
                                                                    className="h-9 w-9" // アイコンサイズを少し調整
                                                                />
                                                            </button>
                                                        </div>
                                                    </div>
                                                    {/* プレビューボックス */}
                                                    <div className="w-full h-32 rounded-md flex items-center justify-center overflow-hidden relative">
                                                        {(() => {
                                                            const template = FIXTURE_TEMPLATES[fixtureCategory]?.find(t => t.id === fixtureTemplateId);
                                                            if (!template) return <div className="text-sm text-gray-500">設備を選択</div>;

                                                            // 1. 実際の描画サイズを計算 (既存のロジック)
                                                            const baseSize = BASE_FIXTURE_DEFAULT_SIZE;
                                                            const templateDefaultSize = template.defaultSize || baseSize;
                                                            const scaleRatio = baseSize / templateDefaultSize;
                                                            const actualWidth = fixtureSize * scaleRatio;
                                                            const aspectRatio = template.aspectRatio || 1;
                                                            const actualHeight = actualWidth / aspectRatio;

                                                            // 2. プレビューボックスに収まるように表示用の拡大率を計算
                                                            const boxSize = 128; // h-32 = 8rem = 128px
                                                            const paddingRatio = 0.8; // ボックスの80%の大きさで表示
                                                            const itemMaxDim = Math.max(actualWidth, actualHeight);
                                                            
                                                            // 0除算を避ける
                                                            if (itemMaxDim === 0) return null;

                                                            const displayScale = (boxSize * paddingRatio) / itemMaxDim;
                                                            const displayWidth = actualWidth * displayScale;
                                                            const displayHeight = actualHeight * displayScale;

                                                            // 3. 背景グリッドのサイズも表示スケールに合わせて調整
                                                            const backgroundGridSize = gridSize * displayScale;
                                                            const gridStyle = {
                                                                backgroundImage: `linear-gradient(to right, #e5e7eb 1px, transparent 1px), linear-gradient(to bottom, #e5e7eb 1px, transparent 1px)`,
                                                                backgroundSize: `${backgroundGridSize}px ${backgroundGridSize}px`
                                                            };
                                                            
                                                            // プレビューボックスの親divにスタイルを適用
                                                            const parentDiv = document.querySelector('.w-full.h-32.rounded-md');
                                                            if (parentDiv) {
                                                                Object.assign(parentDiv.style, gridStyle);
                                                            }
                                                            
                                                            if (template.src) {
                                                                return (
                                                                    <div style={{ 
                                                                        transform: `rotate(${fixtureRotation}deg)`, 
                                                                        width: displayWidth, 
                                                                        height: displayHeight,
                                                                        display: 'flex',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center'
                                                                    }}>
                                                                        <img src={template.src} style={{ width: '100%', height: '100%' }} />
                                                                    </div>
                                                                );
                                                            } else {
                                                                const viewBoxSize = Math.max(template.defaultSize, template.defaultSize / (template.aspectRatio || 1)) * 1.1;
                                                                return (
                                                                    <svg
                                                                        width={displayWidth}
                                                                        height={displayHeight}
                                                                        viewBox={`${-viewBoxSize/2} ${-viewBoxSize/2} ${viewBoxSize} ${viewBoxSize}`}
                                                                        style={{ transform: `rotate(${fixtureRotation}deg)`, overflow: 'visible' }}
                                                                    >
                                                                        <g transform={`scale(${displayWidth / template.defaultSize}, ${displayHeight / template.defaultSize})`}>
                                                                            <path
                                                                                d={template.path}
                                                                                fill={template.defaultFill}
                                                                                stroke={template.defaultStroke}
                                                                                strokeWidth={template.defaultStrokeWidth}
                                                                                vectorEffect="non-scaling-stroke"
                                                                            />
                                                                        </g>
                                                                    </svg>
                                                                );
                                                            }
                                                        })()}
                                                    </div>
                                                    {/* プレビューボックス ここまで*/}
                                                </div>}
                                                {drawingMode === 'compass' && <div className="mt-4 space-y-4">
                                                    <CompassTemplateSelector selectedTemplateId={compassTemplateId} onChange={setCompassTemplateId} />
                                                </div>}
                                                {drawingMode === 'text' && <div className="mt-4 space-y-4">
                                                    <p className="text-sm text-gray-600">キャンバスをクリックしてテキストを配置します。</p>
                                                </div>}
                                            </>
                                        )}
                                        
                                        {editorMode === 'edit' && (
                                            <div className="mt-4 space-y-4">
                                                {!selectedElement && <p className="text-sm text-gray-600">編集したいアイテムをクリックしてください。</p>}
                                                
                                                {/* ▼▼▼ 空間（Space）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'space' && (() => {
                                                    const firstWallInGroup = svgElements.find(el => el.groupId === selectedElement.id && el.type === 'wall');
                                                    const currentLineStyle = firstWallInGroup?.lineStyle || 'solid';
                                                    const currentStrokeWidth = firstWallInGroup?.strokeWidth || DEFAULT_STROKE_WIDTH;
                                                    const currentStroke = firstWallInGroup?.stroke || firstWallInGroup?.color || DEFAULT_STROKE_COLOR;

                                                    return (
                                                        <>
                                                            {/* 空間タイプの選択 */}
                                                            <SpaceTypeSelector selectedType={selectedElement.spaceType} onChange={(newType) => handleSelectedGroupUpdate({ spaceType: newType })} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />
                                                            
                                                            {/* 背景パターンの選択 */}
                                                            <BackgroundSelector selected={selectedElement.backgroundPattern || 'none'} onChange={(pattern) => handleSelectedElementUpdate({ backgroundPattern: pattern })} />
                        
                                                            {/* 塗りつぶしの色 */}
                                                            <div>
                                                                <div className="flex items-center justify-between">
                                                                    <label htmlFor="edit-fill-color-picker" className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                    <div className="flex items-center">
                                                                        <input id="edit-transparent-toggle" type="checkbox" checked={selectedElement.fill === 'none'} onChange={(e) => {
                                                                            if (e.target.checked) {
                                                                                setEditLastFillColor(selectedElement.fill);
                                                                                handleSelectedElementUpdate({ fill: 'none' });
                                                                            } else {
                                                                                handleSelectedElementUpdate({ fill: editLastFillColor });
                                                                            }
                                                                        }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                                                        <label htmlFor="edit-transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                    </div>
                                                                </div>
                                                                <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${selectedElement.fill === 'none' ? 'transparent-bg' : ''}`}>
                                                                    <input type="color" value={selectedElement.fill === 'none' ? '#ffffff' : selectedElement.fill} onChange={(e) => handleSelectedElementUpdate({ fill: e.target.value })} onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)} className={`h-full w-full ${selectedElement.fill === 'none' ? 'opacity-0' : ''}`} disabled={selectedElement.fill === 'none'}/>
                                                                </div>
                                                            </div>
                        
                                                            {/* --- ここから壁のプロパティ編集UI --- */}
                                                            <div className="mt-4 pt-4 border-t border-gray-300 space-y-4">
                                                                <h3 className="text-md font-semibold mb-2">壁のプロパティ</h3>
                                                                
                                                                {/* 壁の線の種類 */}
                                                                <LineStyleSelector
                                                                    selectedStyle={currentLineStyle}
                                                                    onChange={(value) => handleSelectedGroupUpdate({ lineStyle: value })}
                                                                />
                                                                
                                                                {/* 壁の線の太さ */}
                                                                <div>
                                                                    <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                                    <div className="flex items-center space-x-2 mt-1">
                                                                        <input
                                                                            type="range" min="1" max="20" step="1"
                                                                            value={currentStrokeWidth}
                                                                            onChange={(e) => handleSelectedGroupUpdate({ strokeWidth: parseInt(e.target.value) })}
                                                                            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                        />
                                                                        <input
                                                                            type="number"
                                                                            value={currentStrokeWidth}
                                                                            onChange={(e) => handleSelectedGroupUpdate({ strokeWidth: parseInt(e.target.value) || 1 })}
                                                                            className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                        />
                                                                    </div>
                                                                </div>
                                                                
                                                                {/* 壁の線の色 */}
                                                                <div>
                                                                    <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                    <input
                                                                        type="color"
                                                                        value={currentStroke}
                                                                        onChange={(e) => handleSelectedGroupUpdate({ stroke: e.target.value, color: e.target.value })}
                                                                        onFocus={() => setIsPickingColor(true)} onBlur={() => setIsPickingColor(false)}
                                                                        className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                                    />
                                                                </div>
                                                            </div>
                                                            {/* --- ここまで壁のプロパティ編集UI --- */}
                        
                                                            <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この空間を削除</button></div>
                                                        </>
                                                    );
                                                })()}
                                                
                                                {/* ▼▼▼ 壁が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'wall' && (() => {
                                                    const parentSpace = selectedElement.groupId 
                                                        ? svgElements.find(el => el.id === selectedElement.groupId) 
                                                        : null;
                                                
                                                    const isGroupedWall = !!parentSpace;
                                                    const styleSource = isGroupedWall ? parentSpace : selectedElement;
                                                    const updateFunction = isGroupedWall ? handleSelectedGroupUpdate : handleSelectedElementUpdate;
                                                    
                                                    const title = isGroupedWall ? "空間の壁を編集" : "壁を編集";
                                                    const subTitle = isGroupedWall ? "（同じ空間の壁に適用されます）" : "";
                                                    
                                                    const currentLineStyle = styleSource.lineStyle || 'solid';
                                                    const currentStrokeWidth = styleSource.strokeWidth || DEFAULT_STROKE_WIDTH;
                                                    const currentStroke = styleSource.stroke || styleSource.color || DEFAULT_STROKE_COLOR;
                                                
                                                    return (
                                                        <div className="mt-4 space-y-4">
                                                            <h3 className="text-md font-semibold mb-2">{title}</h3>
                                                            {subTitle && <p className="text-xs text-gray-500 -mt-2">{subTitle}</p>}
                                                            
                                                            <LineStyleSelector
                                                                selectedStyle={currentLineStyle}
                                                                onChange={(value) => updateFunction({ lineStyle: value })}
                                                            />
                                                            
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の太さ: {currentStrokeWidth}px</label>
                                                                <div className="flex items-center space-x-2 mt-1">
                                                                    <input
                                                                        type="range" min="1" max="20" step="1"
                                                                        value={currentStrokeWidth}
                                                                        onChange={(e) => updateFunction({ strokeWidth: parseInt(e.target.value) })}
                                                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                    />
                                                                    <input
                                                                        type="number"
                                                                        value={currentStrokeWidth}
                                                                        onChange={(e) => updateFunction({ strokeWidth: parseInt(e.target.value) || 1 })}
                                                                        className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                    />
                                                                </div>
                                                            </div>
                                                            
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input
                                                                    type="color"
                                                                    value={currentStroke}
                                                                    onChange={(e) => {
                                                                        const newColor = e.target.value;
                                                                        updateFunction({ stroke: newColor, color: newColor });
                                                                    }}
                                                                    onFocus={() => setIsPickingColor(true)}
                                                                    onBlur={() => setIsPickingColor(false)}
                                                                    className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                                />
                                                            </div>
                                                            
                                                            {/* ▼▼▼ この部分が修正の核となります ▼▼▼ */}
                                                            <div className="mt-6 space-y-2">
                                                                {isGroupedWall && (
                                                                    <button 
                                                                        onClick={handleUngroupWall} 
                                                                        className="w-full px-4 py-2 rounded bg-orange-500 text-white hover:bg-orange-600"
                                                                    >
                                                                        グループ解除
                                                                    </button>
                                                                )}
                                                                <button 
                                                                    onClick={() => deleteSelectedElement(selectedId)} 
                                                                    className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700"
                                                                >
                                                                    この壁を削除
                                                                </button>
                                                            </div>
                                                            {/* ▲▲▲ 修正箇所ここまで ▲▲▲ */}
                                                        </div>
                                                    );
                                                })()}
                        
                                                {/* ▼▼▼ 階段（Stairs）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'stairs' && (
                                                    <>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">階段幅: {selectedElement.width}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="100" step="1" value={selectedElement.width} onChange={(e) => handleSelectedElementUpdate({width: parseInt(e.target.value)})} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.width} onChange={(e) => handleSelectedElementUpdate({width: parseInt(e.target.value) || 20})} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">方向</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1 mt-1">
                                                                <button onClick={() => handleStairDirectionChange('up')} className="w-full py-1 rounded-md text-sm">UP</button>
                                                                <button onClick={() => handleStairDirectionChange('down')} className="w-full py-1 rounded-md text-sm">DN</button>
                                                                <button onClick={() => handleStairDirectionChange('none')} className="w-full py-1 rounded-md text-sm">非表示</button>
                                                            </div>
                                                        </div>
                                                        <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この階段を削除</button></div>
                                                    </>
                                                )}
                                                
                                                {/* ▼▼▼ ドア（Door）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'door' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中のドアを編集</h3>
                                                        
                                                        <DoorTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                        />
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">ドアの厚み: {selectedElement.wallThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range" min="1" max="30" step="1"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) || 1 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input
                                                                type="color"
                                                                value={selectedElement.color}
                                                                onChange={(e) => handleSelectedElementUpdate({ color: e.target.value })}
                                                                onFocus={() => setIsPickingColor(true)}
                                                                onBlur={() => setIsPickingColor(false)}
                                                                className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                            />
                                                        </div>
                        
                                                        <div className="flex space-x-2">
                                                            <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button>
                                                            <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button>
                                                        </div>
                        
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このドアを削除</button>
                                                        </div>
                                                    </div>
                                                )}
                        
                                                {/* ▼▼▼ 窓（Window）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'window' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中の窓を編集</h3>
                                                        
                                                        <WindowTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                        />
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">窓の厚み: {selectedElement.wallThickness}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="1"
                                                                    max="30"
                                                                    step="1"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.wallThickness}
                                                                    onChange={(e) => handleSelectedElementUpdate({ wallThickness: parseInt(e.target.value) || 1 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input
                                                                type="color"
                                                                value={selectedElement.color}
                                                                onChange={(e) => handleSelectedElementUpdate({ color: e.target.value })}
                                                                onFocus={() => setIsPickingColor(true)}
                                                                onBlur={() => setIsPickingColor(false)}
                                                                className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                            />
                                                        </div>
                        
                                                        <div className="flex space-x-2">
                                                            <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button>
                                                            <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button>
                                                        </div>
                        
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この窓を削除</button>
                                                        </div>
                                                    </div>
                                                )}
                                                
                                                {/* ▼▼▼ 設備（Fixture）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'fixture' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中の設備を編集</h3>
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">カテゴリ</label>
                                                            <div className="mt-2 grid grid-cols-4 gap-2">
                                                                {FIXTURE_CATEGORIES.map(cat => (
                                                                    <button
                                                                        key={cat.key}
                                                                        onClick={() => setFixtureCategory(cat.key)}
                                                                        className={`px-2 py-2 rounded text-[11px] text-center ${fixtureCategory === cat.key ? 'bg-indigo-600 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}
                                                                    >
                                                                        {cat.name}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        </div>
                        
                                                        <FixtureTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                            category={fixtureCategory}
                                                            mode="edit"
                                                            isFlipped={selectedElement.isFlipped || false}
                                                            onFlipChange={(isChecked) => handleSelectedElementUpdate({ isFlipped: isChecked })}
                                                        />
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">サイズ (幅): {Math.round(selectedElement.width)}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="10"
                                                                    max="300"
                                                                    step="1"
                                                                    value={selectedElement.width}
                                                                    onChange={(e) => {
                                                                        const newWidth = parseInt(e.target.value);
                                                                        const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === selectedElement.templateId))] || {};
                                                                        const template = templateCategory.find(t => t.id === selectedElement.templateId);
                                                                        const aspectRatio = template?.aspectRatio || 1;
                                                                        const newHeight = newWidth / aspectRatio;
                                                                        handleSelectedElementUpdate({ width: newWidth, height: newHeight });
                                                                    }}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.width)}
                                                                    onChange={(e) => {
                                                                        const newWidth = parseInt(e.target.value) || 10;
                                                                        const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === selectedElement.templateId))] || {};
                                                                        const template = templateCategory.find(t => t.id === selectedElement.templateId);
                                                                        const aspectRatio = template?.aspectRatio || 1;
                                                                        const newHeight = newWidth / aspectRatio;
                                                                        handleSelectedElementUpdate({ width: newWidth, height: newHeight });
                                                                    }}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">回転: {selectedElement.rotation || 0}°</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-180"
                                                                    max="180"
                                                                    step="1"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.rotation || 0)}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                                <button
                                                                    onClick={rotateSelectedElement90Degrees}
                                                                    className="p-1 bg-gray-200 rounded hover:bg-gray-300 flex-shrink-0"
                                                                    title="90度回転"
                                                                >
                                                                    <img
                                                                        src="https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/90.jpg"
                                                                        alt="90度回転"
                                                                        className="h-9 w-9"
                                                                    />
                                                                </button>
                                                            </div>
                                                        </div>
                        
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この設備を削除</button>
                                                        </div>
                                                    </div>
                                                )}
                                                
                                                {/* ▼▼▼ 方角（Compass）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'compass' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中の方角を編集</h3>
                                                        
                                                        <CompassTemplateSelector
                                                            selectedTemplateId={selectedElement.templateId}
                                                            onChange={(newTemplateId) => handleSelectedElementUpdate({ templateId: newTemplateId })}
                                                        />
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">サイズ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="20"
                                                                    max="300"
                                                                    step="1"
                                                                    value={selectedElement.size}
                                                                    onChange={(e) => handleSelectedElementUpdate({ size: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.size}
                                                                    onChange={(e) => handleSelectedElementUpdate({ size: parseInt(e.target.value) || 20 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">回転</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-180"
                                                                    max="180"
                                                                    step="1"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.rotation || 0)}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この方角を削除</button>
                                                        </div>
                                                    </div>
                                                )}
                                                
                                                {/* ▼▼▼ テキスト（Text）が選択された時の編集パネル ▼▼▼ */}
                                                {selectedElement?.type === 'text' && (
                                                    <div className="space-y-4">
                                                        <h3 className="text-md font-semibold mb-2">選択中のテキストを編集</h3>
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">テキスト</label>
                                                            <textarea
                                                                ref={textEditAreaRef}
                                                                value={selectedElement.text}
                                                                onChange={(e) => handleSelectedElementUpdate({ text: e.target.value })}
                                                                className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm"
                                                                rows="3"
                                                            ></textarea>
                                                        </div>
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">フォント</label>
                                                            <select
                                                                value={selectedElement.fontFamily}
                                                                onChange={(e) => handleSelectedElementUpdate({ fontFamily: e.target.value })}
                                                                className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"
                                                            >
                                                                {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)}
                                                            </select>
                                                        </div>
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">フォントサイズ: {selectedElement.fontSize}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="8"
                                                                    max="72"
                                                                    step="1"
                                                                    value={selectedElement.fontSize}
                                                                    onChange={(e) => handleSelectedElementUpdate({ fontSize: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.fontSize}
                                                                    onChange={(e) => handleSelectedElementUpdate({ fontSize: parseInt(e.target.value) || 8 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>

                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">
                                                                字間: {selectedElement.letterSpacing || 0}px
                                                            </label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-5"    // 字間を詰める
                                                                    max="20"    // 字間を広げる
                                                                    step="1"
                                                                    value={selectedElement.letterSpacing || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ letterSpacing: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={selectedElement.letterSpacing || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ letterSpacing: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">文字の方向</label>
                                                            <fieldset className="mt-2 flex space-x-4">
                                                                <div className="flex items-center">
                                                                    <input
                                                                        id="orientation-h"
                                                                        name="text-orientation"
                                                                        type="radio"
                                                                        value="horizontal"
                                                                        checked={selectedElement.writingMode === 'horizontal' || !selectedElement.writingMode}
                                                                        onChange={(e) => handleSelectedElementUpdate({ writingMode: e.target.value })}
                                                                        className="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500"
                                                                    />
                                                                    <label htmlFor="orientation-h" className="ml-3 block text-sm font-medium text-gray-700">
                                                                        横書き
                                                                    </label>
                                                                </div>
                                                                <div className="flex items-center">
                                                                    <input
                                                                        id="orientation-v"
                                                                        name="text-orientation"
                                                                        type="radio"
                                                                        value="vertical"
                                                                        checked={selectedElement.writingMode === 'vertical'}
                                                                        onChange={(e) => handleSelectedElementUpdate({ writingMode: e.target.value })}
                                                                        className="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500"
                                                                    />
                                                                    <label htmlFor="orientation-v" className="ml-3 block text-sm font-medium text-gray-700">
                                                                        縦書き
                                                                    </label>
                                                                </div>
                                                            </fieldset>
                                                        </div>
                                                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">回転</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input
                                                                    type="range"
                                                                    min="-180"
                                                                    max="180"
                                                                    step="1"
                                                                    value={selectedElement.rotation || 0}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) })}
                                                                    className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                                                />
                                                                <input
                                                                    type="number"
                                                                    value={Math.round(selectedElement.rotation || 0)}
                                                                    onChange={(e) => handleSelectedElementUpdate({ rotation: parseInt(e.target.value) || 0 })}
                                                                    className="w-20 p-1 border border-gray-300 rounded-md text-sm"
                                                                />
                                                            </div>
                                                        </div>
                        
                                                        <div className="grid grid-cols-1 gap-y-4">
                                                            <div>
                                                                <div className="flex items-center justify-between">
                                                                    <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label>
                                                                    <div className="flex items-center">
                                                                        <input
                                                                            id="text-bg-transparent-toggle"
                                                                            type="checkbox"
                                                                            checked={selectedElement.backgroundColor === 'none' || !selectedElement.backgroundColor}
                                                                            onChange={(e) => {
                                                                                const newBgColor = e.target.checked ? 'none' : '#ffffff';
                                                                                handleSelectedElementUpdate({ backgroundColor: newBgColor });
                                                                            }}
                                                                            className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                                        />
                                                                        <label htmlFor="text-bg-transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                    </div>
                                                                </div>
                                                                <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${(!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none') ? 'transparent-bg' : ''}`}>
                                                                    <input
                                                                        type="color"
                                                                        value={!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none' ? '#ffffff' : selectedElement.backgroundColor}
                                                                        onChange={(e) => handleSelectedElementUpdate({ backgroundColor: e.target.value })}
                                                                        onFocus={() => setIsPickingColor(true)}
                                                                        onBlur={() => setIsPickingColor(false)}
                                                                        className={`h-full w-full rounded-md ${(!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none') ? 'opacity-0' : ''}`}
                                                                        disabled={!selectedElement.backgroundColor || selectedElement.backgroundColor === 'none'}
                                                                    />
                                                                </div>
                                                            </div>
                                                            <div>
                                                                <label className="block text-sm font-medium text-gray-700">文字色</label>
                                                                <input
                                                                    type="color"
                                                                    value={selectedElement.color}
                                                                    onChange={(e) => handleSelectedElementUpdate({ color: e.target.value })}
                                                                    onFocus={() => setIsPickingColor(true)}
                                                                    onBlur={() => setIsPickingColor(false)}
                                                                    className="mt-1 h-10 w-full border border-gray-300 rounded-md"
                                                                />
                                                            </div>
                                                        </div>
                        
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">配置</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1">
                                                                <button onClick={() => handleSelectedElementUpdate({ textAlign: 'left' })} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button>
                                                                <button onClick={() => handleSelectedElementUpdate({ textAlign: 'center' })} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button>
                                                                <button onClick={() => handleSelectedElementUpdate({ textAlign: 'right' })} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button>
                                                            </div>
                                                        </div>
                        
                                                        <div className="mt-2">
                                                            <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このテキストを削除</button>
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </aside>
                        <div className="fixed bottom-4 right-4 z-40 bg-white bg-opacity-75 backdrop-blur-sm p-2 rounded-lg shadow-lg flex items-center space-x-2">
                            <span className="text-xs font-bold text-gray-600 mr-2">プレビュー</span>
                            {/* 作図ボタン (Aキー) */}
                            <div className="relative">
                                <button
                                    onMouseDown={() => setPreviewMode('drawing')}
                                    onMouseUp={() => setPreviewMode(null)}
                                    onMouseLeave={() => setPreviewMode(null)}
                                    className={`pl-3 pr-8 py-2 text-white text-xs font-semibold rounded-md transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-400 text-left ${
                                        previewMode === 'drawing' ? 'bg-indigo-700' : 'bg-indigo-500 hover:bg-indigo-600'
                                    }`}
                                    title="作図をプレビュー (Aキー長押し)"
                                >
                                    作図
                                </button>
                                <kbd className="absolute top-1/2 -translate-y-1/2 right-2 px-1.5 py-0.5 bg-gray-200 text-gray-800 text-[10px] font-sans font-bold rounded-sm pointer-events-none">A</kbd>
                            </div>
                            {/* 下絵ボタン (Sキー) */}
                            <div className="relative">
                                <button
                                    onMouseDown={() => setPreviewMode('image')}
                                    onMouseUp={() => setPreviewMode(null)}
                                    onMouseLeave={() => setPreviewMode(null)}
                                    className={`pl-3 pr-8 py-2 text-white text-xs font-semibold rounded-md transition-colors duration-150 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 text-left ${
                                        previewMode === 'image' ? 'bg-gray-700' : 'bg-gray-500 hover:bg-gray-600'
                                    }`}
                                    title="下絵をプレビュー (Sキー長押し)"
                                >
                                    下絵
                                </button>
                                <kbd className="absolute top-1/2 -translate-y-1/2 right-2 px-1.5 py-0.5 bg-gray-200 text-gray-800 text-[10px] font-sans font-bold rounded-sm pointer-events-none">S</kbd>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<Editor />, document.getElementById('root'));
    </script>
</body>
</html>
