<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto間取り図</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            overflow: hidden;
        }
        .editor-area {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        .scroll-wrapper {
            width: 5000px;
            height: 5000px;
            position: relative;
        }
        .editor-container {
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            transform-origin: center center;
        }
        .editor-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            max-width: 100%;
            max-height: 100%;
            pointer-events: none;
        }
        .editor-canvas, .editor-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .editor-svg {
            pointer-events: all;
        }
        .editor-svg > * {
            pointer-events: all;
        }
        .cursor-crosshair { cursor: crosshair; }
        .cursor-pointer { cursor: pointer; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-default { cursor: default; }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.4L159.2%2C69.7c-3.1-3.1-8.2-3.1-11.3%2C0L5.4%2C197.4c-3.1%2C3.1-3.1%2C8.2%2C0%2C11.3l11.3%2C11.3c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l115.4-115.4l115.4%2C115.4c3.1%2C3.1%2C8.2%2C3.1%2C11.3%2C0l11.3-11.3C290.1%2C205.6%2C290.1%2C200.5%2C287%2C197.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem 0.8rem;
            padding-right: 2.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
        }
        select:focus {
            border-color: #6366F1;
            box-shadow: 0 0 0 1px #6366F1;
            outline: none;
        }
        .transparent-bg {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 10px 10px;
            background-position: 0 0, 0 5px, 5px -5px, -5px 0px;
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- 定数とダミーデータ ---
        const DUMMY_OCR_DATA = {
            "Blocks": [
                { "id": "block-1", "type": "LDK", "Text": "LDK 12.5帖", "Geometry": { "BoundingBox": { "Width": 0.25, "Height": 0.05, "Left": 0.4, "Top": 0.5 }}},
                { "id": "block-2", "type": "洋室", "Text": "洋室 6.0帖", "Geometry": { "BoundingBox": { "Width": 0.2, "Height": 0.05, "Left": 0.1, "Top": 0.2 }}},
                { "id": "block-3", "type": "浴室", "Text": "浴室", "Geometry": { "BoundingBox": { "Width": 0.1, "Height": 0.04, "Left": 0.7, "Top": 0.2 }}},
                { "id": "block-4", "type": "収納", "Text": "WIC", "Geometry": { "BoundingBox": { "Width": 0.08, "Height": 0.04, "Left": 0.15, "Top": 0.4 }}}
            ]
        };
        const SPACE_TYPES = {
            main: ["LDK", "DK", "K", "居室", "和室", "収納", "洗面所", "浴室", "トイレ", "廊下", "玄関", "バルコニー"],
            sub: ["柱", "吹抜", "グルニエ", "折上天井", "床下収納", "カウンター", "棚", "下足入", "冷蔵庫", "洗濯機", "PS", "MB"]
        };
        const FONT_FAMILIES = [
            { id: 'sans-serif', name: 'ゴシック体' },
            { id: 'serif', name: '明朝体' },
            { id: 'monospace', name: '等幅フォント' },
            { id: 'cursive', name: '筆記体' }
        ];
        const SNAP_THRESHOLD = 10;
        const DEFAULT_WIDTH = 1200;
        const DEFAULT_HEIGHT = 900;
        const SELECTED_ELEMENT_COLOR = '#3b82f6';
        const DEFAULT_STROKE_COLOR = '#000000';
        const DEFAULT_STROKE_WIDTH = 3;
        const DEFAULT_STAIR_WIDTH = 50;

        const LINE_STYLES = [
            { id: 'solid', name: '実線', dashArray: 'none' },
            { id: 'dashed', name: '破線', dashArray: '10, 5' },
            { id: 'dotted', name: '点線', dashArray: '2, 5' },
            { id: 'chain', name: '一点鎖線', dashArray: '10, 4, 2, 4' },
            { id: 'double-chain', name: '二点鎖線', dashArray: '10, 4, 2, 4, 2, 4' },
            { id: 'wavy', name: '波線', dashArray: null }
        ];
        
        const BACKGROUND_PATTERNS = [
            { id: 'none', name: 'なし' },
            { id: 'vertical-lines', name: '縦線' },
            { id: 'horizontal-lines', name: '横線' },
            { id: 'grid-small', name: '格子小' },
            { id: 'grid-large', name: '格子大' },
            { id: 'dotted-x', name: '点線バツ印' },
            { id: 'solid-x', name: '実線バツ印' },
            { id: 'dotted-triangle', name: '点線三角' },
            { id: 'solid-triangle', name: '実線三角' }
        ];

        const DEFAULT_FILL_COLORS = {
            "LDK": "#fef3c7", "DK": "#fef3c7", "K": "#fef3c7",
            "居室": "#f5e5d4",
            "和室": "#dcfce7",
            "収納": "#fef9c3",
            "洗面所": "#dbeafe",
            "浴室": "#dbeafe",
            "トイレ": "#dbeafe",
            "廊下": "rgb(245, 229, 212)",
            "玄関": "#dedede",
            "バルコニー": "#f5f5f5",
            "柱": "#000000",
            "吹抜": "none",
            "グルニエ": "none",
            "折上天井": "none",
            "床下収納": "none",
            "カウンター": "#CD924C",
            "棚": "#CD924C",
            "下足入": "#CD924C",
            "冷蔵庫": "none",
            "洗濯機": "none",
            "PS": "#ffffff",
            "MB": "#ffffff",
            "その他": "#fafafa"
        };
        
        const SUB_TYPE_PROPERTIES = {
            "吹抜": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "グルニエ": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "折上天井": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "冷蔵庫": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "洗濯機": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "床下収納": { lineStyle: 'dotted', strokeWidth: DEFAULT_STROKE_WIDTH, fill: 'none' },
            "カウンター": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "棚": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "下足入": { lineStyle: 'solid', strokeWidth: 1, fill: '#CD924C' },
            "PS": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#ffffff' },
            "MB": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#ffffff' },
            "柱": { lineStyle: 'solid', strokeWidth: DEFAULT_STROKE_WIDTH, fill: '#000000' }
        };

        const COMPASS_TEMPLATES = [
            { id: 'dsynbol01', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol01.svg'},
            { id: 'dsynbol02', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol02.svg'},
            { id: 'dsynbol03', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol03.svg'},
            { id: 'dsynbol04', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol04.svg'},
            { id: 'dsynbol05', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol05.svg'},
            { id: 'dsynbol06', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol06.svg'},
            { id: 'dsynbol07', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol07.svg'},
            { id: 'dsynbol08', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol08.svg'},
            { id: 'dsynbol09', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol09.svg'},
            { id: 'dsynbol10', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol10.svg'},
            { id: 'dsynbol11', src:'https://automadorizu-upload-891377349958.s3.ap-northeast-1.amazonaws.com/img/dsymbol11.svg'}
        ];

        const FIXTURE_TEMPLATES = {
            kitchen: [
                { id: 'kitchen-sink', name: 'シンク', path: 'M-20,-10 H20 V10 H-20 Z M-10,-10 V10 M0,-10 V10', defaultSize: 40, defaultFill: '#cccccc', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'refrigerator', name: '冷蔵庫', path: 'M-10,-20 H10 V20 H-10 Z M-10,0 H10', defaultSize: 40, defaultFill: '#e0e0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'gas-range', name: 'ガスコンロ', path: 'M-15,-15 H15 V15 H-15 Z M-10,-10 L10,10 M-10,10 L10,-10', defaultSize: 35, defaultFill: '#f0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'microwave', name: '電子レンジ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-5 H10 M-10,0 H10', defaultSize: 30, defaultFill: '#f5f5f5', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dishwasher', name: '食洗機', path: 'M-15,-10 H15 V10 H-15 Z M-10,0 V10 M0,0 V10 M10,0 V10', defaultSize: 30, defaultFill: '#e0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'pantry', name: '食器棚', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20 M-10,-10 H10 M-10,0 H10 M-10,10 H10', defaultSize: 45, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bathroom: [
                { id: 'bathtub', name: '浴槽', path: 'M-20,-10 H20 V10 H-20 Z M-15,-5 H15 V5 H-15 Z', defaultSize: 40, defaultFill: '#e0f0ff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'washbasin', name: '洗面台', path: 'M-10,-10 H10 V10 H-10 Z M-5,0 A5,5 0 1,0 5,0', defaultSize: 30, defaultFill: '#ffffff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'washing-machine', name: '洗濯機', path: 'M-15,-15 H15 V15 H-15 Z M0,-15 V15 M-10,-5 H10', defaultSize: 35, defaultFill: '#f0f0f0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'shower', name: 'シャワー', path: 'M-15,-15 H15 V15 H-15 Z M-10,-10 L10,10 M-10,10 L10,-10', defaultSize: 30, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bidet', name: 'ビデ', path: 'M-10,-10 H10 V10 H-10 Z M-10,-5 A5,5 0 0,1 -5,-10 H5 A5,5 0 0,1 10,-5', defaultSize: 25, defaultFill: '#ffffff', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'towel-rack', name: 'タオル掛け', path: 'M-15,-5 H15 M-10,5 H10', defaultSize: 25, defaultFill: 'none', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            bedroom: [
                { id: 'bed-single', name: 'シングルベッド', path: 'M-20,-15 H20 V15 H-20 Z M-15,-15 H15 V-5 H-15 Z', defaultSize: 50, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bed-double', name: 'ダブルベッド', path: 'M-30,-20 H30 V20 H-30 Z M-25,-20 H25 V-5 H-25 Z', defaultSize: 60, defaultFill: '#a0c0e0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'closet', name: 'クローゼット', path: 'M-15,-20 H15 V20 H-15 Z M0,-20 V20', defaultSize: 40, defaultFill: '#f5deb3', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dresser', name: 'ドレッサー', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'nightstand', name: 'ナイトスタンド', path: 'M-10,-10 H10 V10 H-10 Z', defaultSize: 20, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'wardrobe', name: 'ワードローブ', path: 'M-20,-25 H20 V25 H-20 Z M-15,-25 V25 M15,-25 V25', defaultSize: 50, defaultFill: '#deb887', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            livingDining: [
                { id: 'dining-table-round', name: '円形テーブル', path: 'M0,0 A15,15 0 1,0 0,0.001 Z', defaultSize: 40, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'dining-table-rect', name: '長方形テーブル', path: 'M-25,-15 H25 V15 H-25 Z', defaultSize: 50, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-single', name: '一人掛けソファ', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 V0 M10,-10 V0', defaultSize: 40, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'sofa-double', name: '二人掛けソファ', path: 'M-30,-10 H30 V10 H-30 Z M-25,-10 V0 M25,-10 V0', defaultSize: 60, defaultFill: '#80a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'tv-stand', name: 'テレビ台', path: 'M-20,-5 H20 V5 H-20 Z', defaultSize: 40, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'bookshelf', name: '本棚', path: 'M-15,-20 H15 V20 H-15 Z M-10,-15 H10 M-10,0 H10 M-10,15 H10', defaultSize: 45, defaultFill: '#d0b090', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ],
            other: [
                { id: 'desk', name: 'デスク', path: 'M-20,-10 H20 V10 H-20 Z M-15,0 H15', defaultSize: 45, defaultFill: '#c0a080', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'fireplace', name: '暖炉', path: 'M-15,-10 H15 V10 H-15 Z M-10,-10 L-10,0 L10,0 L10,-10', defaultSize: 30, defaultFill: '#a0a0a0', defaultStroke: '#000000', defaultStrokeWidth: 1 },
                { id: 'piano', name: 'ピアノ', path: 'M-25,-10 H25 V10 H-25 Z M-20,-10 V0 M-15,-10 V0 M-10,-10 V0 M-5,-10 V0 M0,-10 V0 M5,-10 V0 M10,-10 V0 M15,-10 V0 M20,-10 V0', defaultSize: 50, defaultFill: '#303030', defaultStroke: '#000000', defaultStrokeWidth: 1 }
            ]
        };

        const DOOR_TEMPLATES = [
            { id: 'swing-right', name: '開き戸 (右)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const sweepFlag = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 M0,0 L0,${isInner ? doorThickness : -doorThickness} M0,0 A${length},${length} 0 0,${sweepFlag} ${length},${isInner ? length : -length}`;
                },
                previewPath: 'M0,0 L40,0 M0,0 L0,10 M0,0 A40,40 0 0,1 40,40'
            },
            { id: 'swing-left', name: '開き戸 (左)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const sweepFlag = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 M${length},0 L${length},${isInner ? doorThickness : -doorThickness} M${length},0 A${length},${length} 0 0,${sweepFlag} 0,${isInner ? length : -length}`;
                },
                previewPath: 'M0,0 L40,0 M40,0 L40,10 M40,0 A40,40 0 0,0 0,40'
            },
            { id: 'sliding-single', name: '引き戸 (片)',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorOffset = (wallThickness || 10) / 2;
                    return `M0,0 L${length},0 M0,${doorOffset} L${length},${doorOffset}`;
                },
                previewPath: 'M0,0 L40,0 M0,5 L40,5'
            },
            { id: 'double-swing', name: '両開き戸',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const halfLength = length / 2;
                    const doorThickness = wallThickness || 10;
                    const sweepFlag1 = swingDirection === 'clockwise' ? 1 : 0;
                    const sweepFlag2 = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 ` +
                           `M0,0 L0,${isInner ? doorThickness : -doorThickness} ` +
                           `M${halfLength},0 L${halfLength},${isInner ? doorThickness : -doorThickness} ` +
                           `M0,0 A${halfLength},${halfLength} 0 0,${sweepFlag1} ${halfLength},${isInner ? halfLength : -halfLength} ` +
                           `M${length},0 A${halfLength},${halfLength} 0 0,${sweepFlag2} ${halfLength},${isInner ? halfLength : -halfLength}`;
                },
                previewPath: 'M20,0 L0,0 M20,0 L40,0 M0,0 A20,20 0 0,1 20,20 M40,0 A20,20 0 0,0 20,20'
            },
            { id: 'parent-child-door', name: '親子ドア',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const parentLength = length * 0.7;
                    const childLength = length * 0.3;
                    const sweepFlagParent = swingDirection === 'clockwise' ? 1 : 0;
                    const sweepFlagChild = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 ` +
                           `M0,0 L0,${isInner ? doorThickness : -doorThickness} ` +
                           `M${parentLength},0 L${parentLength},${isInner ? doorThickness : -doorThickness} ` +
                           `M0,0 A${parentLength},${parentLength} 0 0,${sweepFlagParent} ${parentLength},${isInner ? parentLength : -parentLength} ` +
                           `M${parentLength},0 A${childLength},${childLength} 0 0,${sweepFlagChild} ${length},${isInner ? childLength : -childLength}`;
                },
                previewPath: 'M0,0 L40,0 M0,0 L0,10 M28,0 L28,10 M0,0 A28,28 0 0,1 28,28 M28,0 A12,12 0 0,1 40,12'
            },
            { id: 'bifold', name: '折れ戸',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const doorThickness = wallThickness || 10;
                    const segmentLength = length / 4;
                    const offset = isInner ? doorThickness : -doorThickness;
                    return `M0,0 L${length},0 ` +
                           `M0,${offset} L${segmentLength},0 ` +
                           `M${segmentLength},0 L${segmentLength * 2},${offset} ` +
                           `M${segmentLength * 2},${offset} L${segmentLength * 3},0 ` +
                           `M${segmentLength * 3},0 L${length},${offset}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L10,0 M10,0 L20,10 M20,10 L30,0 M30,0 L40,10'
            }
        ];

        const WINDOW_TEMPLATES = [
            { id: 'sliding-window', name: '引き違い窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    const offset = windowThickness / 2;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,${offset} L${length},${offset}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,5 L40,5'
            },
            { id: 'casement-single', name: '片開き窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    const arcSweep = swingDirection === 'clockwise' ? 1 : 0;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,0 L0,${windowThickness} M${length},0 A${windowThickness},${windowThickness} 0 0,${arcSweep} ${length - windowThickness},0`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,0 L0,10 M40,0 A10,10 0 0,1 30,0'
            },
            { id: 'casement-double', name: '両開き窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const halfLength = length / 2;
                    const windowThickness = wallThickness || 10;
                    const arcSweep1 = swingDirection === 'clockwise' ? 1 : 0;
                    const arcSweep2 = swingDirection === 'clockwise' ? 0 : 1;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M${halfLength},0 L${halfLength},${windowThickness} M0,0 A${windowThickness},${windowThickness} 0 0,${arcSweep1} ${windowThickness},0 M${length},0 A${windowThickness},${windowThickness} 0 0,${arcSweep2} ${length-windowThickness},0`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M20,0 L20,10 M0,0 A10,10 0 0,1 10,0 M40,0 A10,10 0 0,0 30,0'
            },
            { id: 'fixed-window', name: 'FIX窓',
                path: (length, swingDirection, isInner, wallThickness) => {
                    const windowThickness = wallThickness || 10;
                    return `M0,0 L${length},0 M0,${windowThickness} L${length},${windowThickness} M0,0 L0,${windowThickness} M${length},0 L${length},${windowThickness} M0,0 L${length},${windowThickness} M${length},0 L0,${windowThickness}`;
                },
                previewPath: 'M0,0 L40,0 M0,10 L40,10 M0,0 L0,10 M40,0 L40,10 M0,0 L40,10 M40,0 L0,10'
            }
        ];


        // --- ヘルパー関数 ---
        const generateWavyPathD = (p1, p2) => {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 1) return `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
            const dirX = dx / len, dirY = dy / len, perpX = -dirY, perpY = dirX;
            const amplitude = 4, wavelength = 15;
            const numSegments = Math.max(1, Math.floor(len / wavelength));
            const segmentLen = len / numSegments;
            let d = `M ${p1.x} ${p1.y}`;
            for (let i = 0; i < numSegments; i++) {
                const midX = p1.x + (i + 0.5) * segmentLen * dirX;
                const midY = p1.y + (i + 0.5) * segmentLen * dirY;
                const segEndX = p1.x + (i + 1) * segmentLen * dirX;
                const segEndY = p1.y + (i + 1) * segmentLen * dirY;
                const amp = (i % 2 === 0) ? amplitude : -amplitude;
                const controlX = midX + amp * perpX;
                const controlY = midY + amp * perpY;
                d += ` Q ${controlX} ${controlY} ${segEndX} ${segEndY}`;
            }
            return d;
        };

        const getPolygonCentroid = (pts) => {
            let first = pts[0], last = pts[pts.length - 1];
            if (!first) return { x: 0, y: 0 };
            if (first.x !== last.x || first.y !== last.y) pts.push(first);
            let twicearea = 0, x = 0, y = 0, nPts = pts.length, p1, p2, f;
            for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
                p1 = pts[i]; p2 = pts[j];
                f = p1.x * p2.y - p2.x * p1.y;
                twicearea += f;
                x += (p1.x + p2.x) * f;
                y += (p1.y + p2.y) * f;
            }
            f = twicearea * 3;
            if (pts.length > 0 && pts[pts.length - 1] === first) pts.pop();
            if (Math.abs(f) < 1e-6) { // Avoid division by zero for degenerate polygons
                 return pts.reduce((acc, p) => ({ x: acc.x + p.x / pts.length, y: acc.y + p.y / pts.length }), { x: 0, y: 0 });
            }
            return { x: x / f, y: y / f };
        };

        const createSpaceLabel = (spaceType, centroid, dimensions) => {
            if (["柱", "その他"].includes(spaceType)) {
                return null;
            }
            
            const text = ["LDK", "DK", "K", "居室", "和室"].includes(spaceType)
                ? `${spaceType}\n◯.◯帖`
                : spaceType;

            const smallFontTypes = ["バルコニー", "トイレ", "浴室", "洗面所", "玄関", "収納", "廊下", ...SPACE_TYPES.sub];
            const fontSize = smallFontTypes.includes(spaceType) ? 10 : 16;

            return {
                id: `text-${Date.now()}`,
                type: 'text',
                x: (centroid.x / dimensions.width) * 100,
                y: (centroid.y / dimensions.height) * 100,
                text: text,
                color: '#000000',
                fontSize: fontSize,
                fontFamily: 'sans-serif',
                textAlign: 'center',
            };
        };

        // --- UIコンポーネント ---
        const LineStyleSelector = ({ selectedStyle, onChange, isRectShape }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">線の種類</label>
                <div className="mt-2 grid grid-cols-3 gap-1">
                    {LINE_STYLES.map(style => (
                        (isRectShape && style.id === 'wavy') ? null : (
                            <button key={style.id} onClick={() => onChange(style.id)} className={`p-2 rounded-md border-2 ${selectedStyle === style.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                                <div className="flex items-center justify-center">
                                    <svg width="40" height="20" viewBox="0 0 60 20" className="flex-shrink-0">
                                        {style.id === 'wavy' ? <path d="M 5 10 C 15 0, 25 20, 35 10 S 55 0, 55 10" stroke="black" strokeWidth="2" fill="none" /> : <line x1="5" y1="10" x2="55" y2="10" stroke="black" strokeWidth="2" strokeDasharray={style.dashArray} strokeLinecap="round" />}
                                    </svg>
                                </div>
                            </button>
                        )
                    ))}
                </div>
            </div>
        );
        
        const SpaceTypeSelector = ({ selectedType, onChange, spaceTypeTab, setSpaceTypeTab }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">空間タイプ</label>
                <div className="flex bg-gray-200 rounded-lg p-1 mt-2">
                    <button onClick={() => setSpaceTypeTab('main')} className={`w-full py-1 rounded-md text-sm ${spaceTypeTab === 'main' ? 'bg-white shadow' : ''}`}>メイン</button>
                    <button onClick={() => setSpaceTypeTab('sub')} className={`w-full py-1 rounded-md text-sm ${spaceTypeTab === 'sub' ? 'bg-white shadow' : ''}`}>サブ</button>
                </div>
                <div className="mt-2 grid grid-cols-3 gap-2">
                    {SPACE_TYPES[spaceTypeTab].map(type => {
                        const isSelected = selectedType === type;
                        const isPillar = type === '柱';
                        const isTransparent = DEFAULT_FILL_COLORS[type] === 'none';
                        const style = {
                            backgroundColor: isTransparent ? 'transparent' : DEFAULT_FILL_COLORS[type],
                            color: isPillar ? 'white' : 'black',
                            border: `1px solid ${isTransparent || DEFAULT_FILL_COLORS[type] === '#ffffff' ? '#ccc' : 'transparent'}`
                        };
                        return (
                            <button
                                key={type}
                                onClick={() => onChange(type)}
                                style={style}
                                className={`p-1 rounded-md text-xs text-center transition-all ${isSelected ? 'ring-2 ring-offset-1 ring-indigo-500' : ''} ${isTransparent ? 'transparent-bg' : ''}`}
                            >
                                {type}
                            </button>
                        );
                    })}
                </div>
            </div>
        );

        const BackgroundSelector = ({ selected, onChange }) => {
            const getPreview = (patternId) => {
                const baseRect = <rect width="40" height="20" fill="#f0f0f0" />;
                switch(patternId) {
                    case 'none': return baseRect;
                    case 'vertical-lines': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M10 0 V20 M20 0 V20 M30 0 V20" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'horizontal-lines': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 5 H40 M0 10 H40 M0 15 H40" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'grid-small': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M10 0 V20 M20 0 V20 M30 0 V20 M0 10 H40" stroke="#cccccc" strokeWidth="1" /></>;
                    case 'grid-large': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M20 0 V20" stroke="#000000" strokeWidth="1" /></>;
                    case 'solid-x': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 20 M0 20 L40 0" stroke="#000000" strokeWidth="1" /></>;
                    case 'dotted-x': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 20 M0 20 L40 0" stroke="#000000" strokeWidth="1" strokeDasharray="2 2" /></>;
                    case 'solid-triangle': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 10 L0 20 Z" stroke="#000000" strokeWidth="1" fill="none" /></>;
                    case 'dotted-triangle': return <><rect width="40" height="20" fill="#f0f0f0" /><path d="M0 0 L40 10 L0 20 Z" stroke="#000000" strokeWidth="1" fill="none" strokeDasharray="2 2" /></>;
                    default: return baseRect;
                }
            };
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700">背景</label>
                    <div className="mt-2 grid grid-cols-3 gap-2">
                        {BACKGROUND_PATTERNS.map(pattern => (
                            <button
                                key={pattern.id}
                                onClick={() => onChange(pattern.id)}
                                className={`p-2 rounded-md border-2 text-xs ${selected === pattern.id ? 'border-indigo-500 bg-indigo-50' : 'bg-white border-gray-200'} hover:bg-gray-50 flex flex-col items-center justify-center`}
                            >
                                <svg width="40" height="20" className="border border-gray-300 mb-1">
                                    {getPreview(pattern.id)}
                                </svg>
                                {pattern.name}
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const CompassTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">方角の図形</label>
                <div className="mt-2 grid grid-cols-4 gap-1">
                    {COMPASS_TEMPLATES.map(template => (
                        <button
                            key={template.id}
                            onClick={() => onChange(template.id)}
                            className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center h-12`}
                        >
                           <img
                                src={template.src}
                                alt={template.id}
                                className="w-8 h-8 object-contain"
                            />
                        </button>
                    ))}
                </div>
            </div>
        );

        const FixtureTemplateSelector = ({ selectedTemplateId, onChange, category }) => {
            const templates = FIXTURE_TEMPLATES[category] || [];
            return (
                <div>
                    <label className="block text-sm font-medium text-gray-700">設備の種類</label>
                    <div className="mt-2 grid grid-cols-4 gap-1">
                        {templates.map(template => (
                            <button key={template.id} onClick={() => onChange(template.id)} className={`p-1 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100 flex items-center justify-center`}>
                                <svg width="40" height="40" viewBox="-30 -30 60 60" className="flex-shrink-0">
                                    <path d={template.path} fill={template.defaultFill} stroke={template.defaultStroke} strokeWidth={template.defaultStrokeWidth} />
                                </svg>
                            </button>
                        ))}
                    </div>
                </div>
            );
        };

        const DoorTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">ドアの種類</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                    {DOOR_TEMPLATES.map(template => (
                        <button key={template.id} onClick={() => onChange(template.id)} className={`p-2 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center space-x-2">
                                <svg width="60" height="40" viewBox="0 0 60 40" className="flex-shrink-0">
                                    <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" />
                                </svg>
                                <span className="text-sm">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        const WindowTemplateSelector = ({ selectedTemplateId, onChange }) => (
            <div>
                <label className="block text-sm font-medium text-gray-700">窓の種類</label>
                <div className="mt-2 grid grid-cols-2 gap-2">
                    {WINDOW_TEMPLATES.map(template => (
                        <button key={template.id} onClick={() => onChange(template.id)} className={`p-2 rounded-md border-2 ${selectedTemplateId === template.id ? 'border-indigo-500 bg-indigo-50' : 'border-transparent'} hover:bg-gray-100`}>
                            <div className="flex items-center space-x-2">
                                <svg width="60" height="40" viewBox="0 0 60 40" className="flex-shrink-0">
                                    <path d={template.previewPath} fill="none" stroke="black" strokeWidth="2" />
                                </svg>
                                <span className="text-sm">{template.name}</span>
                            </div>
                        </button>
                    ))}
                </div>
            </div>
        );

        // --- メインエディタコンポーネント ---
        function Editor() {
            // --- ステート定義 ---
            const [isSidebarOpen, setSidebarOpen] = useState(true);
            const [isDisplaySettingsOpen, setDisplaySettingsOpen] = useState(true);
            const [isDrawingToolsOpen, setDrawingToolsOpen] = useState(true);
            const [imageUrl, setImageUrl] = useState('');
            const [historyState, setHistoryState] = useState({
                past: [],
                present: { ocrData: null, svgElements: [] },
                future: []
            });
            const { ocrData: currentOcrData, svgElements } = historyState.present;

            const [editorMode, setEditorMode] = useState('continuous-create'); // 'continuous-create', 'create', 'edit'
            const [drawingMode, setDrawingMode] = useState('space');
            const [spaceShape, setSpaceShape] = useState('rect');
            const [selectedGroupId, setSelectedGroupId] = useState(null);
            const [selectedEdge, setSelectedEdge] = useState(null); // { groupId, edgeIndex }
            const [dimensions, setDimensions] = useState({ width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT });
            const [drawingStartPoint, setDrawingStartPoint] = useState(null);
            const [linePoints, setLinePoints] = useState([]);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [imageOpacity, setImageOpacity] = useState(0.5);
            const [drawingOpacity, setDrawingOpacity] = useState(0.4);
            const [zoom, setZoom] = useState(0.8);
            const [imageScale, setImageScale] = useState(1);
            const [strokeColor, setStrokeColor] = useState(DEFAULT_STROKE_COLOR);
            const [strokeWidth, setStrokeWidth] = useState(DEFAULT_STROKE_WIDTH);
            const [spaceType, setSpaceType] = useState('LDK');
            const [fillColor, setFillColor] = useState(DEFAULT_FILL_COLORS[spaceType]);
            const [lineStyle, setLineStyle] = useState('solid');
            const [backgroundPattern, setBackgroundPattern] = useState('none');
            const [isGridVisible, setGridVisible] = useState(true);
            const [gridSize, setGridSize] = useState(5);
            const [fontSize, setFontSize] = useState(16);
            const [fontFamily, setFontFamily] = useState('sans-serif');
            const [textAlign, setTextAlign] = useState('center');
            const [compassTemplateId, setCompassTemplateId] = useState(COMPASS_TEMPLATES[0].id);
            const [fixtureCategory, setFixtureCategory] = useState('kitchen');
            const [fixtureTemplateId, setFixtureTemplateId] = useState(FIXTURE_TEMPLATES.kitchen[0].id);
            const [doorTemplateId, setDoorTemplateId] = useState(DOOR_TEMPLATES[0].id);
            const [windowTemplateId, setWindowTemplateId] = useState(WINDOW_TEMPLATES[0].id);
            const [stairWidth, setStairWidth] = useState(DEFAULT_STAIR_WIDTH);
            const [stairDirection, setStairDirection] = useState('up');
            const [spaceTypeTab, setSpaceTypeTab] = useState('main');
            const [lastFillColor, setLastFillColor] = useState('#ffffff');
            const [editLastFillColor, setEditLastFillColor] = useState('#ffffff');
            
            const [isDragging, setIsDragging] = useState(false);
            const [resizingHandleInfo, setResizingHandleInfo] = useState(null); // { groupId, handleIndex, isEdge? }

            // --- Ref定義 ---
            const imageRef = useRef(null);
            const canvasRef = useRef(null);
            const editorAreaRef = useRef(null);
            const svgRef = useRef(null);
            const displaySettingsRef = useRef(null);
            const dragInfo = useRef(null);
            const historyOnActionStart = useRef(null);
            const mouseDownInfo = useRef(null);

            const selectedElement = svgElements.find(el => el.id === selectedGroupId || el.groupId === selectedGroupId);

            const handleSelectedElementUpdate = useCallback((key, value) => {
                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.id === selectedGroupId || el.groupId === selectedGroupId) {
                            return { ...el, [key]: value };
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedGroupId]);

            const handleSelectedGroupUpdate = useCallback((key, value) => {
                setHistoryState(prevState => {
                    const updatedSvgElements = prevState.present.svgElements.map(el => {
                        if (el.groupId === selectedGroupId) {
                            const newEl = { ...el, [key]: value };
                            if (key === 'spaceType') {
                                if (el.shape === 'polygon') {
                                    newEl.fill = DEFAULT_FILL_COLORS[value] || '#ffffff';
                                }
                                if (el.type === 'text') {
                                    newEl.text = ["LDK", "DK", "K", "居室", "和室"].includes(value)
                                        ? `${value}\n◯.◯帖`
                                        : value;
                                }
                            }
                            return newEl;
                        }
                        return el;
                    });
                    return {
                        past: [...prevState.past, prevState.present],
                        present: { ...prevState.present, svgElements: updatedSvgElements },
                        future: []
                    };
                });
            }, [selectedGroupId]);

            const handleFileChange = async (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setImageUrl(e.target.result);
                        const newOcrData = DUMMY_OCR_DATA;
                        setHistoryState(prevState => ({
                            past: [...prevState.past, prevState.present],
                            present: { ocrData: newOcrData, svgElements: prevState.present.svgElements },
                            future: []
                        }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const getCanvasCoords = useCallback((event) => {
                const svg = svgRef.current;
                if (!svg) return { x: 0, y: 0 };
                const svgRect = svg.getBoundingClientRect();
                const x = (event.clientX - svgRect.left) / zoom;
                const y = (event.clientY - svgRect.top) / zoom;
                return { x, y };
            }, [zoom]);

            const getGridSnappedPoint = useCallback((point) => {
                return {
                    x: Math.round(point.x / gridSize) * gridSize,
                    y: Math.round(point.y / gridSize) * gridSize
                };
            }, [gridSize]);

            const finishDrawing = useCallback(() => {
                if (drawingMode === 'space' && spaceShape === 'line' && linePoints.length > 2) {
                    createPolygonSpace(linePoints);
                } else if (drawingMode === 'stairs' && linePoints.length > 1) {
                    createStairs(linePoints);
                }
                setLinePoints([]);
            }, [linePoints, drawingMode, spaceShape, createPolygonSpace, createStairs]);


            const handleCanvasClick = useCallback((e) => {
                const clickPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);

                if (editorMode === 'create' || editorMode === 'continuous-create') {
                    if ((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs') {
                        const snappedClickPos = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                        if (linePoints.length > 0) {
                            const firstPoint = linePoints[0];
                            const dist = Math.sqrt((snappedClickPos.x - firstPoint.x)**2 + (snappedClickPos.y - firstPoint.y)**2);
                            if (dist < SNAP_THRESHOLD / zoom) {
                                finishDrawing();
                                return;
                            }
                        }
                        setLinePoints(prev => [...prev, snappedClickPos]);
                        return;
                    }
                    if (drawingStartPoint) {
                        let finalEndPoint = isGridVisible ? getGridSnappedPoint(clickPos) : clickPos;
                        if (drawingMode === 'space' && spaceShape === 'rect') {
                            const x1 = Math.min(drawingStartPoint.x, finalEndPoint.x);
                            const y1 = Math.min(drawingStartPoint.y, finalEndPoint.y);
                            const x2 = Math.max(drawingStartPoint.x, finalEndPoint.x);
                            const y2 = Math.max(drawingStartPoint.y, finalEndPoint.y);
                            const rectPoints = [{x: x1, y: y1}, {x: x2, y: y1}, {x: x2, y: y2}, {x: x1, y: y2}];
                            createPolygonSpace(rectPoints);
                        } else {
                            createItem(drawingStartPoint, finalEndPoint);
                        }
                        setDrawingStartPoint(null);
                        return;
                    }
                    if (drawingMode === 'text' || drawingMode === 'fixture') {
                        createItem(isGridVisible ? getGridSnappedPoint(clickPos) : clickPos);
                    } else if (!((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs')) {
                        setDrawingStartPoint(isGridVisible ? getGridSnappedPoint(clickPos) : clickPos);
                    }
                } else { // edit mode
                    setSelectedGroupId(targetElement ? (targetElement.groupId || targetElement.id) : null);
                    setSelectedEdge(null);
                }
            }, [svgElements, editorMode, drawingMode, spaceShape, drawingStartPoint, linePoints, isGridVisible, getGridSnappedPoint, dimensions, strokeColor, fontSize, fontFamily, textAlign, fixtureTemplateId, fixtureCategory, spaceType, fillColor, lineStyle, compassTemplateId, doorTemplateId, windowTemplateId, zoom, backgroundPattern, finishDrawing]);

            const createPolygonSpace = useCallback((points) => {
                const groupId = `space-group-${Date.now()}`;
                const polygonPointsStr = points.map(p => `${p.x},${p.y}`).join(' ');
                
                const specialProps = SUB_TYPE_PROPERTIES[spaceType];
                
                let finalBackgroundPattern = backgroundPattern;
                if (spaceType === '玄関') finalBackgroundPattern = 'grid-small';
                if (spaceType === '和室') finalBackgroundPattern = 'grid-large';
                if (['吹抜', 'グルニエ', '折上天井', '床下収納', '冷蔵庫', '洗濯機'].includes(spaceType)) {
                    finalBackgroundPattern = 'dotted-x';
                }

                const spaceElement = {
                    id: `space-polygon-${Date.now()}`, type: 'space', shape: 'polygon', spaceType: spaceType, groupId,
                    points: polygonPointsStr, 
                    fill: specialProps?.fill !== undefined ? specialProps.fill : fillColor,
                    color: strokeColor,
                    strokeWidth: specialProps?.strokeWidth !== undefined ? specialProps.strokeWidth : DEFAULT_STROKE_WIDTH,
                    lineStyle: specialProps?.lineStyle !== undefined ? specialProps.lineStyle : lineStyle,
                    backgroundPattern: finalBackgroundPattern,
                };
                
                const centroid = getPolygonCentroid([...points]);
                const labelElement = createSpaceLabel(spaceType, centroid, dimensions);
                if (labelElement) {
                    labelElement.groupId = groupId;
                }
                
                const newElements = [spaceElement];
                if(labelElement) newElements.push(labelElement);
                
                setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                if (editorMode === 'create') {
                    setEditorMode('edit');
                }
                setSelectedGroupId(spaceElement.groupId);
            }, [spaceType, backgroundPattern, fillColor, strokeColor, lineStyle, dimensions, editorMode]);

            const createStairs = useCallback((points) => {
                const newElement = {
                    id: `stairs-${Date.now()}`,
                    type: 'stairs',
                    points: points.map(p => `${p.x},${p.y}`).join(' '),
                    width: stairWidth,
                    direction: stairDirection,
                    color: strokeColor,
                    strokeWidth: DEFAULT_STROKE_WIDTH,
                };
                setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, newElement] }, future: [] }));
                if (editorMode === 'create') {
                    setEditorMode('edit');
                }
                setSelectedGroupId(newElement.id);
            }, [stairWidth, stairDirection, strokeColor, editorMode]);

            const createItem = (start, end) => {
                const newElements = [];
                let newElementId = null;
                let newElementGroupId = null;

                if (drawingMode === 'wall') {
                    const newElement = { id: `wall-${Date.now()}`, type: 'wall', x1: start.x, y1: start.y, x2: end.x, y2: end.y, color: strokeColor, strokeWidth: strokeWidth, lineStyle: lineStyle };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'compass') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const size = Math.min(300, Math.max(20, distance));
                    const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                    const newElement = { id: `compass-${Date.now()}`, type: 'compass', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100, size: size, rotation: rotation, templateId: compassTemplateId };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'door' || drawingMode === 'window') {
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const baseAngle = Math.atan2(dy, dx) * 180 / Math.PI;
                    const newElement = { id: `${drawingMode}-${Date.now()}`, type: drawingMode, templateId: drawingMode === 'door' ? doorTemplateId : windowTemplateId, x1: (start.x / dimensions.width) * 100, y1: (start.y / dimensions.height) * 100, x2: (end.x / dimensions.width) * 100, y2: (end.y / dimensions.height) * 100, length: length, baseAngle: baseAngle, rotation: 0, isInner: true, swingDirection: 'clockwise', wallThickness: 10, color: DEFAULT_STROKE_COLOR, strokeWidth: DEFAULT_STROKE_WIDTH };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'text') {
                    const newElement = { id: `text-${Date.now()}`, type: 'text', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100, text: "テキスト", color: strokeColor, fontSize: fontSize, fontFamily: fontFamily, textAlign: textAlign };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                } else if (drawingMode === 'fixture') {
                    const template = FIXTURE_TEMPLATES[fixtureCategory].find(t => t.id === fixtureTemplateId) || {};
                    const newElement = { id: `fixture-${Date.now()}`, type: 'fixture', x: (start.x / dimensions.width) * 100, y: (start.y / dimensions.height) * 100, templateId: fixtureTemplateId, size: template.defaultSize, fill: template.defaultFill, stroke: template.defaultStroke, strokeWidth: template.defaultStrokeWidth };
                    newElements.push(newElement);
                    newElementId = newElement.id;
                }

                if (newElements.length > 0) {
                    setHistoryState(prev => ({ past: [...prev.past, prev.present], present: { ...prev.present, svgElements: [...prev.present.svgElements, ...newElements] }, future: [] }));
                     if (editorMode === 'create') {
                        setEditorMode('edit');
                    }
                    setSelectedGroupId(newElementGroupId || newElementId);
                }
            };

            const handleMouseDown = useCallback((e) => {
                setDisplaySettingsOpen(false);
                e.stopPropagation();
                mouseDownInfo.current = { x: e.clientX, y: e.clientY };
                const startPos = getCanvasCoords(e);
                const targetId = e.target.getAttribute('data-id') || e.target.closest('[data-id]')?.getAttribute('data-id');
                const targetElement = svgElements.find(el => el.id === targetId);
                
                if (editorMode === 'edit') {
                    const handleIndex = e.target.dataset.handleIndex;
                    if (handleIndex !== undefined && selectedGroupId) {
                        setResizingHandleInfo({
                            groupId: selectedGroupId,
                            handleIndex: parseInt(handleIndex, 10),
                            isEdge: e.target.dataset.isEdge === 'true'
                        });
                        historyOnActionStart.current = historyState.present;
                        return;
                    }

                    if (targetElement) {
                        setIsDragging(true);
                        setSelectedGroupId(targetElement.groupId || targetElement.id);
                        setSelectedEdge(null);
                        historyOnActionStart.current = historyState.present;
                        dragInfo.current = { startMouseX: startPos.x, startMouseY: startPos.y };
                    } else {
                        setSelectedGroupId(null);
                        setSelectedEdge(null);
                    }
                } else { // create mode
                    if (!((drawingMode === 'space' && spaceShape === 'line') || drawingMode === 'stairs')) {
                        setLinePoints([]);
                    }
                }
            }, [getCanvasCoords, svgElements, historyState.present, dimensions, editorMode, drawingMode, spaceShape, selectedGroupId]);
            
            const updatePolygonPoints = (elements, groupId, pointIndex, newPoint, isEdge) => {
                const polygonElement = elements.find(el => el.groupId === groupId && el.shape === 'polygon');
                if (!polygonElement) return elements;

                let points = polygonElement.points.split(' ').map(p => {
                    const [x, y] = p.split(',').map(parseFloat);
                    return { x, y };
                });

                if (isEdge) {
                    const p1 = points[pointIndex];
                    const p2 = points[(pointIndex + 1) % points.length];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const edgeVec = { x: dx, y: dy };
                    const normalVec = { x: -dy, y: dy === 0 ? 1 : dx }; // Simplified normal
                    const len = Math.sqrt(normalVec.x**2 + normalVec.y**2);
                    if (len > 0) {
                        normalVec.x /= len;
                        normalVec.y /= len;
                    }
                    
                    const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                    const mouseVec = { x: newPoint.x - midPoint.x, y: newPoint.y - midPoint.y };
                    const dotProduct = mouseVec.x * normalVec.x + mouseVec.y * normalVec.y;
                    
                    const moveVec = { x: dotProduct * normalVec.x, y: dotProduct * normalVec.y };

                    points[pointIndex] = { x: p1.x + moveVec.x, y: p1.y + moveVec.y };
                    points[(pointIndex + 1) % points.length] = { x: p2.x + moveVec.x, y: p2.y + moveVec.y };

                } else {
                    points[pointIndex] = newPoint;
                }
                
                const newPolygonPointsString = points.map(p => `${p.x},${p.y}`).join(' ');
                
                const newCentroid = getPolygonCentroid([...points]);

                const label = elements.find(el => el.groupId === groupId && el.type === 'text');
                
                return elements.map(el => {
                    if (el.groupId !== groupId) return el;
                    if (el.shape === 'polygon') {
                        return { ...el, points: newPolygonPointsString };
                    }
                    if (label && el.id === label.id) {
                         return { ...el, x: (newCentroid.x / dimensions.width) * 100, y: (newCentroid.y / dimensions.height) * 100 };
                    }
                    return el;
                });
            };

            const handleMouseMove = useCallback((e) => {
                const currentPos = getCanvasCoords(e);
                setMousePos(currentPos);
                
                if (resizingHandleInfo) {
                    const { groupId, handleIndex, isEdge } = resizingHandleInfo;
                    const snappedPos = isGridVisible ? getGridSnappedPoint(currentPos) : currentPos;
                    const newElements = updatePolygonPoints(historyOnActionStart.current.svgElements, groupId, handleIndex, snappedPos, isEdge);
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                    return;
                }

                if (isDragging && dragInfo.current) {
                    const dx = currentPos.x - dragInfo.current.startMouseX;
                    const dy = currentPos.y - dragInfo.current.startMouseY;
                    let finalDx = dx;
                    let finalDy = dy;
                    
                    if (isGridVisible) {
                        const refElement = historyOnActionStart.current.svgElements.find(el => el.id === selectedGroupId || el.groupId === selectedGroupId);
                        if (refElement) {
                            let originalRefX, originalRefY;
                            if (refElement.x !== undefined) {
                                originalRefX = refElement.x / 100 * dimensions.width;
                                originalRefY = refElement.y / 100 * dimensions.height;
                            } else if (refElement.points) {
                                const points = refElement.points.split(' ').map(p => p.split(',').map(parseFloat));
                                originalRefX = points[0][0];
                                originalRefY = points[0][1];
                            } else if (refElement.x1 !== undefined) {
                                originalRefX = refElement.x1;
                                originalRefY = refElement.y1;
                            }

                            if (originalRefX !== undefined) {
                                const newRefPoint = { x: originalRefX + dx, y: originalRefY + dy };
                                const snappedRefPoint = getGridSnappedPoint(newRefPoint);
                                finalDx = snappedRefPoint.x - originalRefX;
                                finalDy = snappedRefPoint.y - originalRefY;
                            }
                        }
                    }

                    const newElements = historyOnActionStart.current.svgElements.map(el => {
                        if (el.groupId === selectedGroupId || el.id === selectedGroupId) {
                            const newEl = { ...el };
                            const originalEl = historyOnActionStart.current.svgElements.find(e => e.id === el.id);
                            if (!originalEl) return el;

                            if (originalEl.x !== undefined) {
                                const newPixelX = (originalEl.x / 100 * dimensions.width) + finalDx;
                                const newPixelY = (originalEl.y / 100 * dimensions.height) + finalDy;
                                newEl.x = (newPixelX / dimensions.width) * 100;
                                newEl.y = (newPixelY / dimensions.height) * 100;
                            } else if (originalEl.points) {
                                const originalPoints = originalEl.points.split(' ').map(p_str => {
                                    const [x, y] = p_str.split(',').map(parseFloat);
                                    return {x, y};
                                });
                                const newPoints = originalPoints.map(p => ({ x: p.x + finalDx, y: p.y + finalDy }));
                                newEl.points = newPoints.map(p => `${p.x},${p.y}`).join(' ');
                            } else if (originalEl.x1 !== undefined) {
                                newEl.x1 = originalEl.x1 + finalDx;
                                newEl.y1 = originalEl.y1 + finalDy;
                                newEl.x2 = originalEl.x2 + finalDx;
                                newEl.y2 = originalEl.y2 + finalDy;
                            }
                            return newEl;
                        }
                        return el;
                    });
                    setHistoryState(prev => ({ ...prev, present: { ...prev.present, svgElements: newElements } }));
                }
                
            }, [isDragging, resizingHandleInfo, getCanvasCoords, selectedGroupId, isGridVisible, getGridSnappedPoint, dimensions]);

            const handleMouseUp = useCallback((e) => {
                const wasDragging = isDragging;
                const wasResizing = !!resizingHandleInfo;
                if (wasDragging || wasResizing) {
                    if (historyOnActionStart.current && JSON.stringify(historyOnActionStart.current.svgElements) !== JSON.stringify(svgElements)) {
                        setHistoryState(prev => ({ ...prev, past: [...prev.past, historyOnActionStart.current], future: [] }));
                    }
                }
                const wasClick = mouseDownInfo.current && (Math.sqrt((e.clientX - mouseDownInfo.current.x)**2 + (e.clientY - mouseDownInfo.current.y)**2) < 5);
                if (wasClick && !wasDragging && !wasResizing) {
                    handleCanvasClick(e);
                }
                setIsDragging(false);
                setResizingHandleInfo(null);
                dragInfo.current = null;
                historyOnActionStart.current = null;
                mouseDownInfo.current = null;
            }, [isDragging, resizingHandleInfo, svgElements, handleCanvasClick]);

            const deleteSelectedElement = useCallback(() => {
                if (!selectedGroupId) return;
                setHistoryState(prevState => {
                    const newSvgElements = prevState.present.svgElements.filter(el => el.groupId !== selectedGroupId && el.id !== selectedGroupId);
                    return { past: [...prevState.past, prevState.present], present: { ...prevState.present, svgElements: newSvgElements }, future: [] };
                });
                setSelectedGroupId(null);
            }, [selectedGroupId]);

            const handleUndo = useCallback(() => {
                setHistoryState(prevState => {
                    const past = [...prevState.past];
                    const newPresent = past.pop();
                    if (!newPresent) return prevState;
                    return { past: past, present: newPresent, future: [prevState.present, ...prevState.future] };
                });
            }, []);

            const handleRedo = useCallback(() => {
                setHistoryState(prevState => {
                    const future = [...prevState.future];
                    const newPresent = future.shift();
                    if (!newPresent) return prevState;
                    return { past: [...prevState.past, prevState.present], present: newPresent, future: future };
                });
            }, []);

            const rotateSelectedElement90Degrees = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window' || selectedElement.type === 'compass')) {
                    const newRotation = ((selectedElement.rotation || 0) + 90) % 360;
                    handleSelectedGroupUpdate('rotation', newRotation);
                }
            }, [selectedElement, handleSelectedGroupUpdate]);

            const toggleSelectedElementSwingDirection = useCallback(() => {
                if (selectedElement && (selectedElement.type === 'door' || selectedElement.type === 'window')) {
                    const newIsInner = !selectedElement.isInner;
                    setHistoryState(prevState => {
                        const updatedElements = prevState.present.svgElements.map(el => {
                            if (el.id === selectedGroupId) { return { ...el, isInner: newIsInner }; }
                            return el;
                        });
                        return { past: [...prevState.past, prevState.present], present: { ...prevState.present, svgElements: updatedElements }, future: [] };
                    });
                }
            }, [selectedElement, selectedGroupId]);

            const handleSaveImage = async () => {
                const storedId = selectedGroupId;
                setSelectedGroupId(null);

                await new Promise(resolve => setTimeout(resolve, 0));

                const svgNode = svgRef.current;
                const exportCanvas = document.createElement('canvas');
                exportCanvas.width = dimensions.width;
                exportCanvas.height = dimensions.height;
                const ctx = exportCanvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                const svgClone = svgNode.cloneNode(true);
                svgClone.style.opacity = 1;

                const images = svgClone.querySelectorAll('image');
                const promises = Array.from(images).map(imageNode => {
                    const href = imageNode.getAttribute('href');
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    return fetch(proxyUrl + encodeURIComponent(href))
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Network response was not ok for ${href}`);
                            }
                            return response.blob();
                        })
                        .then(blob => new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                imageNode.setAttribute('href', reader.result);
                                resolve();
                            };
                            reader.onerror = () => {
                                reject(new Error('FileReader error'));
                            };
                            reader.readAsDataURL(blob);
                        }))
                        .catch(error => {
                            console.error(`Failed to fetch and embed image from ${href}:`, error);
                        });
                });

                try {
                    await Promise.all(promises);
                } catch (error) {
                    console.error("PNG保存エラー: 画像の埋め込みに失敗しました。", error);
                }

                const svgString = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);
                const img = new Image();

                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);
                    const link = document.createElement('a');
                    const today = new Date();
                    const yyyy = today.getFullYear();
                    const mm = String(today.getMonth() + 1).padStart(2, '0');
                    const dd = String(today.getDate()).padStart(2, '0');
                    link.download = `floorplan_${yyyy}${mm}${dd}.png`;
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                    setSelectedGroupId(storedId);
                };
                img.onerror = () => {
                    console.error("Failed to load SVG blob into image for export.");
                    setSelectedGroupId(storedId);
                }
                img.src = url;
            };

            useEffect(() => {
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [handleMouseMove, handleMouseUp]);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }, [zoom, isGridVisible]);


            useEffect(() => {
                if (editorAreaRef.current) {
                    const area = editorAreaRef.current;
                    const timer = setTimeout(() => {
                        area.scrollTop = (area.scrollHeight - area.clientHeight) / 2;
                        const scrollLeftCenter = (area.scrollWidth - area.clientWidth) / 2;
                        const sidebarWidth = 320;
                        const newScrollLeft = isSidebarOpen ? scrollLeftCenter - (sidebarWidth / 2) : scrollLeftCenter;
                        area.scrollLeft = newScrollLeft;
                    }, 0);
                    return () => clearTimeout(timer);
                }
            }, [imageUrl, isSidebarOpen]);

            useEffect(() => {
                setFillColor(DEFAULT_FILL_COLORS[spaceType] || '#ffffff');
            }, [spaceType]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); handleUndo(); }
                    else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); handleRedo(); }
                    else if (e.key === 'Delete' || e.key === 'Backspace') { 
                        if (selectedGroupId) {
                             e.preventDefault(); 
                             deleteSelectedElement();
                        }
                    }
                    else if (e.key === 'Escape') {
                        setDrawingStartPoint(null);
                        setLinePoints([]);
                        setSelectedGroupId(null);
                        setResizingHandleInfo(null);
                        setSelectedEdge(null);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleUndo, handleRedo, deleteSelectedElement, selectedGroupId]);

            useEffect(() => {
                const editorArea = editorAreaRef.current;
                if (!editorArea) return;
                const handleWheel = (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.1 : 0.1;
                        setZoom(prevZoom => Math.max(0.2, Math.min(3, prevZoom + delta)));
                    }
                };
                editorArea.addEventListener('wheel', handleWheel, { passive: false });
                return () => editorArea.removeEventListener('wheel', handleWheel);
            }, []);

            useEffect(() => {
                setDrawingStartPoint(null);
                setLinePoints([]);
                if (editorMode === 'edit') {
                    setSelectedGroupId(null);
                    setSelectedEdge(null);
                }
            }, [editorMode, drawingMode, spaceShape]);

            useEffect(() => {
                if (!isDisplaySettingsOpen) return;
                function handleClickOutside(event) {
                    if (isSidebarOpen && displaySettingsRef.current && !displaySettingsRef.current.contains(event.target) && !editorAreaRef.current.contains(event.target)) {
                        setDisplaySettingsOpen(false);
                    }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => {
                    document.removeEventListener("mousedown", handleClickOutside);
                };
            }, [isDisplaySettingsOpen, isSidebarOpen]);

            const getCursorClass = () => {
                if (isDragging || resizingHandleInfo) return 'cursor-grabbing';
                if (editorMode === 'create' || editorMode === 'continuous-create') return 'cursor-crosshair';
                return 'cursor-default';
            };
            
            const getVerticesAndEdges = (element, allElements) => {
                if (!element) return { vertices: [], edges: [] };
                const polygonEl = allElements.find(e => (e.groupId === element.groupId || e.id === element.id) && e.shape === 'polygon');
                if (polygonEl) {
                    const vertices = polygonEl.points.split(' ').map(p => {
                        const [x, y] = p.split(',');
                        return { x: parseFloat(x), y: parseFloat(y) };
                    });
                    const edges = vertices.map((v, i) => {
                        const nextV = vertices[(i + 1) % vertices.length];
                        return { x: (v.x + nextV.x) / 2, y: (v.y + nextV.y) / 2 };
                    });
                    return { vertices, edges };
                }
                if (element.type === 'wall') {
                    const vertices = [{x: element.x1, y: element.y1}, {x: element.x2, y: element.y2}];
                    return { vertices, edges: [] };
                }
                return { vertices: [], edges: [] };
            }
            
            const getResizeCursor = (index, totalPoints) => {
                if (totalPoints === 4) { // Assume rect-like polygon
                    return ['nwse-resize', 'nesw-resize', 'nwse-resize', 'nesw-resize'][index];
                }
                return 'move';
            }
            
            const sortedElements = [...svgElements].sort((a, b) => {
                const typeOrder = { 'space': 0, 'wall': 1, 'stairs': 2, 'door': 3, 'window': 3, 'fixture': 4, 'compass': 5, 'text': 6 };
                const orderA = typeOrder[a.type] ?? 99;
                const orderB = typeOrder[b.type] ?? 99;
                return orderA - orderB;
            });

            // 背景パターンを描画するためのコンポーネント
            const BackgroundRenderer = ({ element }) => {
                if (!element.backgroundPattern || element.backgroundPattern === 'none') {
                    return null;
                }

                const points = element.points.split(' ').map(p_str => {
                    const [x, y] = p_str.split(',').map(parseFloat);
                    return { x, y };
                });

                if (points.length < 3) return null;

                const clipPathId = `clip-${element.id}`;

                const xs = points.map(p => p.x);
                const ys = points.map(p => p.y);
                const bbox = {
                    minX: Math.min(...xs),
                    minY: Math.min(...ys),
                    maxX: Math.max(...xs),
                    maxY: Math.max(...ys),
                };
                bbox.width = bbox.maxX - bbox.minX;
                bbox.height = bbox.maxY - bbox.minY;

                const renderPattern = () => {
                    const pattern = element.backgroundPattern;
                    const paths = [];
                    const strokeColor = '#cccccc';
                    const strokeWidth = 1;

                    switch (pattern) {
                        case 'vertical-lines': {
                            const step = 10;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'horizontal-lines': {
                            const step = 10;
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'grid-small': {
                            const step = 10;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={strokeColor} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'grid-large': {
                            const step = 30;
                            for (let x = bbox.minX - (bbox.minX % step) + step; x < bbox.maxX; x += step) {
                                paths.push(<line key={`v-${x}`} x1={x} y1={bbox.minY} x2={x} y2={bbox.maxY} stroke={'#000000'} strokeWidth={strokeWidth} />);
                            }
                            for (let y = bbox.minY - (bbox.minY % step) + step; y < bbox.maxY; y += step) {
                                paths.push(<line key={`h-${y}`} x1={bbox.minX} y1={y} x2={bbox.maxX} y2={y} stroke={'#000000'} strokeWidth={strokeWidth} />);
                            }
                            return paths;
                        }
                        case 'solid-x':
                        case 'dotted-x': {
                            const dashArray = pattern === 'dotted-x' ? '2 2' : 'none';
                            paths.push(<line key="x1" x1={bbox.minX} y1={bbox.minY} x2={bbox.maxX} y2={bbox.maxY} stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            paths.push(<line key="x2" x1={bbox.minX} y1={bbox.maxY} x2={bbox.maxX} y2={bbox.minY} stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            return paths;
                        }
                        case 'solid-triangle':
                        case 'dotted-triangle': {
                            const leftPoints = points.filter(p => p.x === bbox.minX).sort((a,b) => a.y - b.y);
                            const rightPoints = points.filter(p => p.x === bbox.maxX).sort((a,b) => a.y - b.y);

                            if (leftPoints.length >= 2 && rightPoints.length >= 1) {
                                const p1 = leftPoints[0];
                                const p2 = leftPoints[leftPoints.length - 1];
                                const pm = { x: bbox.maxX, y: (bbox.maxY + bbox.minY) / 2 };
                                const dashArray = pattern === 'dotted-triangle' ? '2 2' : 'none';
                                paths.push(<path key="tri" d={`M${p1.x},${p1.y} L${p2.x},${p2.y} L${pm.x},${pm.y} Z`} fill="none" stroke={'#000000'} strokeWidth={strokeWidth} strokeDasharray={dashArray} />);
                            }
                            return paths;
                        }
                        default:
                            return null;
                    }
                };

                return (
                    <g style={{pointerEvents: 'none'}}>
                        <defs>
                            <clipPath id={clipPathId}>
                                <polygon points={element.points} />
                            </clipPath>
                        </defs>
                        <g clipPath={`url(#${clipPathId})`}>
                            {renderPattern()}
                        </g>
                    </g>
                );
            };

            const StairsRenderer = ({ element }) => {
                const { points: pointsStr, width, direction, color, strokeWidth } = element;
                const points = pointsStr.split(' ').map(p => {
                    const [x, y] = p.split(',').map(parseFloat);
                    return { x, y };
                });

                if (points.length < 2) return null;

                const outlines = [[], []];
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    let p_before = i > 0 ? points[i - 1] : null;
                    let p_after = i < points.length - 1 ? points[i + 1] : null;

                    let vec1 = p_before ? { x: p.x - p_before.x, y: p.y - p_before.y } : { x: p_after.x - p.x, y: p_after.y - p.y };
                    let perp1 = { x: -vec1.y, y: vec1.x };
                    let len1 = Math.sqrt(perp1.x ** 2 + perp1.y ** 2);
                    if (len1 > 0) { perp1.x /= len1; perp1.y /= len1; }

                    let p1_1 = { x: p.x + perp1.x * width / 2, y: p.y + perp1.y * width / 2 };
                    let p1_2 = { x: p.x - perp1.x * width / 2, y: p.y - perp1.y * width / 2 };

                    if (p_before && p_after) {
                        outlines[0].push(p1_1);
                        outlines[1].push(p1_2);
                    } else {
                        outlines[0].push(p1_1);
                        outlines[1].push(p1_2);
                    }
                }

                const steps = [];
                const stepInterval = 15;
                let totalLength = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i+1];
                    const segmentVec = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const segmentLen = Math.sqrt(segmentVec.x**2 + segmentVec.y**2);
                    const segmentDir = { x: segmentVec.x / segmentLen, y: segmentVec.y / segmentLen };
                    const perp = { x: -segmentDir.y, y: segmentDir.x };
                    
                    const startOffset = (stepInterval - (totalLength % stepInterval)) % stepInterval;

                    for (let l = startOffset; l < segmentLen; l += stepInterval) {
                        const stepCenter = { x: p1.x + segmentDir.x * l, y: p1.y + segmentDir.y * l };
                        const s1 = { x: stepCenter.x + perp.x * width / 2, y: stepCenter.y + perp.y * width / 2 };
                        const s2 = { x: stepCenter.x - perp.x * width / 2, y: stepCenter.y - perp.y * width / 2 };
                        steps.push(<line key={`step-${i}-${l}`} x1={s1.x} y1={s1.y} x2={s2.x} y2={s2.y} stroke={color} strokeWidth={1} />);
                    }
                    totalLength += segmentLen;
                }

                const lastPoint = points[points.length - 1];
                const secondLastPoint = points[points.length - 2];
                const arrowVec = { x: lastPoint.x - secondLastPoint.x, y: lastPoint.y - secondLastPoint.y };
                const arrowLen = Math.sqrt(arrowVec.x**2 + arrowVec.y**2);
                const arrowDir = { x: arrowVec.x / arrowLen, y: arrowVec.y / arrowLen };
                const arrowText = direction.toUpperCase();

                return (
                    <g data-id={element.id} style={{ pointerEvents: 'all', cursor: 'grab' }}>
                        <path d={`M ${outlines[0].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={strokeWidth} />
                        <path d={`M ${outlines[1].map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={strokeWidth} />
                        {steps}
                        <path d={`M ${points.map(p => `${p.x} ${p.y}`).join(' L ')}`} fill="none" stroke={color} strokeWidth={1} markerEnd="url(#arrowhead)" />
                        <text x={lastPoint.x + arrowDir.x * 10} y={lastPoint.y + arrowDir.y * 10} fontSize="16" fill={color} textAnchor="middle" dominantBaseline="middle" transform={`rotate(${Math.atan2(arrowDir.y, arrowDir.x) * 180 / Math.PI - 90} ${lastPoint.x} ${lastPoint.y})`}>
                            {arrowText}
                        </text>
                    </g>
                );
            };

            return (
                <div className="flex flex-col h-screen">
                    <header className="bg-white shadow-md p-2 flex items-center justify-between z-30 flex-shrink-0">
                        <span className="text-xl font-bold text-gray-800 ml-4">Auto間取り図</span>
                        <div className="flex items-center space-x-4">
                            <button onClick={handleSaveImage} className="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">PNGで保存</button>
                            <button onClick={handleUndo} disabled={historyState.past.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">戻る</button>
                            <button onClick={handleRedo} disabled={historyState.future.length === 0} className="px-3 py-1 bg-gray-200 rounded disabled:opacity-50">進む</button>
                            <div className="flex items-center space-x-2">
                                <button onClick={() => setZoom(z => Math.max(0.2, z - 0.1))} className="px-3 py-1 bg-gray-200 rounded">-</button>
                                <span>{Math.round(zoom * 100)}%</span>
                                <button onClick={() => setZoom(z => Math.min(3, z + 0.1))} className="px-3 py-1 bg-gray-200 rounded">+</button>
                            </div>
                        </div>
                    </header>

                    <div className="flex-1 relative overflow-hidden">
                        <main ref={editorAreaRef} className="editor-area w-full h-full bg-gray-200">
                            <div className="scroll-wrapper">
                                <div className="editor-container" style={{ width: dimensions.width, height: dimensions.height, transform: `translate(-50%, -50%) scale(${zoom})`, ...(isGridVisible && { backgroundImage: `linear-gradient(to right, #f3f4f6 1px, transparent 1px), linear-gradient(to bottom, #f3f4f6 1px, transparent 1px)`, backgroundSize: `${gridSize}px ${gridSize}px` }) }}>
                                    {imageUrl && <img ref={imageRef} src={imageUrl} alt="間取り図" className="editor-image" style={{ opacity: 1 - imageOpacity, transform: `translate(-50%, -50%) scale(${imageScale})` }} crossOrigin="anonymous"/>}
                                    <canvas ref={canvasRef} className={getCursorClass()} width={dimensions.width} height={dimensions.height} />
                                    <svg ref={svgRef} className="editor-svg" width={dimensions.width} height={dimensions.height} xmlns="http://www.w3.org/2000/svg" style={{ opacity: 1 - drawingOpacity }} onMouseDown={handleMouseDown}>
                                        <defs>
                                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                                <polygon points="0 0, 10 3.5, 0 7" />
                                            </marker>
                                        </defs>
                                        {sortedElements.map(el => {
                                            const isSelected = el.groupId ? el.groupId === selectedGroupId : el.id === selectedGroupId;
                                            const stroke = isSelected ? SELECTED_ELEMENT_COLOR : (el.color || DEFAULT_STROKE_COLOR);
                                            const strokeW = el.strokeWidth || DEFAULT_STROKE_WIDTH;
                                            const style = LINE_STYLES.find(s => s.id === el.lineStyle);
                                            
                                            if (el.shape === 'polygon' && el.type === 'space') {
                                                const pointerEvents = (editorMode === 'create' || editorMode === 'continuous-create') ? 'none' : 'all';
                                                return (
                                                    <g key={el.id} data-id={el.id}>
                                                        <polygon points={el.points} fill={el.fill} stroke="none" shapeRendering="crispEdges" style={{ pointerEvents }} />
                                                        <BackgroundRenderer element={el} />
                                                        <polygon points={el.points} fill="none" stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} style={{ pointerEvents }} shapeRendering="crispEdges" />
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'wall') {
                                                return <line key={el.id} data-id={el.id} x1={el.x1} y1={el.y1} x2={el.x2} y2={el.y2} stroke={stroke} strokeWidth={strokeW} strokeDasharray={style?.dashArray} style={{ pointerEvents: 'all' }} />
                                            }
                                            if (el.type === 'stairs') {
                                                return <StairsRenderer key={el.id} element={{...el, color: stroke, strokeWidth: strokeW}} />;
                                            }
                                            if (el.type === 'text') {
                                                let textAnchor = 'start';
                                                if (el.textAlign === 'center') textAnchor = 'middle';
                                                else if (el.textAlign === 'right') textAnchor = 'end';
                                                return (
                                                    <text key={el.id} data-id={el.id} x={`${el.x}%`} y={`${el.y}%`} fill={el.color} fontSize={el.fontSize} fontFamily={el.fontFamily} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab', pointerEvents:'all'}} textAnchor={textAnchor}>
                                                        {el.text.split('\n').map((line, i) => (
                                                            <tspan key={i} x={`${el.x}%`} dy={i === 0 ? 0 : '1.2em'}>{line}</tspan>
                                                        ))}
                                                    </text>
                                                );
                                            }
                                            if (el.type === 'compass') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const template = COMPASS_TEMPLATES.find(t => t.id === el.templateId) || COMPASS_TEMPLATES[0];
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) rotate(${el.rotation || 0})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <image href={template.src} x={-el.size / 2} y={-el.size / 2} width={el.size} height={el.size} preserveAspectRatio="xMidYMid meet" />
                                                        {isSelected && <rect x={-el.size/2 - 2} y={-el.size/2 - 2} width={el.size + 4} height={el.size + 4} fill="none" stroke={SELECTED_ELEMENT_COLOR} strokeWidth="2" />}
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'fixture') {
                                                const cx = el.x / 100 * dimensions.width;
                                                const cy = el.y / 100 * dimensions.height;
                                                const templateCategory = FIXTURE_TEMPLATES[Object.keys(FIXTURE_TEMPLATES).find(cat => FIXTURE_TEMPLATES[cat].some(t => t.id === el.templateId))] || FIXTURE_TEMPLATES.kitchen;
                                                const template = templateCategory.find(t => t.id === el.templateId) || FIXTURE_TEMPLATES.kitchen[0];
                                                const scaleFactor = el.size / template.defaultSize;
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${cx}, ${cy}) scale(${scaleFactor})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <path d={template.path} fill={el.fill} stroke={el.stroke} strokeWidth={el.strokeWidth} />
                                                    </g>
                                                );
                                            }
                                            if (el.type === 'door' || el.type === 'window') {
                                                const p1 = { x: el.x1 / 100 * dimensions.width, y: el.y1 / 100 * dimensions.height };
                                                const template = el.type === 'door' ? (DOOR_TEMPLATES.find(t => t.id === el.templateId) || DOOR_TEMPLATES[0]) : (WINDOW_TEMPLATES.find(t => t.id === el.templateId) || WINDOW_TEMPLATES[0]);
                                                const totalRotation = el.baseAngle + (el.rotation || 0);
                                                return (
                                                    <g key={el.id} data-id={el.id} transform={`translate(${p1.x}, ${p1.y}) rotate(${totalRotation})`} style={{cursor: isSelected && isDragging ? 'grabbing' : 'grab'}}>
                                                        <path d={template.path(el.length, el.swingDirection, el.isInner, el.wallThickness)} fill="none" stroke={stroke} strokeWidth={DEFAULT_STROKE_WIDTH} strokeLinecap="square" />
                                                    </g>
                                                );
                                            }
                                            return null;
                                        })}
                                        
                                        {selectedElement && editorMode === 'edit' && (
                                            <g>
                                                {(() => {
                                                    const { vertices, edges } = getVerticesAndEdges(selectedElement, svgElements);
                                                    return (
                                                        <>
                                                            {vertices.map((vertex, index) => (
                                                                <circle
                                                                    key={`handle-vertex-${selectedElement.id}-${index}`}
                                                                    data-id={selectedElement.id}
                                                                    data-handle-index={index}
                                                                    cx={vertex.x}
                                                                    cy={vertex.y}
                                                                    r={6 / zoom}
                                                                    fill="black"
                                                                    stroke="white"
                                                                    strokeWidth={2 / zoom}
                                                                    style={{ cursor: getResizeCursor(index, vertices.length) }}
                                                                />
                                                            ))}
                                                             {selectedElement.type === 'space' && edges.map((edge, index) => (
                                                                <rect
                                                                    key={`handle-edge-${selectedElement.id}-${index}`}
                                                                    data-id={selectedElement.id}
                                                                    data-handle-index={index}
                                                                    data-is-edge="true"
                                                                    x={edge.x - 5/zoom}
                                                                    y={edge.y - 5/zoom}
                                                                    width={10/zoom}
                                                                    height={10/zoom}
                                                                    fill="white"
                                                                    stroke="black"
                                                                    strokeWidth={1 / zoom}
                                                                    style={{ cursor: 'move' }}
                                                                />
                                                            ))}
                                                        </>
                                                    )
                                                })()}
                                            </g>
                                        )}

                                        {/* Preview Rendering */}
                                        {drawingStartPoint && !linePoints.length && (() => {
                                            let previewEndPoint = isGridVisible ? getGridSnappedPoint(mousePos) : mousePos;
                                            if(drawingMode === 'compass') {
                                                const template = COMPASS_TEMPLATES.find(t => t.id === compassTemplateId) || COMPASS_TEMPLATES[0];
                                                const dx = mousePos.x - drawingStartPoint.x;
                                                const dy = mousePos.y - drawingStartPoint.y;
                                                const distance = Math.sqrt(dx*dx + dy*dy);
                                                const size = Math.min(300, Math.max(20, distance));
                                                const rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                                                return (
                                                    <g transform={`translate(${drawingStartPoint.x}, ${drawingStartPoint.y}) rotate(${rotation})`} style={{ pointerEvents: 'none' }}>
                                                        <image href={template.src} x={-size / 2} y={-size / 2} width={size} height={size} preserveAspectRatio="xMidYMid meet" opacity="0.7"/>
                                                    </g>
                                                );
                                            }
                                            if(drawingMode === 'space' && spaceShape === 'rect') return <rect x={Math.min(drawingStartPoint.x, previewEndPoint.x)} y={Math.min(drawingStartPoint.y, previewEndPoint.y)} width={Math.abs(drawingStartPoint.x - previewEndPoint.x)} height={Math.abs(drawingStartPoint.y - previewEndPoint.y)} fill="transparent" stroke={strokeColor} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5" style={{ pointerEvents: 'none' }} shapeRendering="crispEdges" />;
                                            if(drawingMode === 'door' || drawingMode === 'window' || drawingMode === 'wall') return <line x1={drawingStartPoint.x} y1={drawingStartPoint.y} x2={previewEndPoint.x} y2={previewEndPoint.y} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="5,5" style={{ pointerEvents: 'none' }} />;
                                            return null;
                                        })()}
                                        {linePoints.length > 0 && (
                                            <g style={{pointerEvents: 'none'}}>
                                                {linePoints.map((p, i) => {
                                                    if (i === 0) return null;
                                                    const p1 = linePoints[i-1];
                                                    return <line key={i} x1={p1.x} y1={p1.y} x2={p.x} y2={p.y} stroke={strokeColor} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray={LINE_STYLES.find(s => s.id === lineStyle)?.dashArray || 'none'} />;
                                                })}
                                                <line x1={linePoints[linePoints.length - 1].x} y1={linePoints[linePoints.length - 1].y} x2={isGridVisible ? getGridSnappedPoint(mousePos).x : mousePos.x} y2={isGridVisible ? getGridSnappedPoint(mousePos).y : mousePos.y} stroke={strokeColor} strokeWidth={DEFAULT_STROKE_WIDTH} strokeDasharray="5,5" />
                                            </g>
                                        )}
                                    </svg>
                                </div>
                            </div>
                        </main>

                        <button onClick={() => setSidebarOpen(!isSidebarOpen)} className={`absolute top-16 z-20 bg-indigo-600 hover:bg-indigo-700 text-white w-6 h-12 flex items-center justify-center rounded-r-lg cursor-pointer transition-all duration-300 ease-in-out focus:outline-none ${isSidebarOpen ? 'left-80' : '-left-0'}`} aria-label={isSidebarOpen ? "サイドバーを閉じる" : "サイドバーを開く"}>
                            {isSidebarOpen ? '◀' : '▶'}
                        </button>

                        <aside className={`absolute top-0 left-0 h-full w-80 bg-gray-50 p-4 space-y-4 z-10 transform transition-transform duration-300 ease-in-out ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`} style={{overflowY: 'auto'}}>
                            <div ref={displaySettingsRef}>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDisplaySettingsOpen(!isDisplaySettingsOpen)}>
                                    <span>表示設定</span>
                                    <span className="text-gray-400">{isDisplaySettingsOpen ? '▼' : '▶'}</span>
                                </h2>
                                {isDisplaySettingsOpen && (
                                    <div className="mt-2 space-y-4">
                                        <div>
                                            <label className="cursor-pointer block w-full text-sm text-center text-blue-700 bg-blue-50 hover:bg-blue-100 font-semibold py-2 px-4 rounded-full">
                                                下絵を選択<input type="file" onChange={handleFileChange} accept="image/*" className="hidden"/>
                                            </label>
                                        </div>
                                        {imageUrl && (
                                            <>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">下絵のサイズ: {Math.round(imageScale * 100)}%</label>
                                                    <div className="flex items-center space-x-2 mt-1">
                                                        <input type="range" min="10" max="300" step="1" value={imageScale * 100} onChange={(e) => setImageScale(parseFloat(e.target.value) / 100)} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        <input type="number" value={Math.round(imageScale * 100)} onChange={(e) => setImageScale(parseInt(e.target.value) / 100 || 0.1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                    </div>
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700">下絵の透明度: {Math.round(imageOpacity * 100)}%</label>
                                                     <div className="flex items-center space-x-2 mt-1">
                                                        <input type="range" min="0" max="1" step="0.05" value={imageOpacity} onChange={(e) => setImageOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                        <input type="number" value={Math.round(imageOpacity * 100)} onChange={(e) => setImageOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                    </div>
                                                </div>
                                            </>
                                        )}
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">レイヤーの透明度: {Math.round(drawingOpacity * 100)}%</label>
                                            <div className="flex items-center space-x-2 mt-1">
                                                <input type="range" min="0" max="1" step="0.05" value={drawingOpacity} onChange={(e) => setDrawingOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                <input type="number" value={Math.round(drawingOpacity * 100)} onChange={(e) => setDrawingOpacity(parseInt(e.target.value) / 100 || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                            </div>
                                        </div>
                                        <div className="flex items-center">
                                            <input id="grid-toggle" type="checkbox" checked={isGridVisible} onChange={() => setGridVisible(!isGridVisible)} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
                                            <label htmlFor="grid-toggle" className="ml-2 block text-sm font-medium text-gray-700">グリッド線を表示</label>
                                        </div>
                                        {isGridVisible && (
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700">グリッドサイズ: {gridSize}px</label>
                                                <div className="flex items-center space-x-2 mt-1">
                                                    <input type="range" min="1" max="30" step="1" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                    <input type="number" value={gridSize} onChange={(e) => setGridSize(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            <hr/>
                            <div>
                                <h2 className="text-lg font-semibold mb-2 flex justify-between items-center cursor-pointer" onClick={() => setDrawingToolsOpen(!isDrawingToolsOpen)}>
                                    <span>図形描画</span>
                                    <span className="text-gray-400">{isDrawingToolsOpen ? '▼' : '▶'}</span>
                                </h2>
                                {isDrawingToolsOpen && (
                                    <div className="mt-2">
                                        <div className="flex bg-gray-200 rounded-lg p-1 mb-4">
                                            <button onClick={() => setEditorMode('continuous-create')} className={`w-full py-1 rounded-md text-sm ${editorMode === 'continuous-create' ? 'bg-white shadow' : ''}`}>連続作成</button>
                                            <button onClick={() => setEditorMode('create')} className={`w-full py-1 rounded-md text-sm ${editorMode === 'create' ? 'bg-white shadow' : ''}`}>作成</button>
                                            <button onClick={() => setEditorMode('edit')} className={`w-full py-1 rounded-md text-sm ${editorMode === 'edit' ? 'bg-white shadow' : ''}`}>編集</button>
                                        </div>

                                        {(editorMode === 'create' || editorMode === 'continuous-create') && (
                                            <>
                                                <div className="grid grid-cols-4 gap-2">
                                                    {['space', 'door', 'window', 'wall', 'fixture', 'stairs', 'compass', 'text'].map(mode => {
                                                        const names = {'space':'空間', 'door':'ドア', 'window':'窓', 'wall':'壁', 'fixture':'設備', 'stairs':'階段', 'compass':'方角', 'text':'文字'};
                                                        return <button key={mode} onClick={() => setDrawingMode(mode)} className={`px-2 py-2 rounded text-sm ${drawingMode === mode ? 'bg-indigo-600 text-white' : 'bg-gray-200'}`}>{names[mode]}</button>
                                                    })}
                                                </div>
                                                {drawingMode === 'space' && (
                                                    <div className="mt-4 space-y-4">
                                                        <div className="flex bg-gray-200 rounded-lg p-1">
                                                            <button onClick={() => setSpaceShape('rect')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'rect' ? 'bg-white shadow' : ''}`}>四角形</button>
                                                            <button onClick={() => setSpaceShape('line')} className={`w-full py-1 rounded-md text-sm ${spaceShape === 'line' ? 'bg-white shadow' : ''}`}>線</button>
                                                        </div>
                                                        <SpaceTypeSelector selectedType={spaceType} onChange={setSpaceType} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />
                                                        <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} isRectShape={spaceShape === 'rect'}/>
                                                        <BackgroundSelector selected={backgroundPattern} onChange={setBackgroundPattern} />
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div>
                                                                <label htmlFor="stroke-color-picker" className="block text-sm font-medium text-gray-700">線の色</label>
                                                                <input id="stroke-color-picker" type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                            </div>
                                                            <div>
                                                                <div className="flex items-center justify-between">
                                                                     <label htmlFor="fill-color-picker" className="block text-sm font-medium text-gray-700">枠内の色</label>
                                                                     <div className="flex items-center">
                                                                        <input id="transparent-toggle" type="checkbox" checked={fillColor === 'none'} onChange={(e) => {
                                                                            if (e.target.checked) {
                                                                                setLastFillColor(fillColor);
                                                                                setFillColor('none');
                                                                            } else {
                                                                                setFillColor(lastFillColor);
                                                                            }
                                                                        }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"/>
                                                                        <label htmlFor="transparent-toggle" className="ml-2 text-sm text-gray-700">透明</label>
                                                                     </div>
                                                                </div>
                                                                <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${fillColor === 'none' ? 'transparent-bg' : ''}`}>
                                                                    <input type="color" value={fillColor === 'none' ? '#ffffff' : fillColor} onChange={(e) => setFillColor(e.target.value)} className={`h-full w-full ${fillColor === 'none' ? 'opacity-0' : ''}`} disabled={fillColor === 'none'}/>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'wall' && (
                                                    <div className="mt-4 space-y-4">
                                                        <LineStyleSelector selectedStyle={lineStyle} onChange={setLineStyle} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={strokeWidth} onChange={(e) => setStrokeWidth(parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input type="color" value={strokeColor} onChange={(e) => setStrokeColor(e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'stairs' && (
                                                    <div className="mt-4 space-y-4">
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">階段幅: {stairWidth}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="100" step="1" value={stairWidth} onChange={(e) => setStairWidth(parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={stairWidth} onChange={(e) => setStairWidth(parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">方向</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1 mt-1">
                                                                <button onClick={() => setStairDirection('up')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'up' ? 'bg-white shadow' : ''}`}>UP</button>
                                                                <button onClick={() => setStairDirection('down')} className={`w-full py-1 rounded-md text-sm ${stairDirection === 'down' ? 'bg-white shadow' : ''}`}>DN</button>
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                {drawingMode === 'door' && <div className="mt-4 space-y-4"><DoorTemplateSelector selectedTemplateId={doorTemplateId} onChange={setDoorTemplateId} /></div>}
                                                {drawingMode === 'window' && <div className="mt-4 space-y-4"><WindowTemplateSelector selectedTemplateId={windowTemplateId} onChange={setWindowTemplateId} /></div>}
                                                {drawingMode === 'fixture' && <div className="mt-4 space-y-4"><FixtureTemplateSelector selectedTemplateId={fixtureTemplateId} onChange={setFixtureTemplateId} category={fixtureCategory} /></div>}
                                                {drawingMode === 'compass' && <div className="mt-4 space-y-4"><CompassTemplateSelector selectedTemplateId={compassTemplateId} onChange={setCompassTemplateId} /></div>}
                                                {drawingMode === 'text' && <div className="mt-4 space-y-4"><p className="text-sm text-gray-600">キャンバスをクリックしてテキストを配置します。</p></div>}
                                            </>
                                        )}
                                        
                                        {editorMode === 'edit' && (
                                            <div className="mt-4 space-y-4">
                                                {!selectedElement && <p className="text-sm text-gray-600">編集したいアイテムをクリックしてください。</p>}
                                                {selectedElement?.type === 'space' && (
                                                    <>
                                                        <SpaceTypeSelector selectedType={selectedElement.spaceType} onChange={(newType) => handleSelectedGroupUpdate('spaceType', newType)} spaceTypeTab={spaceTypeTab} setSpaceTypeTab={setSpaceTypeTab} />
                                                        <LineStyleSelector selectedStyle={selectedElement.lineStyle || 'solid'} onChange={(newStyle) => handleSelectedGroupUpdate('lineStyle', newStyle)} isRectShape={true}/>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH} onChange={(e) => handleSelectedGroupUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.strokeWidth || DEFAULT_STROKE_WIDTH} onChange={(e) => handleSelectedGroupUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div className="grid grid-cols-2 gap-2">
                                                            <div><label className="block text-sm font-medium text-gray-700">線の色</label><input type="color" value={selectedElement.color || DEFAULT_STROKE_COLOR} onChange={(e) => handleSelectedGroupUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/></div>
                                                            <div>
                                                                <div className="flex items-center justify-between">
                                                                     <label className="block text-sm font-medium text-gray-700">枠内の色</label>
                                                                     <div className="flex items-center">
                                                                        <input type="checkbox" checked={selectedElement.fill === 'none'} onChange={(e) => {
                                                                            if (e.target.checked) {
                                                                                setEditLastFillColor(selectedElement.fill);
                                                                                handleSelectedGroupUpdate('fill', 'none');
                                                                            } else {
                                                                                handleSelectedGroupUpdate('fill', editLastFillColor);
                                                                            }
                                                                        }} className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"/>
                                                                        <label className="ml-2 text-sm text-gray-700">透明</label>
                                                                     </div>
                                                                </div>
                                                                <div className={`mt-1 h-10 w-full border border-gray-300 rounded-md ${selectedElement.fill === 'none' ? 'transparent-bg' : ''}`}>
                                                                    <input type="color" value={selectedElement.fill === 'none' ? '#ffffff' : selectedElement.fill} onChange={(e) => handleSelectedGroupUpdate('fill', e.target.value)} className={`h-full w-full ${selectedElement.fill === 'none' ? 'opacity-0' : ''}`} disabled={selectedElement.fill === 'none'}/>
                                                                </div>
                                                            </div>
                                                        </div>
                                                        <BackgroundSelector selected={selectedElement.backgroundPattern || 'none'} onChange={(pattern) => handleSelectedGroupUpdate('backgroundPattern', pattern)} />
                                                        <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この空間を削除</button></div>
                                                    </>
                                                )}
                                                {selectedElement?.type === 'wall' && (
                                                    <>
                                                        <LineStyleSelector selectedStyle={selectedElement.lineStyle} onChange={(v) => handleSelectedElementUpdate('lineStyle', v)} />
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の太さ</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="1" max="20" step="1" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.strokeWidth} onChange={(e) => handleSelectedElementUpdate('strokeWidth', parseInt(e.target.value) || 1)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">線の色</label>
                                                            <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/>
                                                        </div>
                                                        <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この壁を削除</button></div>
                                                    </>
                                                )}
                                                {selectedElement?.type === 'stairs' && (
                                                    <>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">階段幅: {selectedElement.width}px</label>
                                                            <div className="flex items-center space-x-2 mt-1">
                                                                <input type="range" min="20" max="100" step="1" value={selectedElement.width} onChange={(e) => handleSelectedElementUpdate('width', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/>
                                                                <input type="number" value={selectedElement.width} onChange={(e) => handleSelectedElementUpdate('width', parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" />
                                                            </div>
                                                        </div>
                                                        <div>
                                                            <label className="block text-sm font-medium text-gray-700">方向</label>
                                                            <div className="flex bg-gray-200 rounded-lg p-1 mt-1">
                                                                <button onClick={() => handleSelectedElementUpdate('direction', 'up')} className={`w-full py-1 rounded-md text-sm ${selectedElement.direction === 'up' ? 'bg-white shadow' : ''}`}>UP</button>
                                                                <button onClick={() => handleSelectedElementUpdate('direction', 'down')} className={`w-full py-1 rounded-md text-sm ${selectedElement.direction === 'down' ? 'bg-white shadow' : ''}`}>DN</button>
                                                            </div>
                                                        </div>
                                                        <div className="mt-6"><button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この階段を削除</button></div>
                                                    </>
                                                )}
                                                {selectedElement?.type === 'door' && ( <div> <h3 className="text-md font-semibold mb-2">選択中のドアを編集</h3> <DoorTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} /> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">線の色</label> <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div className="mt-2 flex space-x-2"> <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button> <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このドアを削除</button> </div> </div> )}
                                                {selectedElement?.type === 'window' && ( <div> <h3 className="text-md font-semibold mb-2">選択中の窓を編集</h3> <WindowTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} /> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">線の色</label> <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div className="mt-2 flex space-x-2"> <button onClick={rotateSelectedElement90Degrees} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">90度回転</button> <button onClick={toggleSelectedElementSwingDirection} className="flex-1 px-3 py-1 bg-gray-200 rounded hover:bg-gray-300">反転</button> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この窓を削除</button> </div> </div> )}
                                                {selectedElement?.type === 'fixture' && ( <div> <h3 className="text-md font-semibold mb-2">選択中の設備を編集</h3> <div> <label className="block text-sm font-medium text-gray-700">カテゴリ</label> <select value={fixtureCategory} onChange={(e) => setFixtureCategory(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"> {Object.keys(FIXTURE_TEMPLATES).map(cat => ( <option key={cat} value={cat}> {cat === 'kitchen' ? 'キッチン' : cat === 'bathroom' ? '浴室' : cat === 'bedroom' ? '寝室' : cat === 'livingDining' ? 'リビング・ダイニング' : 'その他'} </option> ))} </select> </div> <FixtureTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} category={fixtureCategory} /> <div> <label className="block text-sm font-medium text-gray-700">サイズ: {selectedElement.size}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="10" max="100" step="1" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value) || 10)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">塗りつぶしの色</label> <input type="color" value={selectedElement.fill} onChange={(e) => handleSelectedElementUpdate('fill', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> <div> <label className="block text-sm font-medium text-gray-700">線の色</label> <input type="color" value={selectedElement.stroke} onChange={(e) => handleSelectedElementUpdate('stroke', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この設備を削除</button> </div> </div> )}
                                                {selectedElement?.type === 'compass' && ( <div> <h3 className="text-md font-semibold mb-2">選択中の方角を編集</h3> <CompassTemplateSelector selectedTemplateId={selectedElement.templateId} onChange={(newTemplateId) => handleSelectedElementUpdate('templateId', newTemplateId)} /> <div> <label className="block text-sm font-medium text-gray-700 mt-2">サイズ</label> <div className="flex items-center space-x-2 mt-1"> <input type="range" min="20" max="300" step="1" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.size} onChange={(e) => handleSelectedElementUpdate('size', parseInt(e.target.value) || 20)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /> </div> </div> <div> <label className="block text-sm font-medium text-gray-700 mt-2">回転</label> <div className="flex items-center space-x-2 mt-1"> <input type="range" min="-180" max="180" step="1" value={selectedElement.rotation || 0} onChange={(e) => handleSelectedElementUpdate('rotation', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={Math.round(selectedElement.rotation || 0)} onChange={(e) => handleSelectedElementUpdate('rotation', parseInt(e.target.value) || 0)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /> </div> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">この方角を削除</button> </div> </div> )}
                                                {selectedElement?.type === 'text' && ( <div> <h3 className="text-md font-semibold mb-2">選択中のテキストを編集</h3> <div> <label className="block text-sm font-medium text-gray-700">テキスト</label> <textarea value={selectedElement.text} onChange={(e) => handleSelectedElementUpdate('text', e.target.value)} className="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" rows="3"></textarea> </div> <div> <label className="block text-sm font-medium text-gray-700">フォント</label> <select value={selectedElement.fontFamily} onChange={(e) => handleSelectedElementUpdate('fontFamily', e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md"> {FONT_FAMILIES.map(font => <option key={font.id} value={font.id}>{font.name}</option>)} </select> </div> <div> <label className="block text-sm font-medium text-gray-700">フォントサイズ: {selectedElement.fontSize}px</label> <div className="flex items-center space-x-2 mt-1"><input type="range" min="8" max="72" step="1" value={selectedElement.fontSize} onChange={(e) => handleSelectedElementUpdate('fontSize', parseInt(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"/> <input type="number" value={selectedElement.fontSize} onChange={(e) => handleSelectedElementUpdate('fontSize', parseInt(e.target.value) || 8)} className="w-20 p-1 border border-gray-300 rounded-md text-sm" /></div> </div> <div className="grid grid-cols-2 gap-2"> <div> <label className="block text-sm font-medium text-gray-700">文字色</label> <input type="color" value={selectedElement.color} onChange={(e) => handleSelectedElementUpdate('color', e.target.value)} className="mt-1 h-10 w-full border border-gray-300 rounded-md"/> </div> </div> <div> <label className="block text-sm font-medium text-gray-700">配置</label> <div className="flex bg-gray-200 rounded-lg p-1"> <button onClick={() => handleSelectedElementUpdate('textAlign', 'left')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'left' ? 'bg-white shadow' : ''}`}>左揃え</button> <button onClick={() => handleSelectedElementUpdate('textAlign', 'center')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'center' ? 'bg-white shadow' : ''}`}>中央揃え</button> <button onClick={() => handleSelectedElementUpdate('textAlign', 'right')} className={`w-full py-1 rounded-md text-sm ${selectedElement.textAlign === 'right' ? 'bg-white shadow' : ''}`}>右揃え</button> </div> </div> <div className="mt-6"> <button onClick={deleteSelectedElement} className="w-full px-4 py-2 rounded bg-red-600 text-white hover:bg-red-700">このテキストを削除</button> </div> </div> )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </aside>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<Editor />, document.getElementById('root'));
    </script>
</body>
</html>
